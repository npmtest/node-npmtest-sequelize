{"/home/travis/build/npmtest/node-npmtest-sequelize/test.js":"/* istanbul instrument in package npmtest_sequelize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sequelize/lib.npmtest_sequelize.js":"/* istanbul instrument in package npmtest_sequelize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sequelize = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sequelize = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sequelize/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sequelize && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sequelize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sequelize\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sequelize.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_sequelize.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sequelize.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_sequelize.__dirname +\n                    '/lib.npmtest_sequelize.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/index.js":"'use strict';\n\n/**\n  The entry point.\n  @module Sequelize\n**/\nmodule.exports = require('./lib/sequelize');\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/sequelize.js":"'use strict';\n\nvar url = require('url')\n  , Path = require('path')\n  , retry = require('retry-as-promised')\n  , Utils = require('./utils')\n  , Model = require('./model')\n  , DataTypes = require('./data-types')\n  , Deferrable = require('./deferrable')\n  , ModelManager = require('./model-manager')\n  , QueryInterface = require('./query-interface')\n  , Transaction = require('./transaction')\n  , QueryTypes = require('./query-types')\n  , sequelizeErrors = require('./errors')\n  , Promise = require('./promise')\n  , Hooks = require('./hooks')\n  , Instance = require('./instance')\n  , Association = require('./associations/index')\n  , _ = require('lodash');\n\n/**\n * This is the main class, the entry point to sequelize. To use it, you just need to import sequelize:\n *\n * ```js\n * var Sequelize = require('sequelize');\n * ```\n *\n * In addition to sequelize, the connection library for the dialect you want to use should also be installed in your project. You don't need to import it however, as sequelize will take care of that.\n *\n * @class Sequelize\n */\n\n /**\n * Instantiate sequelize with name of database, username and password\n *\n * #### Example usage\n *\n * ```javascript\n * // without password and options\n * var sequelize = new Sequelize('database', 'username')\n *\n * // without options\n * var sequelize = new Sequelize('database', 'username', 'password')\n *\n * // without password / with blank password\n * var sequelize = new Sequelize('database', 'username', null, {})\n *\n * // with password and options\n * var sequelize = new Sequelize('my_database', 'john', 'doe', {})\n *\n * // with uri (see below)\n * var sequelize = new Sequelize('mysql://localhost:3306/database', {})\n * ```\n *\n * @name Sequelize\n * @constructor\n *\n * @param {String}   database The name of the database\n * @param {String}   [username=null] The username which is used to authenticate against the database.\n * @param {String}   [password=null] The password which is used to authenticate against the database.\n * @param {Object}   [options={}] An object with options.\n * @param {String}   [options.host='localhost'] The host of the relational database.\n * @param {Integer}  [options.port=] The port of the relational database.\n * @param {String}   [options.username=null] The username which is used to authenticate against the database.\n * @param {String}   [options.password=null] The password which is used to authenticate against the database.\n * @param {String}   [options.database=null] The name of the database\n * @param {String}   [options.dialect='mysql'] The dialect of the database you are connecting to. One of mysql, postgres, sqlite, mariadb and mssql.\n * @param {String}   [options.dialectModulePath=null] If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'pg.js' here\n * @param {Object}   [options.dialectOptions] An object of additional options, which are passed directly to the connection library\n * @param {String}   [options.storage] Only used by sqlite. Defaults to ':memory:'\n * @param {String}   [options.protocol='tcp'] The protocol of the relational database.\n * @param {Object}   [options.define={}] Default options for model definitions. See sequelize.define for options\n * @param {Object}   [options.query={}] Default options for sequelize.query\n * @param {Object}   [options.set={}] Default options for sequelize.set\n * @param {Object}   [options.sync={}] Default options for sequelize.sync\n * @param {String}   [options.timezone='+00:00'] The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.\n * @param {Function} [options.logging=console.log] A function that gets executed every time Sequelize would log something.\n * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param {Boolean}  [options.omitNull=false] A flag that defines if null values should be passed to SQL queries or not.\n * @param {Boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres\n * @param {Boolean}  [options.replication=false] Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`\n * @param {Object}   [options.pool={}] Should sequelize use a connection pool. Default is true\n * @param {Integer}  [options.pool.maxConnections]\n * @param {Integer}  [options.pool.minConnections]\n * @param {Integer}  [options.pool.maxIdleTime] The maximum time, in milliseconds, that a connection can be idle before being released\n * @param {Function} [options.pool.validateConnection] A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected\n * @param {Boolean}  [options.quoteIdentifiers=true] Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.\n * @param {String}   [options.transactionType='DEFERRED'] Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.\n * @param {String}   [options.isolationLevel='REPEATABLE_READ'] Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options.\n * @param {Object}   [options.retry] Set of flags that control when a query is automatically retried.\n * @param {Array}    [options.retry.match] Only retry a query if the error matches one of these strings.\n * @param {Integer}  [options.retry.max] How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error.\n * @param {Boolean}  [options.typeValidation=false] Run built in type validators on insert and update, e.g. validate that arguments passed to integer fields are integer-like.\n*/\n\n/**\n * Instantiate sequelize with an URI\n * @name Sequelize\n * @constructor\n *\n * @param {String} uri A full database URI\n * @param {object} [options={}] See above for possible options\n*/\n\n/**\n * Instantiate sequelize with an options object\n * @name Sequelize\n * @constructor\n *\n * @param {object} [options={}] See above for possible options\n*/\nvar Sequelize = function(database, username, password, options) {\n  var config;\n\n  if (arguments.length === 1 && typeof database === 'object') {\n    // new Sequelize({ ... options })\n    options = database;\n    config = _.pick(options, 'host', 'port', 'database', 'username', 'password');\n  } else if ((arguments.length === 1 && typeof database === 'string') || (arguments.length === 2 && typeof username === 'object')) {\n    // new Sequelize(URI, { ... options })\n\n    config = {};\n    options = username || {};\n\n    var urlParts = url.parse(arguments[0]);\n\n    // SQLite don't have DB in connection url\n    if (urlParts.pathname) {\n      config.database = urlParts.pathname.replace(/^\\//, '');\n    }\n\n    options.dialect = urlParts.protocol.replace(/:$/, '');\n    options.host = urlParts.hostname;\n\n    if (urlParts.port) {\n      options.port = urlParts.port;\n    }\n\n    if (urlParts.auth) {\n      config.username = urlParts.auth.split(':')[0];\n      config.password = urlParts.auth.split(':')[1];\n    }\n  } else {\n    // new Sequelize(database, username, password, { ... options })\n    options = options || {};\n    config = {database: database, username: username, password: password};\n  }\n\n  Sequelize.runHooks('beforeInit', config, options);\n\n  this.options = Utils._.extend({\n    dialect: 'mysql',\n    dialectModulePath: null,\n    host: 'localhost',\n    protocol: 'tcp',\n    define: {},\n    query: {},\n    sync: {},\n    timezone:'+00:00',\n    logging: console.log,\n    omitNull: false,\n    native: false,\n    replication: false,\n    ssl: undefined,\n    pool: {},\n    quoteIdentifiers: true,\n    hooks: {},\n    retry: {max: 5, match: ['SQLITE_BUSY: database is locked']},\n    transactionType: Transaction.TYPES.DEFERRED,\n    isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ,\n    databaseVersion: 0,\n    typeValidation: false,\n    benchmark: false\n  }, options || {});\n\n  if (this.options.dialect === 'postgresql') {\n    this.options.dialect = 'postgres';\n  }\n\n  if (this.options.dialect === 'sqlite' && this.options.timezone !== '+00:00') {\n    throw new Error('Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.');\n  }\n\n  if (this.options.logging === true) {\n    console.log('DEPRECATION WARNING: The logging-option should be either a function or false. Default: console.log');\n    this.options.logging = console.log;\n  }\n\n  this.options.hooks = this.replaceHookAliases(this.options.hooks);\n\n  if ((['', null, false].indexOf(config.password) > -1) || (typeof config.password === 'undefined')) {\n    config.password = null;\n  }\n\n  this.config = {\n    database: config.database,\n    username: config.username,\n    password: config.password,\n    host: config.host || this.options.host,\n    port: config.port || this.options.port,\n    pool: this.options.pool,\n    protocol: this.options.protocol,\n    native: this.options.native,\n    ssl: this.options.ssl,\n    replication: this.options.replication,\n    dialectModulePath: this.options.dialectModulePath,\n    keepDefaultTimezone: this.options.keepDefaultTimezone,\n    dialectOptions: this.options.dialectOptions\n  };\n\n  var Dialect;\n  // Requiring the dialect in a switch-case to keep the\n  // require calls static. (Browserify fix)\n  switch (this.getDialect()){\n    case 'mariadb':\n      Dialect = require('./dialects/mariadb');\n      break;\n    case 'mssql':\n      Dialect = require('./dialects/mssql');\n      break;\n    case 'mysql':\n      Dialect = require('./dialects/mysql');\n      break;\n    case 'postgres':\n      Dialect = require('./dialects/postgres');\n      break;\n    case 'sqlite':\n      Dialect = require('./dialects/sqlite');\n      break;\n    default:\n      throw new Error('The dialect ' + this.getDialect() + ' is not supported. Supported dialects: mariadb, mssql, mysql, postgres, and sqlite.');\n  }\n  this.dialect = new Dialect(this);\n\n  this.dialect.QueryGenerator.typeValidation = options.typeValidation;\n\n  /**\n   * Models are stored here under the name given to `sequelize.define`\n   * @property models\n   */\n  this.models = {};\n  this.modelManager = new ModelManager(this);\n  this.connectionManager = this.dialect.connectionManager;\n\n  this.importCache = {};\n\n  this.test = {\n    $trackRunningQueries: false,\n    $runningQueries: 0,\n    trackRunningQueries: function() {\n      this.$trackRunningQueries = true;\n    },\n    verifyNoRunningQueries: function() {\n      if (this.$runningQueries > 0) throw new Error('Expected 0 running queries. '+this.$runningQueries+' queries still running');\n    }\n  };\n\n  Sequelize.runHooks('afterInit', this);\n};\n\n/**\n * Sequelize version number.\n * @property version\n */\nSequelize.version = require('../package.json').version;\n\nSequelize.options = {hooks: {}};\n\n/**\n * A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc.\n * @property Sequelize\n * @see {Sequelize}\n */\nSequelize.prototype.Sequelize = Sequelize;\n\n/**\n * A reference to sequelize utilities. Most users will not need to use these utils directly. However, you might want to use `Sequelize.Utils._`, which is a reference to the lodash library, if you don't already have it imported in your project.\n * @property Utils\n */\nSequelize.prototype.Utils = Sequelize.Utils = Utils;\n\n/**\n * A handy reference to the bluebird Promise class\n * @property Promise\n */\nSequelize.prototype.Promise = Sequelize.Promise = Promise;\n\n/**\n * Available query types for use with `sequelize.query`\n * @property QueryTypes\n */\nSequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;\n\n/**\n * Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor.\n * @property Validator\n * @see https://github.com/chriso/validator.js\n */\nSequelize.prototype.Validator = Sequelize.Validator = require('validator');\n\nSequelize.prototype.Model = Sequelize.Model = Model;\n\n/**\n * A reference to the sequelize class holding commonly used data types. The datatypes are used when defining a new model using `sequelize.define`\n * @property DataTypes\n */\nSequelize.DataTypes = DataTypes;\n\nfor (var dataType in DataTypes) {\n  Sequelize[dataType] = DataTypes[dataType];\n}\n\nObject.defineProperty(Sequelize.prototype, 'connectorManager', {\n  get: function() {\n    return this.transactionManager.getConnectorManager();\n  }\n});\n\n/**\n * A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction\n * @property Transaction\n * @see {Transaction}\n * @see {Sequelize#transaction}\n */\nSequelize.prototype.Transaction = Sequelize.Transaction = Transaction;\n\n/**\n * A reference to the deferrable collection. Use this to access the different deferrable options.\n * @property Deferrable\n * @see {Deferrable}\n * @see {Sequelize#transaction}\n */\nSequelize.prototype.Deferrable = Sequelize.Deferrable = Deferrable;\n\n/**\n * A reference to the sequelize instance class.\n * @property Instance\n * @see {Instance}\n */\nSequelize.prototype.Instance = Sequelize.Instance = Instance;\n\n/**\n * A reference to the sequelize association class.\n * @property Association\n * @see {Association}\n */\nSequelize.prototype.Association = Sequelize.Association = Association;\n\n/**\n * Allow hooks to be defined on Sequelize + on sequelize instance as universal hooks to run on all models\n * and on Sequelize/sequelize methods e.g. Sequelize(), Sequelize#define()\n */\nHooks.applyTo(Sequelize);\n\n/**\n * A general error class\n * @property Error\n * @see {Errors#BaseError}\n */\nSequelize.prototype.Error = Sequelize.Error =\n  sequelizeErrors.BaseError;\n\n/**\n * Emitted when a validation fails\n * @property ValidationError\n * @see {Errors#ValidationError}\n */\nSequelize.prototype.ValidationError = Sequelize.ValidationError =\n  sequelizeErrors.ValidationError;\n\n/**\n * Describes a validation error on an instance path\n * @property ValidationErrorItem\n * @see {Errors#ValidationErrorItem}\n */\nSequelize.prototype.ValidationErrorItem = Sequelize.ValidationErrorItem =\n  sequelizeErrors.ValidationErrorItem;\n\n/**\n * A base class for all database related errors.\n * @see {Errors#DatabaseError}\n */\nSequelize.prototype.DatabaseError = Sequelize.DatabaseError =\n  sequelizeErrors.DatabaseError;\n\n/**\n * Thrown when a database query times out because of a deadlock\n * @see {Errors#TimeoutError}\n */\nSequelize.prototype.TimeoutError = Sequelize.TimeoutError =\n  sequelizeErrors.TimeoutError;\n\n/**\n * Thrown when a unique constraint is violated in the database\n * @see {Errors#UniqueConstraintError}\n */\nSequelize.prototype.UniqueConstraintError = Sequelize.UniqueConstraintError =\n  sequelizeErrors.UniqueConstraintError;\n\n/**\n * Thrown when an exclusion constraint is violated in the database\n * @see {Errors#ExclusionConstraintError}\n */\nSequelize.prototype.ExclusionConstraintError = Sequelize.ExclusionConstraintError =\n  sequelizeErrors.ExclusionConstraintError;\n\n/**\n * Thrown when a foreign key constraint is violated in the database\n * @see {Errors#ForeignKeyConstraintError}\n */\nSequelize.prototype.ForeignKeyConstraintError = Sequelize.ForeignKeyConstraintError =\n  sequelizeErrors.ForeignKeyConstraintError;\n\n/**\n * A base class for all connection related errors.\n * @see {Errors#ConnectionError}\n */\nSequelize.prototype.ConnectionError = Sequelize.ConnectionError =\n  sequelizeErrors.ConnectionError;\n\n/**\n * Thrown when a connection to a database is refused\n * @see {Errors#ConnectionRefusedError}\n */\nSequelize.prototype.ConnectionRefusedError = Sequelize.ConnectionRefusedError =\n  sequelizeErrors.ConnectionRefusedError;\n\n/**\n * Thrown when a connection to a database is refused due to insufficient access\n * @see {Errors#AccessDeniedError}\n */\nSequelize.prototype.AccessDeniedError = Sequelize.AccessDeniedError =\n  sequelizeErrors.AccessDeniedError;\n\n/**\n * Thrown when a connection to a database has a hostname that was not found\n * @see {Errors#HostNotFoundError}\n */\nSequelize.prototype.HostNotFoundError = Sequelize.HostNotFoundError =\n  sequelizeErrors.HostNotFoundError;\n\n/**\n * Thrown when a connection to a database has a hostname that was not reachable\n * @see {Errors#HostNotReachableError}\n */\nSequelize.prototype.HostNotReachableError = Sequelize.HostNotReachableError =\n  sequelizeErrors.HostNotReachableError;\n\n/**\n * Thrown when a connection to a database has invalid values for any of the connection parameters\n * @see {Errors#InvalidConnectionError}\n */\nSequelize.prototype.InvalidConnectionError = Sequelize.InvalidConnectionError =\n  sequelizeErrors.InvalidConnectionError;\n\n/**\n * Thrown when a connection to a database times out\n * @see {Errors#ConnectionTimedOutError}\n */\nSequelize.prototype.ConnectionTimedOutError = Sequelize.ConnectionTimedOutError =\n  sequelizeErrors.ConnectionTimedOutError;\n\n/**\n * Thrown when a some problem occurred with Instance methods (see message for details)\n * @see {Errors#InstanceError}\n */\nSequelize.prototype.InstanceError = Sequelize.InstanceError =\n  sequelizeErrors.InstanceError;\n\n/**\n  * Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)\n  * @see {Errors#RecordNotFoundError}\n  */\nSequelize.prototype.EmptyResultError = Sequelize.EmptyResultError =\n  sequelizeErrors.EmptyResultError;\n\n\nSequelize.prototype.refreshTypes = function () {\n  this.connectionManager.refreshTypeParser(DataTypes);\n};\n\n/**\n * Returns the specified dialect.\n *\n * @return {String} The specified dialect.\n */\nSequelize.prototype.getDialect = function() {\n  return this.options.dialect;\n};\n\n/**\n * Returns an instance of QueryInterface.\n\n * @method getQueryInterface\n * @return {QueryInterface} An instance (singleton) of QueryInterface.\n *\n * @see {QueryInterface}\n */\nSequelize.prototype.getQueryInterface = function() {\n  this.queryInterface = this.queryInterface || new QueryInterface(this);\n  return this.queryInterface;\n};\n\n/**\n * Define a new model, representing a table in the DB.\n *\n * The table columns are define by the hash that is given as the second argument. Each attribute of the hash represents a column. A short table definition might look like this:\n *\n * ```js\n * sequelize.define('modelName', {\n *     columnA: {\n *         type: Sequelize.BOOLEAN,\n *         validate: {\n *           is: [\"[a-z]\",'i'],        // will only allow letters\n *           max: 23,                  // only allow values <= 23\n *           isIn: {\n *             args: [['en', 'zh']],\n *             msg: \"Must be English or Chinese\"\n *           }\n *         },\n *         field: 'column_a'\n *         // Other attributes here\n *     },\n *     columnB: Sequelize.STRING,\n *     columnC: 'MY VERY OWN COLUMN TYPE'\n * })\n *\n * sequelize.models.modelName // The model will now be available in models under the name given to define\n * ```\n *\n *\n * As shown above, column definitions can be either strings, a reference to one of the datatypes that are predefined on the Sequelize constructor, or an object that allows you to specify both the type of the column, and other attributes such as default values, foreign key constraints and custom setters and getters.\n *\n * For a list of possible data types, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#data-types\n *\n * For more about getters and setters, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#getters-setters\n *\n * For more about instance and class methods, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#expansion-of-models\n *\n * For more about validation, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#validations\n *\n * @see {DataTypes}\n * @see {Hooks}\n * @param {String}                  modelName The name of the model. The model will be stored in `sequelize.models` under this name\n * @param {Object}                  attributes An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below:\n * @param {String|DataType|Object}  attributes.column The description of a database column\n * @param {String|DataType}         attributes.column.type A string or a data type\n * @param {Boolean}                 [attributes.column.allowNull=true] If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.\n * @param {Any}                     [attributes.column.defaultValue=null] A literal default value, a JavaScript function, or an SQL function (see `sequelize.fn`)\n * @param {String|Boolean}          [attributes.column.unique=false] If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index\n * @param {Boolean}                 [attributes.column.primaryKey=false]\n * @param {String}                  [attributes.column.field=null] If set, sequelize will map the attribute name to a different name in the database\n * @param {Boolean}                 [attributes.column.autoIncrement=false]\n * @param {String}                  [attributes.column.comment=null]\n * @param {String|Model}            [attributes.column.references=null] An object with reference configurations\n * @param {String|Model}            [attributes.column.references.model] If this column references another table, provide it here as a Model, or a string\n * @param {String}                  [attributes.column.references.key='id'] The column of the foreign table that this column references\n * @param {String}                  [attributes.column.onUpdate] What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION\n * @param {String}                  [attributes.column.onDelete] What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION\n * @param {Function}                [attributes.column.get] Provide a custom getter for this column. Use `this.getDataValue(String)` to manipulate the underlying values.\n * @param {Function}                [attributes.column.set] Provide a custom setter for this column. Use `this.setDataValue(String, Value)` to manipulate the underlying values.\n * @param {Object}                  [attributes.validate] An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the `DAOValidator` property for more details), or a custom validation function. Custom validation functions are called with the value of the field, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation, it it is async, the callback should be called with the error text.\n\n * @param {Object}                  [options] These options are merged with the default define options provided to the Sequelize constructor\n * @param {Object}                  [options.defaultScope={}] Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll\n * @param {Object}                  [options.scopes] More scopes, defined in the same way as defaultScope above. See `Model.scope` for more information about how scopes are defined, and what you can do with them\n * @param {Boolean}                 [options.omitNull] Don't persist null values. This means that all columns with null values will not be saved\n * @param {Boolean}                 [options.timestamps=true] Adds createdAt and updatedAt timestamps to the model.\n * @param {Boolean}                 [options.paranoid=false] Calling `destroy` will not delete the model, but instead set a `deletedAt` timestamp if this is true. Needs `timestamps=true` to work\n * @param {Boolean}                 [options.underscored=false] Converts all camelCased columns to underscored if true\n * @param {Boolean}                 [options.underscoredAll=false] Converts camelCased model names to underscored table names if true\n * @param {Boolean}                 [options.freezeTableName=false] If freezeTableName is true, sequelize will not try to alter the DAO name to get the table name. Otherwise, the model name will be pluralized\n * @param {Object}                  [options.name] An object with two attributes, `singular` and `plural`, which are used when this model is associated to others.\n * @param {String}                  [options.name.singular=inflection.singularize(modelName)]\n * @param {String}                  [options.name.plural=inflection.pluralize(modelName)]\n * @param {Array<Object>}           [options.indexes]\n * @param {String}                  [options.indexes[].name] The name of the index. Defaults to model name + _ + fields concatenated\n * @param {String}                  [options.indexes[].type] Index type. Only used by mysql. One of `UNIQUE`, `FULLTEXT` and `SPATIAL`\n * @param {String}                  [options.indexes[].method] The method to create the index by (`USING` statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.\n * @param {Boolean}                 [options.indexes[].unique=false] Should the index by unique? Can also be triggered by setting type to `UNIQUE`\n * @param {Boolean}                 [options.indexes[].concurrently=false] PostgreSQL will build the index without taking any write locks. Postgres only\n * @param {Array<String|Object>}    [options.indexes[].fields] An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g `sequelize.fn`), or an object with the following attributes: `attribute` (field name), `length` (create a prefix index of length chars), `order` (the direction the column should be sorted in), `collate` (the collation (sort order) for the column)\n * @param {String|Boolean}          [options.createdAt] Override the name of the createdAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting.\n * @param {String|Boolean}          [options.updatedAt] Override the name of the updatedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting.\n * @param {String|Boolean}          [options.deletedAt] Override the name of the deletedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting.\n * @param {String}                  [options.tableName] Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim\n * @param {Object}                  [options.getterMethods] Provide getter functions that work like those defined per column. If you provide a getter method with the same name as a column, it will be used to access the value of that column. If you provide a name that does not match a column, this function will act as a virtual getter, that can fetch multiple other values\n * @param {Object}                  [options.setterMethods] Provide setter functions that work like those defined per column. If you provide a setter method with the same name as a column, it will be used to update the value of that column. If you provide a name that does not match a column, this function will act as a virtual setter, that can act on and set other values, but will not be persisted\n * @param {Object}                  [options.instanceMethods] Provide functions that are added to each instance (DAO). If you override methods provided by sequelize, you can access the original method using `this.constructor.super_.prototype`, e.g. `this.constructor.super_.prototype.toJSON.apply(this, arguments)`\n * @param {Object}                  [options.classMethods] Provide functions that are added to the model (Model). If you override methods provided by sequelize, you can access the original method using `this.constructor.prototype`, e.g. `this.constructor.prototype.find.apply(this, arguments)`\n * @param {String}                  [options.schema='public']\n * @param {String}                  [options.engine]\n * @param {String}                  [options.charset]\n * @param {String}                  [options.comment]\n * @param {String}                  [options.collate]\n * @param {String}                  [options.initialAutoIncrement] Set the initial AUTO_INCREMENT value for the table in MySQL.\n * @param {Object}                  [options.hooks] An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, validationFailed, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, afterDestroy, afterUpdate, afterBulkCreate, afterBulkDestory and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions.\n * @param {Object}                  [options.validate] An object of model wide validations. Validations have access to all model values via `this`. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error.\n *\n * @return {Model}\n */\nSequelize.prototype.define = function(modelName, attributes, options) { // testhint options:none\n  options = options || {};\n  var globalOptions = this.options;\n\n  if (globalOptions.define) {\n    options = Utils.merge(_.cloneDeep(globalOptions.define), options);\n  }\n\n  options = Utils.merge({\n    name: {\n      plural: Utils.inflection.pluralize(modelName),\n      singular: Utils.inflection.singularize(modelName)\n    },\n    indexes: [],\n    omitNul: globalOptions.omitNull\n  }, options);\n\n  // if you call \"define\" multiple times for the same modelName, do not clutter the factory\n  if (this.isDefined(modelName)) {\n    this.modelManager.removeModel(this.modelManager.getModel(modelName));\n  }\n\n  options.sequelize = this;\n\n  options.modelName = modelName;\n  this.runHooks('beforeDefine', attributes, options);\n  modelName = options.modelName;\n  delete options.modelName;\n\n  var model = new Model(modelName, attributes, options);\n  model = model.init(this.modelManager);\n  this.modelManager.addModel(model);\n\n  this.runHooks('afterDefine', model);\n\n  return model;\n};\n\n/**\n * Fetch a Model which is already defined\n *\n * @param {String} modelName The name of a model defined with Sequelize.define\n * @throws Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)\n * @return {Model}\n */\nSequelize.prototype.model = function(modelName) {\n  if (!this.isDefined(modelName)) {\n    throw new Error(modelName + ' has not been defined');\n  }\n\n  return this.modelManager.getModel(modelName);\n};\n\n/**\n * Checks whether a model with the given name is defined\n *\n * @param {String} modelName The name of a model defined with Sequelize.define\n * @return {Boolean}\n */\nSequelize.prototype.isDefined = function(modelName) {\n  var models = this.modelManager.models;\n  return (models.filter(function(model) { return model.name === modelName; }).length !== 0);\n};\n\n/**\n * Imports a model defined in another file\n *\n * Imported models are cached, so multiple calls to import with the same path will not load the file multiple times\n *\n * See https://github.com/sequelize/express-example for a short example of how to define your models in separate files so that they can be imported by sequelize.import\n * @param {String} path The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file\n * @return {Model}\n */\nSequelize.prototype.import = function(path) {\n  // is it a relative path?\n  if(Path.normalize(path) !== Path.resolve(path)){\n    // make path relative to the caller\n    var callerFilename = Utils.stack()[1].getFileName()\n      , callerPath = Path.dirname(callerFilename);\n\n    path = Path.resolve(callerPath, path);\n  }\n\n  if (!this.importCache[path]) {\n    var defineCall = (arguments.length > 1 ? arguments[1] : require(path));\n    if (typeof defineCall === 'object') {\n      // Babel/ES6 module compatability\n      defineCall = defineCall.default;\n    }\n    this.importCache[path] = defineCall(this, DataTypes);\n  }\n\n  return this.importCache[path];\n};\n\n/**\n * Execute a query on the DB, with the possibility to bypass all the sequelize goodness.\n *\n * By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc. Use `.spread` to access the results.\n *\n * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:\n *\n * ```js\n * sequelize.query('SELECT...').spread(function (results, metadata) {\n *   // Raw query - use spread\n * });\n *\n * sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }).then(function (results) {\n *   // SELECT query - use then\n * })\n * ```\n *\n * @method query\n * @param {String}          sql\n * @param {Object}          [options={}] Query options.\n * @param {Boolean}         [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result\n * @param {Transaction}     [options.transaction=null] The transaction that the query should be executed under\n * @param {String}          [options.type='RAW'] The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.\n * @param {Boolean}         [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified\n * @param {Boolean}         [options.plain=false] Sets the query type to `SELECT` and return a single row\n * @param {Object|Array}    [options.replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.\n * @param {Object|Array}    [options.bind] Either an object of named bind parameter in the format `$param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL.\n * @param {Boolean}         [options.useMaster=false] Force the query to use the write pool, regardless of the query type.\n * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Instance}        [options.instance] A sequelize instance used to build the return instance\n * @param {Model}           [options.model] A sequelize model used to build the returned model instances (used to be called callee)\n * @param {Object}          [options.retry] Set of flags that control when a query is automatically retried.\n * @param {Array}           [options.retry.match] Only retry a query if the error matches one of these strings.\n * @param {Integer}         [options.retry.max] How many times a failing query is automatically retried.\n * @param {String}          [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n * @param {Boolean}         [options.supportsSearchPath] If false do not prepend the query with the search_path (Postgres only)\n * @param {Object}          [options.mapToModel=false] Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance.\n * @param {Object}          [options.fieldMap] Map returned fields to arbitrary names for `SELECT` query type.\n *\n * @return {Promise}\n *\n * @see {Model#build} for more information about instance option.\n */\nSequelize.prototype.query = function(sql, options) {\n  if (arguments.length > 2) {\n    // TODO: Remove this note in the next major version (4.0)\n    throw new Error('Sequelize.query was refactored to only use the parameters `sql` and `options`. Please read the changelog about BC.');\n  }\n\n  var self = this;\n\n  options = _.assign({}, this.options.query, options);\n\n  if (options.instance && !options.model) {\n    options.model = options.instance.Model;\n  }\n\n  // Map raw fields to model field names using the `fieldAttributeMap`\n  if (options.model && options.mapToModel && !Utils._.isEmpty(options.model.fieldAttributeMap)) {\n    options.fieldMap =  options.model.fieldAttributeMap;\n  }\n\n  if (typeof sql === 'object') {\n    if (sql.values !== undefined) {\n      if (options.replacements !== undefined) {\n        throw new Error('Both `sql.values` and `options.replacements` cannot be set at the same time');\n      }\n\n      options.replacements = sql.values;\n    }\n\n    if (sql.bind !== undefined) {\n      if (options.bind !== undefined) {\n        throw new Error('Both `sql.bind` and `options.bind` cannot be set at the same time');\n      }\n\n      options.bind = sql.bind;\n    }\n\n    if (sql.query !== undefined) {\n      sql = sql.query;\n    }\n  }\n\n  sql = sql.trim();\n\n  if (!options.instance && !options.model) {\n    options.raw = true;\n  }\n\n  if (options.replacements && options.bind) {\n    throw new Error('Both `replacements` and `bind` cannot be set at the same time');\n  }\n  if (options.replacements) {\n    if (Array.isArray(options.replacements)) {\n      sql = Utils.format([sql].concat(options.replacements), this.options.dialect);\n    }\n    else {\n      sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);\n    }\n  }\n  var bindParameters;\n  if (options.bind) {\n    var bindSql = self.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);\n    sql = bindSql[0];\n    bindParameters = bindSql[1];\n  }\n\n  options = _.defaults(options, {\n    logging: this.options.hasOwnProperty('logging') ? this.options.logging : console.log,\n    searchPath: this.options.hasOwnProperty('searchPath') ? this.options.searchPath : 'DEFAULT',\n  });\n\n  if (options.transaction === undefined && Sequelize.cls) {\n    options.transaction = Sequelize.cls.get('transaction');\n  }\n\n  if (!options.type) {\n    if (options.model || options.nest || options.plain) {\n      options.type = QueryTypes.SELECT;\n    } else {\n      options.type = QueryTypes.RAW;\n    }\n  }\n\n  if (options.transaction && options.transaction.finished) {\n    var error = new Error(options.transaction.finished+' has been called on this transaction('+options.transaction.id+'), you can no longer use it. (The rejected query is attached as the \\'sql\\' property of this error)');\n    error.sql = sql;\n    return Promise.reject(error);\n  }\n\n  if (this.test.$trackRunningQueries) {\n    this.test.$runningQueries++;\n  }\n\n  //if dialect doesn't support search_path or dialect option\n  //to prepend searchPath is not true delete the searchPath option\n  if (!self.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath ||\n    options.supportsSearchPath === false) {\n    delete options.searchPath;\n  } else if (!options.searchPath) {\n    //if user wants to always prepend searchPath (dialectOptions.preprendSearchPath = true)\n    //then set to DEFAULT if none is provided\n    options.searchPath = 'DEFAULT';\n  }\n\n  return Promise.resolve(\n    options.transaction ? options.transaction.connection : self.connectionManager.getConnection(options)\n  ).then(function (connection) {\n\n    var query = new self.dialect.Query(connection, self, options);\n    return retry(function() {\n      return query.run(sql, bindParameters).finally(function() {\n        if (options.transaction) return;\n        return self.connectionManager.releaseConnection(connection);\n      });\n    }, Utils._.extend(self.options.retry, options.retry || {}));\n  }).finally(function () {\n    if (self.test.$trackRunningQueries) {\n      self.test.$runningQueries--;\n    }\n  });\n};\n\n/**\n * Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.\n * Only works for MySQL.\n *\n * @method set\n * @param {Object}        variables Object with multiple variables.\n * @param {Object}        options Query options.\n * @param {Transaction}   options.transaction The transaction that the query should be executed under\n *\n * @return {Promise}\n */\nSequelize.prototype.set = function( variables, options ) {\n  var query;\n\n  // Prepare options\n  options = Utils._.extend({}, this.options.set, typeof options === 'object' && options || {});\n\n  if (['mysql', 'mariadb'].indexOf(this.options.dialect) === -1) {\n    throw new Error('sequelize.set is only supported for mysql');\n  }\n  if (!options.transaction || !(options.transaction instanceof Transaction) ) {\n    throw new TypeError('options.transaction is required');\n  }\n\n  // Override some options, since this isn't a SELECT\n  options.raw = true;\n  options.plain = true;\n  options.type = 'SET';\n\n  // Generate SQL Query\n  query =\n    'SET '+\n    Utils._.map( variables, function ( v, k ) {\n      return '@'+k +' := '+ ( typeof v === 'string' ? '\"'+v+'\"' : v );\n    }).join(', ');\n\n  return this.query(query, options);\n};\n\n/**\n * Escape value.\n *\n * @param {String} value\n * @return {String}\n */\nSequelize.prototype.escape = function(value) {\n  return this.getQueryInterface().escape(value);\n};\n\n/**\n * Create a new database schema.\n *\n * Note,that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n * not a database table. In mysql and sqlite, this command will do nothing.\n *\n * @see {Model#schema}\n * @param {String} schema Name of the schema\n * @param {Object} options={}\n * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n * @return {Promise}\n */\nSequelize.prototype.createSchema = function(schema, options) {\n  return this.getQueryInterface().createSchema(schema, options);\n};\n\n/**\n * Show all defined schemas\n *\n * Note,that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n * not a database table. In mysql and sqlite, this will show all tables.\n * @param {Object} options={}\n * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n * @return {Promise}\n */\nSequelize.prototype.showAllSchemas = function(options) {\n  return this.getQueryInterface().showAllSchemas(options);\n};\n\n/**\n * Drop a single schema\n *\n * Note,that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n * not a database table. In mysql and sqlite, this drop a table matching the schema name\n * @param {String} schema Name of the schema\n * @param {Object} options={}\n * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n * @return {Promise}\n */\nSequelize.prototype.dropSchema = function(schema, options) {\n  return this.getQueryInterface().dropSchema(schema, options);\n};\n\n/**\n * Drop all schemas\n *\n * Note,that this is a schema in the [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),\n * not a database table. In mysql and sqlite, this is the equivalent of drop all tables.\n * @param {Object} options={}\n * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n * @return {Promise}\n */\nSequelize.prototype.dropAllSchemas = function(options) {\n  return this.getQueryInterface().dropAllSchemas(options);\n};\n\n/**\n * Sync all defined models to the DB.\n *\n * @param {Object} [options={}]\n * @param {Boolean} [options.force=false] If force is true, each DAO will do DROP TABLE IF EXISTS ..., before it tries to create its own table\n * @param {RegEx} [options.match] Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code\n * @param {Boolean|function} [options.logging=console.log] A function that logs sql queries, or false for no logging\n * @param {String} [options.schema='public'] The schema that the tables should be created in. This can be overriden for each table in sequelize.define\n * @param  {String} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n * @param {Boolean} [options.hooks=true] If hooks is true then beforeSync, afterSync, beforBulkSync, afterBulkSync hooks will be called\n * @return {Promise}\n */\nSequelize.prototype.sync = function(options) {\n  var self = this;\n\n  options = _.clone(options) || {};\n  options.hooks = options.hooks === undefined ? true : !!options.hooks;\n  options.logging = options.logging === undefined ? false : options.logging;\n  options = Utils._.defaults(options, this.options.sync, this.options);\n\n  if (options.match) {\n    if (!options.match.test(this.config.database)) {\n      return Promise.reject(new Error('Database does not match sync match parameter'));\n    }\n  }\n\n  return Promise.try(function () {\n    if (options.hooks) {\n      return self.runHooks('beforeBulkSync', options);\n    }\n  }).then(function () {\n    if (options.force) {\n      return self.drop(options);\n    }\n  }).then(function() {\n    var models = [];\n\n    // Topologically sort by foreign key constraints to give us an appropriate\n    // creation order\n    self.modelManager.forEachModel(function(model) {\n      if (model) {\n        models.push(model);\n      } else {\n        // DB should throw an SQL error if referencing inexistant table\n      }\n    });\n\n    return Promise.each(models, function(model) {\n      return model.sync(options);\n    });\n  }).then(function () {\n    if (options.hooks) {\n      return self.runHooks('afterBulkSync', options);\n    }\n  }).return(self);\n};\n\n/**\n * Truncate all tables defined through the sequelize models. This is done\n * by calling Model.truncate() on each model.\n *\n * @param {object} [options] The options passed to Model.destroy in addition to truncate\n * @param {Boolean|function} [options.transaction]\n * @param {Boolean|function} [options.logging] A function that logs sql queries, or false for no logging\n * @return {Promise}\n *\n * @see {Model#truncate} for more information\n */\nSequelize.prototype.truncate = function(options) {\n  var models = [];\n\n  this.modelManager.forEachModel(function(model) {\n    if (model) {\n      models.push(model);\n    }\n  }, { reverse: false });\n\n  var truncateModel = function(model) {\n    return model.truncate(options);\n  };\n\n  if (options && options.cascade) {\n    return Promise.each(models, truncateModel);\n  } else {\n    return Promise.map(models, truncateModel);\n  }\n};\n\n/**\n * Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model\n * @see {Model#drop} for options\n *\n * @param {object} options  The options passed to each call to Model.drop\n * @param {Boolean|function} options.logging A function that logs sql queries, or false for no logging\n * @return {Promise}\n */\nSequelize.prototype.drop = function(options) {\n  var models = [];\n\n  this.modelManager.forEachModel(function(model) {\n    if (model) {\n      models.push(model);\n    }\n  }, { reverse: false });\n\n  return Promise.each(models, function(model) {\n    return model.drop(options);\n  });\n};\n\n/**\n * Test the connection by trying to authenticate\n *\n * @fires success If authentication was successful\n * @error 'Invalid credentials' if the authentication failed (even if the database did not respond at all...)\n * @alias validate\n * @return {Promise}\n */\nSequelize.prototype.authenticate = function(options) {\n  return this.query('SELECT 1+1 AS result', Utils._.assign({ raw: true, plain: true }, options)).return();\n};\n\nSequelize.prototype.databaseVersion = function(options) {\n  return this.getQueryInterface().databaseVersion(options);\n};\n\nSequelize.prototype.validate = Sequelize.prototype.authenticate;\n\n/**\n * Creates a object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions.\n * If you want to refer to columns in your function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and not a strings.\n *\n * Convert a user's username to upper case\n * ```js\n * instance.updateAttributes({\n *   username: self.sequelize.fn('upper', self.sequelize.col('username'))\n * })\n * ```\n *\n * @see {Model#find}\n * @see {Model#findAll}\n * @see {Model#define}\n * @see {Sequelize#col}\n * @method fn\n *\n * @param {String} fn The function you want to call\n * @param {any} args All further arguments will be passed as arguments to the function\n *\n * @since v2.0.0-dev3\n * @return {Sequelize.fn}\n */\nSequelize.fn = Sequelize.prototype.fn = function(fn) {\n  return new Utils.fn(fn, Utils.sliceArgs(arguments, 1));\n};\n\n/**\n * Creates a object representing a column in the DB. This is often useful in conjunction with `sequelize.fn`, since raw string arguments to fn will be escaped.\n * @see {Sequelize#fn}\n *\n * @method col\n * @param {String} col The name of the column\n * @since v2.0.0-dev3\n * @return {Sequelize.col}\n */\nSequelize.col = Sequelize.prototype.col = function(col) {\n  return new Utils.col(col);\n};\n\n\n/**\n * Creates a object representing a call to the cast function.\n *\n * @method cast\n * @param {any} val The value to cast\n * @param {String} type The type to cast it to\n * @since v2.0.0-dev3\n * @return {Sequelize.cast}\n */\nSequelize.cast = Sequelize.prototype.cast = function(val, type) {\n  return new Utils.cast(val, type);\n};\n\n/**\n * Creates a object representing a literal, i.e. something that will not be escaped.\n *\n * @method literal\n * @param {any} val\n * @alias asIs\n * @since v2.0.0-dev3\n * @return {Sequelize.literal}\n */\nSequelize.literal = Sequelize.asIs = Sequelize.prototype.asIs = Sequelize.prototype.literal = function(val) {\n  return new Utils.literal(val);\n};\n\n/**\n * An AND query\n * @see {Model#find}\n *\n * @method and\n * @param {String|Object} args Each argument will be joined by AND\n * @since v2.0.0-dev3\n * @return {Sequelize.and}\n */\nSequelize.and = Sequelize.prototype.and = function() {\n  return { $and: Utils.sliceArgs(arguments) };\n};\n\n/**\n * An OR query\n * @see {Model#find}\n *\n * @method or\n * @param {String|Object} args Each argument will be joined by OR\n * @since v2.0.0-dev3\n * @return {Sequelize.or}\n */\nSequelize.or = Sequelize.prototype.or = function() {\n  return { $or: Utils.sliceArgs(arguments) };\n};\n\n/**\n * Creates an object representing nested where conditions for postgres's json data-type.\n * @see {Model#find}\n *\n * @method json\n * @param {String|Object} conditions A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres json syntax.\n * @param {String|Number|Boolean} [value] An optional value to compare against. Produces a string of the form \"<json path> = '<value>'\".\n * @return {Sequelize.json}\n */\nSequelize.json = Sequelize.prototype.json = function (conditionsOrPath, value) {\n  return new Utils.json(conditionsOrPath, value);\n};\n\n/*\n * A way of specifying attr = condition.\n *\n * The attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id` or `Model.rawAttributes.name`). The\n * attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)\n *\n * For string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your string to be escaped, use `sequelize.literal`.\n *\n * @see {Model#find}\n *\n * @param {Object} attr The attribute, which can be either an attribute object from `Model.rawAttributes` or a sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the POJO syntax\n * @param {string} [comparator='=']\n * @param {String|Object} logic The condition. Can be both a simply type, or a further condition (`$or`, `$and`, `.literal` etc.)\n * @method where\n * @alias condition\n * @since v2.0.0-dev3\n * @return {Sequelize.where}\n */\nSequelize.where = Sequelize.condition = Sequelize.prototype.condition = Sequelize.prototype.where = function(attr, comparator, logic) {\n  return new Utils.where(attr, comparator, logic);\n};\n\n/**\n * Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction\n *\n * ```js\n * sequelize.transaction().then(function (t) {\n *   return User.find(..., { transaction: t}).then(function (user) {\n *     return user.updateAttributes(..., { transaction: t});\n *   })\n *   .then(t.commit.bind(t))\n *   .catch(t.rollback.bind(t));\n * })\n * ```\n *\n * A syntax for automatically committing or rolling back based on the promise chain resolution is also supported:\n *\n * ```js\n * sequelize.transaction(function (t) { // Note that we use a callback rather than a promise.then()\n *   return User.find(..., { transaction: t}).then(function (user) {\n *     return user.updateAttributes(..., { transaction: t});\n *   });\n * }).then(function () {\n *   // Committed\n * }).catch(function (err) {\n *   // Rolled back\n *   console.error(err);\n * });\n * ```\n *\n * If you have [CLS](https://github.com/othiym23/node-continuation-local-storage) enabled, the transaction will automatically be passed to any query that runs within the callback.\n * To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:\n *\n * ```js\n * var cls = require('continuation-local-storage'),\n *     ns = cls.createNamespace('....');\n * var Sequelize = require('sequelize');\n * Sequelize.cls = ns;\n * ```\n * Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace\n *\n * @see {Transaction}\n\n * @param {Object}   [options={}]\n * @param {Boolean}  [options.autocommit=true]\n * @param {String}   [options.type='DEFERRED'] See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.\n * @param {String}   [options.isolationLevel='REPEATABLE_READ'] See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options\n * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n * @return {Promise}\n * @fires error If there is an uncaught error during the transaction\n * @fires success When the transaction has ended (either committed or rolled back)\n */\nSequelize.prototype.transaction = function(options, autoCallback) {\n  if (typeof options === 'function') {\n    autoCallback = options;\n    options = undefined;\n  }\n  // testhint argsConform.end\n\n  var transaction = new Transaction(this, options)\n    , ns = Sequelize.cls;\n\n  if (autoCallback) {\n    var transactionResolver = function (resolve, reject) {\n      transaction.prepareEnvironment().then(function () {\n        if (ns) {\n          autoCallback = ns.bind(autoCallback);\n        }\n\n        var result = autoCallback(transaction);\n        if (!result || !result.then) throw new Error('You need to return a promise chain/thenable to the sequelize.transaction() callback');\n\n        return result.then(function (result) {\n          return transaction.commit().then(function () {\n            resolve(result);\n          });\n        });\n      }).catch(function(err) {\n        // If the transaction has already finished (commit, rollback, etc), reject with the original error\n        if (transaction.finished) {\n          reject(err);\n        } else {\n          return transaction.rollback().finally(function () {\n            reject(err);\n          });\n        }\n      });\n    };\n\n    if (ns) {\n      transactionResolver = ns.bind(transactionResolver, ns.createContext());\n    }\n\n    return new Promise(transactionResolver);\n  } else {\n    return transaction.prepareEnvironment().return(transaction);\n  }\n};\n\nSequelize.prototype.log = function() {\n  var args = Utils.sliceArgs(arguments)\n    , last = Utils._.last(args)\n    , options;\n\n  if (last && Utils._.isPlainObject(last) && last.hasOwnProperty('logging')) {\n    options = last;\n\n    // remove options from set of logged arguments\n    args.splice(args.length-1, 1);\n  } else {\n    options = this.options;\n  }\n\n  if (options.logging) {\n    if (options.logging === true) {\n      console.log('DEPRECATION WARNING: The logging-option should be either a function or false. Default: console.log');\n      options.logging = console.log;\n    }\n\n    // second argument is sql-timings, when benchmarking option enabled\n    if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {\n      args = [args[0] + ' Elapsed time: ' + args[1] + 'ms'];\n    }\n\n    options.logging.apply(null, args);\n  }\n};\n\n/**\n * Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.\n *\n * Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want\n * to garbage collect some of them.\n */\nSequelize.prototype.close = function () {\n  this.connectionManager.close();\n};\n\nSequelize.prototype.normalizeDataType = function(Type) {\n  var type = typeof Type === 'function' ? new Type() : Type\n    , dialectTypes = this.dialect.DataTypes || {};\n\n  if (dialectTypes[type.key]) {\n    type = dialectTypes[type.key].extend(type);\n  }\n\n  if (type instanceof DataTypes.ARRAY && dialectTypes[type.type.key]) {\n    type.type = dialectTypes[type.type.key].extend(type.type);\n  }\n  return type;\n};\nSequelize.prototype.normalizeAttribute = function(attribute) {\n   if (!Utils._.isPlainObject(attribute)) {\n    attribute = { type: attribute };\n  }\n\n  if (!attribute.type) return attribute;\n\n  attribute.type = this.normalizeDataType(attribute.type);\n\n  if (attribute.hasOwnProperty('defaultValue')) {\n    if (typeof attribute.defaultValue === 'function' && (\n        attribute.defaultValue === DataTypes.NOW ||\n        attribute.defaultValue === DataTypes.UUIDV1 ||\n        attribute.defaultValue === DataTypes.UUIDV4\n    )) {\n      attribute.defaultValue = new attribute.defaultValue();\n    }\n  }\n\n  if (attribute.type instanceof DataTypes.ENUM) {\n    // The ENUM is a special case where the type is an object containing the values\n    if (attribute.values) {\n      attribute.type.values = attribute.type.options.values = attribute.values;\n    } else {\n      attribute.values = attribute.type.values;\n    }\n\n    if (!attribute.values.length) {\n      throw new Error('Values for ENUM have not been defined.');\n    }\n  }\n\n  return attribute;\n};\n\n// Allows the promise to access cls namespaces\nmodule.exports = Promise.Sequelize = Sequelize;\nmodule.exports.Sequelize = Sequelize;\nmodule.exports.default = Sequelize;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/utils.js":"'use strict';\n\nvar DataTypes = require('./data-types')\n  , SqlString = require('./sql-string')\n  , _ = require('lodash').runInContext() // Prevent anyone messing with template settings by creating a fresh copy\n  , parameterValidator = require('./utils/parameter-validator')\n  , inflection = require('inflection')\n  , uuid = require('uuid')\n  , deprecate = require('depd')('Utils')\n  , primitives = ['string', 'number', 'boolean'];\n\nvar Utils = module.exports = {\n  inflection: inflection,\n  _: _,\n  camelizeIf: function(string, condition) {\n    var result = string;\n\n    if (condition) {\n      result = Utils.camelize(string);\n    }\n\n    return result;\n  },\n  underscoredIf: function(string, condition) {\n    var result = string;\n\n    if (condition) {\n      result = inflection.underscore(string);\n    }\n\n    return result;\n  },\n  isPrimitive: function (val) {\n    return primitives.indexOf(typeof val) !== -1;\n  },\n  // Same concept as _.merge, but don't overwrite properties that have already been assigned\n  mergeDefaults: function (a, b) {\n    return _.mergeWith(a, b, function (objectValue, sourceValue) {\n      // If it's an object, let _ handle it this time, we will be called again for each property\n      if (!this._.isPlainObject(objectValue) && objectValue !== undefined) {\n        return objectValue;\n      }\n    }.bind(this));\n  },\n  // An alternative to _.merge, which doesn't clone its arguments\n  // Cloning is a bad idea because options arguments may contain references to sequelize\n  // models - which again reference database libs which don't like to be cloned (in particular pg-native)\n  merge: function () {\n    var result = {};\n\n    Array.prototype.slice.apply(arguments).forEach(function (obj) {\n      _.forOwn(obj, function (value, key) {\n        if (typeof value !== 'undefined') {\n          if (!result[key]) {\n            result[key] = value;\n          } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n            result[key] = Utils.merge(result[key], value);\n          } else if (Array.isArray(value) && Array.isArray(result[key])) {\n            result[key] = value.concat(result[key]);\n          } else {\n            result[key] = value;\n          }\n        }\n      });\n    });\n\n    return result;\n  },\n  lowercaseFirst: function (s) {\n    return s[0].toLowerCase() + s.slice(1);\n  },\n  uppercaseFirst: function (s) {\n    return s[0].toUpperCase() + s.slice(1);\n  },\n  spliceStr: function (str, index, count, add) {\n    return str.slice(0, index) + add + str.slice(index + count);\n  },\n  camelize: function(str){\n    return str.trim().replace(/[-_\\s]+(.)?/g, function(match, c){ return c.toUpperCase(); });\n  },\n  format: function(arr, dialect) {\n    var timeZone = null;\n    // Make a clone of the array beacuse format modifies the passed args\n    return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n  },\n  formatNamedParameters: function(sql, parameters, dialect) {\n    var timeZone = null;\n    return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n  },\n  cloneDeep: function(obj) {\n    obj = obj || {};\n    return _.cloneDeepWith(obj, function (elem) {\n      // Do not try to customize cloning of arrays or POJOs\n      if (Array.isArray(elem) || _.isPlainObject(elem)) {\n        return undefined;\n      }\n\n      // Don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n      if (typeof elem === 'object') {\n        return elem;\n      }\n\n      // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n      if (elem && typeof elem.clone === 'function') {\n        return elem.clone();\n      }\n    });\n  },\n\n  /* Expand and normalize finder options */\n  mapFinderOptions: function(options, Model) {\n    if (Model._hasVirtualAttributes && Array.isArray(options.attributes)) {\n      options.attributes.forEach(function (attribute) {\n        if (Model._isVirtualAttribute(attribute) && Model.rawAttributes[attribute].type.fields) {\n          options.attributes = options.attributes.concat(Model.rawAttributes[attribute].type.fields);\n        }\n      }.bind(Model));\n      options.attributes = _.without.apply(_, [options.attributes].concat(Model._virtualAttributes));\n      options.attributes = _.uniq(options.attributes);\n    }\n\n    Utils.mapOptionFieldNames(options, Model);\n\n    return options;\n  },\n\n  /* Used to map field names in attributes and where conditions */\n  mapOptionFieldNames: function(options, Model) {\n    if (Array.isArray(options.attributes)) {\n      options.attributes = options.attributes.map(function(attr) {\n        // Object lookups will force any variable to strings, we don't want that for special objects etc\n        if (typeof attr !== 'string') return attr;\n        // Map attributes to aliased syntax attributes\n        if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n          return [Model.rawAttributes[attr].field, attr];\n        }\n        return attr;\n      });\n    }\n\n    if (options.where && _.isPlainObject(options.where)) {\n      options.where = Utils.mapWhereFieldNames(options.where, Model);\n    }\n\n    if (Array.isArray(options.order)) {\n      options.order.forEach(function(oGroup) {\n        var OrderModel, attr, attrOffset;\n\n        if (Array.isArray(oGroup)) {\n          OrderModel = Model;\n\n          // Check if we have ['attr', 'DESC'] or [Model, 'attr', 'DESC']\n          if (typeof oGroup[oGroup.length - 2] === 'string') {\n            attrOffset = 2;\n\n          // Assume ['attr'], [Model, 'attr'] or [seq.fn('somefn', 1), 'DESC']\n          } else {\n            attrOffset = 1;\n          }\n\n          attr = oGroup[oGroup.length - attrOffset];\n          if (oGroup.length > attrOffset) {\n            OrderModel = oGroup[oGroup.length - (attrOffset + 1)];\n            if (OrderModel.model) {\n              OrderModel = OrderModel.model;\n            }\n          }\n\n          if (OrderModel.rawAttributes && OrderModel.rawAttributes[attr] && attr !== OrderModel.rawAttributes[attr].field) {\n            oGroup[oGroup.length - attrOffset] = OrderModel.rawAttributes[attr].field;\n          }\n        }\n      });\n    }\n\n    return options;\n  },\n\n  mapWhereFieldNames: function (attributes, Model) {\n    var attribute\n      , rawAttribute;\n\n    if (attributes) {\n      for (attribute in attributes) {\n        rawAttribute = Model.rawAttributes[attribute];\n\n        if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n          attributes[rawAttribute.field] = attributes[attribute];\n          delete attributes[attribute];\n        }\n\n        if (_.isPlainObject(attributes[attribute])) {\n          attributes[attribute] = Utils.mapOptionFieldNames({\n            where: attributes[attribute]\n          }, Model).where;\n        }\n\n        if (Array.isArray(attributes[attribute])) {\n          attributes[attribute] = attributes[attribute].map(function (where) {\n            if (_.isPlainObject(where)) {\n              return Utils.mapWhereFieldNames(where, Model);\n            }\n\n            return where;\n          });\n        }\n      }\n    }\n\n    return attributes;\n  },\n\n  /* Used to map field names in values */\n  mapValueFieldNames: function (dataValues, fields, Model) {\n    var values = {};\n\n    fields.forEach(function(attr) {\n      if (dataValues[attr] !== undefined && !Model._isVirtualAttribute(attr)) {\n        // Field name mapping\n        if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n          values[Model.rawAttributes[attr].field] = dataValues[attr];\n        } else {\n          values[attr] = dataValues[attr];\n        }\n      }\n    });\n\n    return values;\n  },\n\n  isColString: function(value) {\n    return typeof value === 'string' && value.substr(0, 1) === '$' && value.substr(value.length - 1, 1) === '$';\n  },\n\n  argsArePrimaryKeys: function(args, primaryKeys) {\n    var result = (args.length === Object.keys(primaryKeys).length);\n    if (result) {\n      Utils._.each(args, function(arg) {\n        if (result) {\n          if (['number', 'string'].indexOf(typeof arg) !== -1) {\n            result = true;\n          } else {\n            result = (arg instanceof Date) || Buffer.isBuffer(arg);\n          }\n        }\n      });\n    }\n    return result;\n  },\n  canTreatArrayAsAnd: function(arr) {\n    return arr.reduce(function(treatAsAnd, arg) {\n      if (treatAsAnd) {\n        return treatAsAnd;\n      } else {\n        return Utils._.isPlainObject(arg);\n      }\n    }, false);\n  },\n\n  combineTableNames: function(tableName1, tableName2) {\n    return (tableName1.toLowerCase() < tableName2.toLowerCase()) ? (tableName1 + tableName2) : (tableName2 + tableName1);\n  },\n\n  singularize: function(s) {\n    return inflection.singularize(s);\n  },\n\n  pluralize: function(s) {\n    return inflection.pluralize(s);\n  },\n\n  removeCommentsFromFunctionString: function(s) {\n    s = s.replace(/\\s*(\\/\\/.*)/g, '');\n    s = s.replace(/(\\/\\*[\\n\\r\\s\\S]*?\\*\\/)/mg, '');\n\n    return s;\n  },\n\n  toDefaultValue: function(value) {\n    if (typeof value === 'function') {\n      var tmp = value();\n      if (tmp instanceof DataTypes.ABSTRACT) {\n        return tmp.toSql();\n      } else {\n        return tmp;\n      }\n    } else if (value instanceof DataTypes.UUIDV1) {\n      return uuid.v1();\n    } else if (value instanceof DataTypes.UUIDV4) {\n      return uuid.v4();\n    } else if (value instanceof DataTypes.NOW) {\n      return Utils.now();\n    } else if(_.isPlainObject(value) || _.isArray(value)) {\n      return _.clone(value);\n    } else {\n      return value;\n    }\n  },\n\n  /**\n   * Determine if the default value provided exists and can be described\n   * in a db schema using the DEFAULT directive.\n   *\n   * @param  {*} value Any default value.\n   * @return {boolean} yes / no.\n   */\n  defaultValueSchemable: function(value) {\n    if (typeof value === 'undefined') { return false; }\n\n    // TODO this will be schemable when all supported db\n    // have been normalized for this case\n    if (value instanceof DataTypes.NOW) { return false; }\n\n    if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n    if (_.isFunction(value)) {\n      return false;\n    }\n\n    return true;\n  },\n\n  removeNullValuesFromHash: function(hash, omitNull, options) {\n    var result = hash;\n\n    options = options || {};\n    options.allowNull = options.allowNull || [];\n\n    if (omitNull) {\n      var _hash = {};\n\n      Utils._.forIn(hash, function(val, key) {\n        if (options.allowNull.indexOf(key) > -1 || key.match(/Id$/) || ((val !== null) && (val !== undefined))) {\n          _hash[key] = val;\n        }\n      });\n\n      result = _hash;\n    }\n\n    return result;\n  },\n\n  inherit: function(SubClass, SuperClass) {\n    if (SuperClass.constructor === Function) {\n      // Normal Inheritance\n      SubClass.prototype = new SuperClass();\n      SubClass.prototype.constructor = SubClass;\n      SubClass.prototype.parent = SuperClass.prototype;\n    } else {\n      // Pure Virtual Inheritance\n      SubClass.prototype = SuperClass;\n      SubClass.prototype.constructor = SubClass;\n      SubClass.prototype.parent = SuperClass;\n    }\n\n    return SubClass;\n  },\n\n\n  stack: function _stackGrabber() {\n    var orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function(_, stack) { return stack; };\n    var err = new Error();\n    Error.captureStackTrace(err, _stackGrabber);\n    var errStack = err.stack;\n    Error.prepareStackTrace = orig;\n    return errStack;\n  },\n\n  sliceArgs: function (args, begin) {\n    begin = begin || 0;\n    var tmp = new Array(args.length - begin);\n    for (var i = begin; i < args.length; ++i) {\n        tmp[i - begin] = args[i];\n    }\n    return tmp;\n  },\n\n  now: function(dialect) {\n    var now = new Date();\n    if (['postgres', 'sqlite'].indexOf(dialect) === -1) {\n      now.setMilliseconds(0);\n    }\n    return now;\n  },\n\n  tick: function(func) {\n    var tick = (global.hasOwnProperty('setImmediate') ? global.setImmediate : process.nextTick);\n    tick(func);\n  },\n\n  // Note: Use the `quoteIdentifier()` and `escape()` methods on the\n  // `QueryInterface` instead for more portable code.\n\n  TICK_CHAR: '`',\n  addTicks: function(s, tickChar) {\n    tickChar = tickChar || Utils.TICK_CHAR;\n    return tickChar + Utils.removeTicks(s, tickChar) + tickChar;\n  },\n  removeTicks: function(s, tickChar) {\n    tickChar = tickChar || Utils.TICK_CHAR;\n    return s.replace(new RegExp(tickChar, 'g'), '');\n  },\n\n  /*\n   * Utility functions for representing SQL functions, and columns that should be escaped.\n   * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n   */\n  fn: function(fn, args) {\n    this.fn = fn;\n    this.args = args;\n  },\n\n  col: function(col) {\n    if (arguments.length > 1) {\n      col = this.sliceArgs(arguments);\n    }\n    this.col = col;\n  },\n\n  cast: function(val, type) {\n    this.val = val;\n    this.type = (type || '').trim();\n  },\n\n  literal: function(val) {\n    this.val = val;\n  },\n\n  json: function(conditionsOrPath, value) {\n    if (Utils._.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  },\n\n  where: function(attribute, comparator, logic) {\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  },\n\n  validateParameter: parameterValidator,\n\n  formatReferences: function (obj) {\n    if (!_.isPlainObject(obj.references)) {\n      deprecate('Non-object references property found. Support for that will be removed in version 4. Expected { references: { model: \"value\", key: \"key\" } } instead of { references: \"value\", referencesKey: \"key\" }.');\n      obj.references = { model: obj.references, key: obj.referencesKey, deferrable: obj.referencesDeferrable };\n      obj.referencesKey = undefined;\n      obj.referencesDeferrable = undefined;\n    }\n\n    return obj;\n  }\n};\n\nUtils.where.prototype._isSequelizeMethod =\nUtils.literal.prototype._isSequelizeMethod =\nUtils.cast.prototype._isSequelizeMethod =\nUtils.fn.prototype._isSequelizeMethod =\nUtils.col.prototype._isSequelizeMethod =\nUtils.json.prototype._isSequelizeMethod = true;\n\nUtils.fn.prototype.clone = function() {\n  return new Utils.fn(this.fn, this.args);\n};\n\nUtils.Promise = require('./promise');\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/data-types.js":"'use strict';\n/*jshint -W110 */\n\nvar util = require('util')\n  , _ = require('lodash')\n  , Wkt = require('terraformer-wkt-parser')\n  , sequelizeErrors = require('./errors')\n  , warnings = {}\n  , Validator = require('validator')\n  , momentTz = require('moment-timezone')\n  , moment = require('moment');\n\n/**\n * A convenience class holding commonly used data types. The datatypes are used when defining a new model using `Sequelize.define`, like this:\n * ```js\n * sequelize.define('model', {\n *   column: DataTypes.INTEGER\n * })\n * ```\n * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\n * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n *\n * Some data types have special properties that can be accessed in order to change the data type.\n * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\n * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well. The available properties are listed under each data type.\n *\n * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n *\n * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\n * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *     primaryKey: true\n *   }\n * })\n * ```\n * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplised\n * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\n * from a function.\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: function() {\n *       return generateMyId()\n *     },\n *     primaryKey: true\n *   }\n * })\n * ```\n *\n * @class DataTypes\n */\n\nvar ABSTRACT = function(options) {\n};\n\nABSTRACT.prototype.dialectTypes = '';\n\nABSTRACT.prototype.toString = function(options) {\n  return this.toSql(options);\n};\nABSTRACT.prototype.toSql = function() {\n  return this.key;\n};\nABSTRACT.warn = function(link, text) {\n  if (!warnings[text]) {\n    warnings[text] = true;\n    console.warn('>> WARNING:', text, '\\n>> Check:', link);\n  }\n};\nABSTRACT.prototype.stringify = function (value, options) {\n  if (this.$stringify) {\n    return this.$stringify(value, options);\n  }\n  return value;\n};\n\nABSTRACT.inherits = function (Constructor) {\n  var baseType = this;\n\n  if (!Constructor) {\n    Constructor = function () {\n      if (!(this instanceof Constructor)) {\n        var args = [null].concat(arguments);\n        var FactoryFunction = Constructor.bind.apply(Constructor, args);\n        return new FactoryFunction();\n      }\n      baseType.apply(this, arguments);\n    };\n  }\n\n  util.inherits(Constructor, baseType); // Instance (prototype) methods\n  _.extend(Constructor, this); // Static methods\n\n  return Constructor;\n};\n\n\n/**\n * A variable length string. Default length 255\n *\n * Available properties: `BINARY`\n *\n * @property STRING\n */\nvar STRING = ABSTRACT.inherits(function(length, binary) {\n  var options = typeof length === 'object' && length || {\n    length: length,\n    binary: binary\n  };\n\n  if (!(this instanceof STRING)) return new STRING(options);\n\n  this.options = options;\n  this._binary = options.binary;\n  this._length = options.length || 255;\n});\n\nSTRING.prototype.key = STRING.key = 'STRING';\nSTRING.prototype.toSql = function() {\n  return 'VARCHAR(' + this._length + ')' + ((this._binary) ? ' BINARY' : '');\n};\nSTRING.prototype.validate = function(value) {\n  if (Object.prototype.toString.call(value) !== '[object String]') {\n    if ((this.options.binary && Buffer.isBuffer(value)) || _.isNumber(value)) {\n      return true;\n    }\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n  }\n\n  return true;\n};\nObject.defineProperty(STRING.prototype, 'BINARY', {\n  get: function() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n});\n\n/**\n * A fixed length string. Default length 255\n *\n * Available properties: `BINARY`\n *\n * @property CHAR\n */\nvar CHAR = STRING.inherits(function(length, binary) {\n  var options = typeof length === 'object' && length || {\n    length: length,\n    binary: binary\n  };\n\n  if (!(this instanceof CHAR)) return new CHAR(options);\n  STRING.apply(this, arguments);\n});\n\nCHAR.prototype.key = CHAR.key = 'CHAR';\nCHAR.prototype.toSql = function() {\n  return 'CHAR(' + this._length + ')' + ((this._binary) ? ' BINARY' : '');\n};\n\n/**\n * An (un)limited length text column. Available lengths: `tiny`, `medium`, `long`\n * @property TEXT\n */\nvar TEXT = ABSTRACT.inherits(function(length) {\n  var options = typeof length === 'object' && length || {\n    length: length\n  };\n  if (!(this instanceof TEXT)) return new TEXT(options);\n  this.options = options;\n  this._length = options.length || '';\n});\n\nTEXT.prototype.key = TEXT.key = 'TEXT';\nTEXT.prototype.toSql = function() {\n  switch (this._length.toLowerCase()) {\n  case 'tiny':\n    return 'TINYTEXT';\n  case 'medium':\n    return 'MEDIUMTEXT';\n  case 'long':\n    return 'LONGTEXT';\n  default:\n    return this.key;\n  }\n};\nTEXT.prototype.validate = function(value) {\n  if (!_.isString(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n   }\n\n  return true;\n};\n\nvar NUMBER = ABSTRACT.inherits(function(options) {\n  this.options = options;\n  this._length = options.length;\n  this._zerofill = options.zerofill;\n  this._decimals = options.decimals;\n  this._precision = options.precision;\n  this._scale = options.scale;\n  this._unsigned = options.unsigned;\n});\n\nNUMBER.prototype.key = NUMBER.key = 'NUMBER';\nNUMBER.prototype.toSql = function() {\n  var result = this.key;\n  if (this._length) {\n    result += '(' + this._length;\n    if (typeof this._decimals === 'number') {\n      result += ',' + this._decimals;\n    }\n    result += ')';\n  }\n  if (this._unsigned) {\n    result += ' UNSIGNED';\n  }\n  if (this._zerofill) {\n    result += ' ZEROFILL';\n  }\n  return result;\n};\n\nNUMBER.prototype.validate = function(value) {\n  if (!Validator.isFloat(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid number', value));\n  }\n\n  return true;\n};\n\nObject.defineProperty(NUMBER.prototype, 'UNSIGNED', {\n  get: function() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n});\nObject.defineProperty(NUMBER.prototype, 'ZEROFILL', {\n  get: function() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n});\n\n/**\n * A 32 bit integer.\n *\n * Available properties: `UNSIGNED`, `ZEROFILL`\n *\n * @property INTEGER\n */\nvar INTEGER = NUMBER.inherits(function(length) {\n  var options = typeof length === 'object' && length || {\n    length: length\n  };\n  if (!(this instanceof INTEGER)) return new INTEGER(options);\n  NUMBER.call(this, options);\n});\n\nINTEGER.prototype.key = INTEGER.key = 'INTEGER';\nINTEGER.prototype.validate = function(value) {\n  if (!Validator.isInt(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid integer', value));\n  }\n\n  return true;\n};\n\n/**\n * A 64 bit integer.\n *\n * Note: an attribute defined as `BIGINT` will be treated like a `string` due this [feature from node-postgres](https://github.com/brianc/node-postgres/pull/353) to prevent precision loss. To have this attribute as a `number`, this is a possible [workaround](https://github.com/sequelize/sequelize/issues/2383#issuecomment-58006083).\n *\n * Available properties: `UNSIGNED`, `ZEROFILL`\n *\n * @property BIGINT\n */\n\nvar BIGINT = NUMBER.inherits(function(length) {\n  var options = typeof length === 'object' && length || {\n    length: length\n  };\n  if (!(this instanceof BIGINT)) return new BIGINT(options);\n  NUMBER.call(this, options);\n});\n\nBIGINT.prototype.key = BIGINT.key = 'BIGINT';\nBIGINT.prototype.validate = function(value) {\n  if (!Validator.isInt(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid bigint', value));\n  }\n\n  return true;\n};\n\n/**\n * Floating point number (4-byte precision). Accepts one or two arguments for precision\n *\n * Available properties: `UNSIGNED`, `ZEROFILL`\n *\n * @property FLOAT\n */\nvar FLOAT = NUMBER.inherits(function(length, decimals) {\n  var options = typeof length === 'object' && length || {\n    length: length,\n    decimals: decimals\n  };\n  if (!(this instanceof FLOAT)) return new FLOAT(options);\n  NUMBER.call(this, options);\n});\n\nFLOAT.prototype.key = FLOAT.key = 'FLOAT';\nFLOAT.prototype.validate = function(value) {\n  if (!Validator.isFloat(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));\n  }\n\n  return true;\n};\n\n/**\n * Floating point number (4-byte precision). Accepts one or two arguments for precision\n *\n * Available properties: `UNSIGNED`, `ZEROFILL`\n *\n * @property REAL\n */\nvar REAL = NUMBER.inherits(function(length, decimals) {\n  var options = typeof length === 'object' && length || {\n    length: length,\n    decimals: decimals\n  };\n  if (!(this instanceof REAL)) return new REAL(options);\n  NUMBER.call(this, options);\n});\n\nREAL.prototype.key = REAL.key = 'REAL';\n\n/**\n * Floating point number (8-byte precision). Accepts one or two arguments for precision\n *\n * Available properties: `UNSIGNED`, `ZEROFILL`\n *\n * @property DOUBLE\n */\nvar DOUBLE = NUMBER.inherits(function(length, decimals) {\n  var options = typeof length === 'object' && length || {\n    length: length,\n    decimals: decimals\n  };\n  if (!(this instanceof DOUBLE)) return new DOUBLE(options);\n  NUMBER.call(this, options);\n});\n\nDOUBLE.prototype.key = DOUBLE.key = 'DOUBLE PRECISION';\n\n/**\n * Decimal number. Accepts one or two arguments for precision\n *\n * Available properties: `UNSIGNED`, `ZEROFILL`\n *\n * @property DECIMAL\n */\nvar DECIMAL = NUMBER.inherits(function(precision, scale) {\n  var options = typeof precision === 'object' && precision || {\n    precision: precision,\n    scale: scale\n  };\n  if (!(this instanceof DECIMAL)) return new DECIMAL(options);\n  NUMBER.call(this, options);\n});\n\nDECIMAL.prototype.key = DECIMAL.key = 'DECIMAL';\nDECIMAL.prototype.toSql = function() {\n  if (this._precision || this._scale) {\n    return 'DECIMAL(' + [this._precision, this._scale].filter(_.identity).join(',') + ')';\n  }\n\n  return 'DECIMAL';\n};\nDECIMAL.prototype.validate = function(value) {\n  if (!Validator.isDecimal(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));\n  }\n\n  return true;\n};\n\n[FLOAT, DOUBLE, REAL].forEach(function (floating) {\n  floating.prototype.escape = false;\n  floating.prototype.$stringify = function (value) {\n    if (isNaN(value)) {\n      return \"'NaN'\";\n    } else if (!isFinite(value)) {\n      var sign = value < 0 ? '-' : '';\n      return \"'\" + sign + \"Infinity'\";\n    }\n\n    return value;\n  };\n});\n\n/**\n * A boolean / tinyint column, depending on dialect\n * @property BOOLEAN\n */\nvar BOOLEAN = ABSTRACT.inherits();\n\nBOOLEAN.prototype.key = BOOLEAN.key = 'BOOLEAN';\nBOOLEAN.prototype.toSql = function() {\n  return 'TINYINT(1)';\n};\nBOOLEAN.prototype.validate = function(value) {\n  if (!Validator.isBoolean(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));\n  }\n\n  return true;\n};\n\n/**\n * A time column\n * @property TIME\n */\n\nvar TIME = ABSTRACT.inherits();\n\nTIME.prototype.key = TIME.key = 'TIME';\nTIME.prototype.toSql = function() {\n  return 'TIME';\n};\n\n/**\n * A datetime column\n * @property DATE\n */\nvar DATE = ABSTRACT.inherits(function (length) {\n  var options = typeof length === 'object' && length || {\n      length: length\n    };\n\n  if (!(this instanceof DATE)) return new DATE(options);\n\n  this.options = options;\n  this._length = options.length || '';\n});\n\nDATE.prototype.key = DATE.key = 'DATE';\nDATE.prototype.toSql = function() {\n  return 'DATETIME';\n};\nDATE.prototype.validate = function(value) {\n  if (!Validator.isDate(String(value))) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));\n  }\n\n  return true;\n};\n\nDATE.prototype.$applyTimezone = function (date, options) {\n  if (options.timezone) {\n    if (momentTz.tz.zone(options.timezone)) {\n      date = momentTz(date).tz(options.timezone);\n    } else {\n      date = moment(date).utcOffset(options.timezone);\n    }\n  } else {\n    date = momentTz(date);\n  }\n\n  return date;\n};\n\nDATE.prototype.$stringify = function (date, options) {\n  date = this.$applyTimezone(date, options);\n\n  // Z here means current timezone, _not_ UTC\n  return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n};\n\n/**\n * A date only column\n * @property DATEONLY\n */\n\nvar DATEONLY = function() {\n  if (!(this instanceof DATEONLY)) return new DATEONLY();\n  ABSTRACT.apply(this, arguments);\n};\nutil.inherits(DATEONLY, ABSTRACT);\n\nDATEONLY.prototype.key = DATEONLY.key = 'DATEONLY';\nDATEONLY.prototype.toSql = function() {\n  return 'DATE';\n};\n\n/**\n * A key / value column. Only available in postgres.\n * @property HSTORE\n */\n\nvar HSTORE = ABSTRACT.inherits();\n\nHSTORE.prototype.key = HSTORE.key = 'HSTORE';\nHSTORE.prototype.validate = function(value) {\n  if (!_.isPlainObject(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));\n  }\n\n  return true;\n};\n\n/**\n * A JSON string column. Only available in postgres.\n * @property JSON\n */\nvar JSONTYPE = function() {\n  if (!(this instanceof JSONTYPE)) return new JSONTYPE();\n  ABSTRACT.apply(this, arguments);\n};\nutil.inherits(JSONTYPE, ABSTRACT);\n\nJSONTYPE.prototype.key = JSONTYPE.key = 'JSON';\nJSONTYPE.prototype.validate = function(value) {\n  return true;\n};\n\nJSONTYPE.prototype.$stringify = function (value, options) {\n  return JSON.stringify(value);\n};\n\n/**\n * A pre-processed JSON data column. Only available in postgres.\n * @property JSONB\n */\nvar JSONB = function() {\n  if (!(this instanceof JSONB)) return new JSONB();\n  JSONTYPE.apply(this, arguments);\n};\nutil.inherits(JSONB, JSONTYPE);\n\nJSONB.prototype.key = JSONB.key = 'JSONB';\n\n/**\n * A default value of the current timestamp\n * @property NOW\n */\nvar NOW = ABSTRACT.inherits();\n\nNOW.prototype.key = NOW.key = 'NOW';\n\n/**\n * Binary storage. Available lengths: `tiny`, `medium`, `long`\n *\n * @property BLOB\n */\n\nvar BLOB = ABSTRACT.inherits(function(length) {\n  var options = typeof length === 'object' && length || {\n    length: length\n  };\n  if (!(this instanceof BLOB)) return new BLOB(options);\n  this.options = options;\n  this._length = options.length || '';\n});\n\nBLOB.prototype.key = BLOB.key = 'BLOB';\nBLOB.prototype.toSql = function() {\n  switch (this._length.toLowerCase()) {\n  case 'tiny':\n    return 'TINYBLOB';\n  case 'medium':\n    return 'MEDIUMBLOB';\n  case 'long':\n    return 'LONGBLOB';\n  default:\n    return this.key;\n  }\n};\nBLOB.prototype.validate = function(value) {\n  if (!_.isString(value) && !Buffer.isBuffer(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));\n  }\n\n  return true;\n};\n\nBLOB.prototype.escape = false;\nBLOB.prototype.$stringify = function (value) {\n  if (!Buffer.isBuffer(value)) {\n    if (Array.isArray(value)) {\n      value = new Buffer(value);\n    } else {\n      value = new Buffer(value.toString());\n    }\n  }\n  var hex = value.toString('hex');\n\n  return this.$hexify(hex);\n};\n\nBLOB.prototype.$hexify = function (hex) {\n  return \"X'\" + hex + \"'\";\n};\n\n/**\n * Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in postgres.\n * See {@link http://www.postgresql.org/docs/9.4/static/rangetypes.html|Postgres documentation} for more details\n * @property RANGE\n */\n\nvar RANGE = ABSTRACT.inherits(function (subtype) {\n  var options = _.isPlainObject(subtype) ? subtype : { subtype: subtype };\n\n  if (!options.subtype) options.subtype = new INTEGER();\n\n  if (_.isFunction(options.subtype)) {\n    options.subtype = new options.subtype();\n  }\n\n  if (!(this instanceof RANGE)) return new RANGE(options);\n  ABSTRACT.apply(this, arguments);\n\n  this._subtype = options.subtype.key;\n  this.options = options;\n});\n\nvar pgRangeSubtypes = {\n  integer: 'int4range',\n  bigint: 'int8range',\n  decimal: 'numrange',\n  dateonly: 'daterange',\n  date: 'tstzrange',\n  datenotz: 'tsrange'\n};\n\nRANGE.prototype.key = RANGE.key = 'RANGE';\nRANGE.prototype.toSql = function() {\n  return pgRangeSubtypes[this._subtype.toLowerCase()];\n};\nRANGE.prototype.validate = function(value) {\n  if (_.isPlainObject(value) && value.inclusive) {\n    value = value.inclusive;\n  }\n\n  if (!_.isArray(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));\n  }\n\n  if (value.length !== 2) {\n    throw new sequelizeErrors.ValidationError('A range must be an array with two elements');\n  }\n\n  return true;\n};\n\n\n/**\n * A column storing a unique universal identifier. Use with `UUIDV1` or `UUIDV4` for default values.\n * @property UUID\n */\nvar UUID = ABSTRACT.inherits();\n\nUUID.prototype.key = UUID.key = 'UUID';\nUUID.prototype.validate = function(value, options) {\n  if (!_.isString(value) || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n  }\n\n  return true;\n};\n\n/**\n * A default unique universal identifier generated following the UUID v1 standard\n * @property UUIDV1\n */\n\nvar UUIDV1 = function() {\n  if (!(this instanceof UUIDV1)) return new UUIDV1();\n  ABSTRACT.apply(this, arguments);\n};\nutil.inherits(UUIDV1, ABSTRACT);\n\nUUIDV1.prototype.key = UUIDV1.key = 'UUIDV1';\nUUIDV1.prototype.validate = function(value, options) {\n  if (!_.isString(value) || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n  }\n\n  return true;\n};\n\n/**\n * A default unique universal identifier generated following the UUID v4 standard\n * @property UUIDV4\n */\n\nvar UUIDV4 = function() {\n  if (!(this instanceof UUIDV4)) return new UUIDV4();\n  ABSTRACT.apply(this, arguments);\n};\nutil.inherits(UUIDV4, ABSTRACT);\n\nUUIDV4.prototype.key = UUIDV4.key = 'UUIDV4';\nUUIDV4.prototype.validate = function(value, options) {\n  if (!_.isString(value) || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));\n  }\n\n  return true;\n};\n\n/**\n * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. Checking password length before hashing it for example:\n * ```js\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        this.setDataValue('password', val); // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n * ```\n * In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n * ```js\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n * ```\n *\n * @property VIRTUAL\n * @alias NONE\n */\nvar VIRTUAL = function(ReturnType, fields) {\n  if (!(this instanceof VIRTUAL)) return new VIRTUAL(ReturnType, fields);\n  if (typeof ReturnType === 'function') ReturnType = new ReturnType();\n\n  this.returnType = ReturnType;\n  this.fields = fields;\n};\nutil.inherits(VIRTUAL, ABSTRACT);\n\nVIRTUAL.prototype.key = VIRTUAL.key = 'VIRTUAL';\n\n/**\n * An enumeration. `DataTypes.ENUM('value', 'another value')`.\n *\n * @property ENUM\n */\nvar ENUM = ABSTRACT.inherits(function(value) {\n  var options = typeof value === 'object' && !Array.isArray(value) && value || {\n    values: Array.prototype.slice.call(arguments).reduce(function(result, element) {\n      return result.concat(Array.isArray(element) ? element : [element]);\n    }, [])\n  };\n  if (!(this instanceof ENUM)) return new ENUM(options);\n  this.values = options.values;\n  this.options = options;\n});\n\nENUM.prototype.key = ENUM.key = 'ENUM';\nENUM.prototype.validate = function(value) {\n  if (!_.includes(this.values, value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));\n  }\n\n  return true;\n};\n\n/**\n * An array of `type`, e.g. `DataTypes.ARRAY(DataTypes.DECIMAL)`. Only available in postgres.\n * @property ARRAY\n */\nvar ARRAY = function(type) {\n  var options = _.isPlainObject(type) ? type : {\n    type: type\n  };\n  if (!(this instanceof ARRAY)) return new ARRAY(options);\n  this.type = typeof options.type === 'function' ? new options.type() : options.type;\n};\nutil.inherits(ARRAY, ABSTRACT);\n\nARRAY.prototype.key = ARRAY.key = 'ARRAY';\nARRAY.prototype.toSql = function() {\n  return this.type.toSql() + '[]';\n};\nARRAY.prototype.validate = function(value) {\n  if (!_.isArray(value)) {\n    throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));\n  }\n\n  return true;\n};\nARRAY.is = function(obj, type) {\n  return obj instanceof ARRAY && obj.type instanceof type;\n};\n\nvar helpers = {\n  BINARY: [STRING, CHAR],\n  UNSIGNED: [NUMBER, INTEGER, BIGINT, FLOAT, DOUBLE, REAL],\n  ZEROFILL: [NUMBER, INTEGER, BIGINT, FLOAT, DOUBLE, REAL],\n  PRECISION: [DECIMAL],\n  SCALE: [DECIMAL]\n};\n\n/**\n * A column storing Geometry information.\n *\n * Only available in PostgreSQL (with PostGIS) or MySQL.\n * In MySQL, allowable Geometry types are 'POINT', 'LINESTRING', 'POLYGON'.\n *\n * When using, GeoJSON is accepted as input and returned as output.\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\n * In MySQL it is parsed using the function `GeomFromText`.\n * Therefore, one can just follow the [GeoJSON spec](http://geojson.org/geojson-spec.html) for handling geometry objects.  See the following examples:\n *\n * ```js\n * // Create a new point:\n * var point = { type: 'Point', coordinates: [39.807222,-76.984722]};\n *\n * User.create({username: 'username', geometry: point }).then(function(newUser) {\n * ...\n * });\n *\n * // Create a new linestring:\n * var line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line }).then(function(newUser) {\n * ...\n * });\n *\n * // Create a new polygon:\n * var polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon }).then(function(newUser) {\n * ...\n * });\n\n * // Create a new point with a custom SRID:\n * var point = {\n *   type: 'Point',\n *   coordinates: [39.807222,-76.984722],\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point }).then(function(newUser) {\n * ...\n * });\n * ```\n *\n * @property GEOMETRY\n */\n\nvar GEOMETRY = ABSTRACT.inherits(function(type, srid) {\n  var options = _.isPlainObject(type) ? type : {\n    type: type,\n    srid: srid\n  };\n\n  if (!(this instanceof GEOMETRY)) return new GEOMETRY(options);\n\n  this.options = options;\n  this.type = options.type;\n  this.srid = options.srid;\n});\n\nGEOMETRY.prototype.key = GEOMETRY.key = 'GEOMETRY';\n\nGEOMETRY.prototype.escape = false;\nGEOMETRY.prototype.$stringify = function (value, options) {\n  return 'GeomFromText(' + options.escape(Wkt.convert(value)) + ')';\n};\n\n/**\n * A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n * @property GEOGRAPHY\n */\n\nvar GEOGRAPHY = ABSTRACT.inherits(function(type, srid) {\n  var options = _.isPlainObject(type) ? type : {\n    type: type,\n    srid: srid\n  };\n\n  if (!(this instanceof GEOGRAPHY)) return new GEOGRAPHY(options);\n\n  this.options = options;\n  this.type = options.type;\n  this.srid = options.srid;\n});\n\nGEOGRAPHY.prototype.key = GEOGRAPHY.key = 'GEOGRAPHY';\n\nGEOGRAPHY.prototype.escape = false;\nGEOGRAPHY.prototype.$stringify = function (value, options) {\n  return 'GeomFromText(' + options.escape(Wkt.convert(value)) + ')';\n};\n\nObject.keys(helpers).forEach(function (helper) {\n  helpers[helper].forEach(function (DataType) {\n    if (!DataType[helper]) {\n      Object.defineProperty(DataType, helper, {\n        get: function() {\n          var dataType = new DataType();\n          if (typeof dataType[helper] === 'object') {\n            return dataType;\n          }\n          return dataType[helper].apply(dataType, arguments);\n        }\n      });\n    }\n  });\n});\n\nvar dataTypes = {\n  ABSTRACT: ABSTRACT,\n  STRING: STRING,\n  CHAR: CHAR,\n  TEXT: TEXT,\n  NUMBER: NUMBER,\n  INTEGER: INTEGER,\n  BIGINT: BIGINT,\n  FLOAT: FLOAT,\n  TIME: TIME,\n  DATE: DATE,\n  DATEONLY: DATEONLY,\n  BOOLEAN: BOOLEAN,\n  NOW: NOW,\n  BLOB: BLOB,\n  DECIMAL: DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID: UUID,\n  UUIDV1: UUIDV1,\n  UUIDV4: UUIDV4,\n  HSTORE: HSTORE,\n  JSON: JSONTYPE,\n  JSONB: JSONB,\n  VIRTUAL: VIRTUAL,\n  ARRAY: ARRAY,\n  NONE: VIRTUAL,\n  ENUM: ENUM,\n  RANGE: RANGE,\n  REAL: REAL,\n  DOUBLE: DOUBLE,\n  'DOUBLE PRECISION': DOUBLE,\n  GEOMETRY: GEOMETRY,\n  GEOGRAPHY: GEOGRAPHY\n};\n\n_.each(dataTypes, function (dataType) {\n  dataType.types = {};\n});\n\ndataTypes.postgres = require('./dialects/postgres/data-types')(dataTypes);\ndataTypes.mysql = require('./dialects/mysql/data-types')(dataTypes);\ndataTypes.mariadb = dataTypes.mysql;\ndataTypes.sqlite = require('./dialects/sqlite/data-types')(dataTypes);\ndataTypes.mssql = require('./dialects/mssql/data-types')(dataTypes);\n\nmodule.exports = dataTypes;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/errors.js":"'use strict';\n\n/**\n * Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.\n * All sequelize errors inherit from the base JS error object.\n *\n * @fileOverview The Error Objects produced by Sequelize.\n * @class Errors\n */\n\nvar util = require('util');\nvar error = module.exports = {};\n\n/**\n * The Base Error all Sequelize Errors inherit from.\n *\n * @constructor\n * @alias Error\n */\nerror.BaseError = function() {\n  var tmp = Error.apply(this, arguments);\n  tmp.name = this.name = 'SequelizeBaseError';\n\n  this.message = tmp.message;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, this.constructor);\n};\nutil.inherits(error.BaseError, Error);\n\n\n/**\n * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\n * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.\n *\n * @param {string} message Error message\n * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors\n *\n * @extends BaseError\n * @constructor\n */\nerror.ValidationError = function(message, errors) {\n  error.BaseError.apply(this, arguments);\n  this.name = 'SequelizeValidationError';\n  this.message = 'Validation Error';\n/**\n * An array of ValidationErrorItems\n * @member errors\n */\n  this.errors = errors || [];\n\n  // Use provided error message if available...\n  if (message) {\n    this.message = message;\n\n  // ... otherwise create a concatenated message out of existing errors.\n  } else if (this.errors.length > 0 && this.errors[0].message) {\n    this.message = this.errors.map(function(err) {\n      return err.type + ': ' + err.message;\n    }).join(',\\n');\n  }\n};\nutil.inherits(error.ValidationError, error.BaseError);\n\n/**\n * Gets all validation error items for the path / field specified.\n *\n * @param {string} path The path to be checked for error items\n * @returns {Array} Validation error items for the specified path\n */\nerror.ValidationError.prototype.get = function(path) {\n  return this.errors.reduce(function(reduced, error) {\n    if (error.path === path) {\n      reduced.push(error);\n    }\n    return reduced;\n  }, []);\n};\n\n/**\n * A base class for all database related errors.\n * @extends BaseError\n * @constructor\n */\nerror.DatabaseError = function (parent) {\n  error.BaseError.apply(this, [parent.message]);\n  this.name = 'SequelizeDatabaseError';\n\n/**\n * The database specific error which triggered this one\n * @member parent\n */\n  this.parent = parent;\n  this.original = parent;\n/**\n * The SQL that triggered the error\n * @member sql\n */\n  this.sql = parent.sql;\n/**\n * The message from the DB.\n * @member message\n * @name message\n */\n/**\n * The fields of the unique constraint\n * @member fields\n * @name fields\n */\n/**\n * The value(s) which triggered the error\n * @member value\n * @name value\n */\n/**\n * The name of the index that triggered the error\n * @member index\n * @name index\n */\n};\nutil.inherits(error.DatabaseError, error.BaseError);\n\n/**\n * Thrown when a database query times out because of a deadlock\n * @extends DatabaseError\n * @constructor\n */\nerror.TimeoutError = function (parent) {\n  error.DatabaseError.call(this, parent);\n  this.name = 'SequelizeTimeoutError';\n};\nutil.inherits(error.TimeoutError, error.BaseError);\n\n /**\n * Thrown when a unique constraint is violated in the database\n * @extends DatabaseError\n * @constructor\n */\nerror.UniqueConstraintError = function (options) {\n  options = options || {};\n  options.parent = options.parent || { sql: '' };\n  options.message = options.message || options.parent.message || 'Validation Error';\n  options.errors = options.errors || {};\n\n  error.ValidationError.call(this, options.message, options.errors);\n  this.name = 'SequelizeUniqueConstraintError';\n  this.message = options.message;\n  this.errors = options.errors;\n  this.fields = options.fields;\n  this.parent = options.parent;\n  this.original = options.parent;\n  this.sql = options.parent.sql;\n};\nutil.inherits(error.UniqueConstraintError, error.ValidationError);\n\n/**\n * Thrown when a foreign key constraint is violated in the database\n * @extends DatabaseError\n * @constructor\n */\nerror.ForeignKeyConstraintError = function (options) {\n  options = options || {};\n  options.parent = options.parent || { sql: '' };\n\n  error.DatabaseError.call(this, options.parent);\n  this.name = 'SequelizeForeignKeyConstraintError';\n\n  this.message = options.message || options.parent.message || 'Database Error';\n  this.fields = options.fields;\n  this.table = options.table;\n  this.value = options.value;\n  this.index = options.index;\n};\nutil.inherits(error.ForeignKeyConstraintError, error.DatabaseError);\n\n/**\n * Thrown when an exclusion constraint is violated in the database\n * @extends DatabaseError\n * @constructor\n */\nerror.ExclusionConstraintError = function (options) {\n  options = options || {};\n  options.parent = options.parent || { sql: '' };\n\n  error.DatabaseError.call(this, options.parent);\n  this.name = 'SequelizeExclusionConstraintError';\n\n  this.message = options.message || options.parent.message;\n  this.constraint = options.constraint;\n  this.fields = options.fields;\n  this.table = options.table;\n};\nutil.inherits(error.ExclusionConstraintError, error.DatabaseError);\n\n/**\n * Validation Error Item\n * Instances of this class are included in the `ValidationError.errors` property.\n *\n * @param {string} message An error message\n * @param {string} type The type of the validation error\n * @param {string} path The field that triggered the validation error\n * @param {string} value The value that generated the error\n * @constructor\n */\nerror.ValidationErrorItem = function(message, type, path, value) {\n  this.message = message || '';\n  this.type = type || null;\n  this.path = path || null;\n  this.value = value || null;\n};\n\n/**\n * A base class for all connection related errors.\n * @extends BaseError\n * @constructor\n */\nerror.ConnectionError = function (parent) {\n  error.BaseError.apply(this, [parent ? parent.message : '']);\n  this.name = 'SequelizeConnectionError';\n/**\n * The connection specific error which triggered this one\n * @member parent\n */\n  this.parent = parent;\n  this.original = parent;\n};\nutil.inherits(error.ConnectionError, error.BaseError);\n\n/**\n * Thrown when a connection to a database is refused\n * @extends ConnectionError\n * @constructor\n */\nerror.ConnectionRefusedError = function (parent) {\n  error.ConnectionError.call(this, parent);\n  this.name = 'SequelizeConnectionRefusedError';\n};\nutil.inherits(error.ConnectionRefusedError, error.ConnectionError);\n\n/**\n * Thrown when a connection to a database is refused due to insufficient privileges\n * @extends ConnectionError\n * @constructor\n */\nerror.AccessDeniedError = function (parent) {\n  error.ConnectionError.call(this, parent);\n  this.name = 'SequelizeAccessDeniedError';\n};\nutil.inherits(error.AccessDeniedError, error.ConnectionError);\n\n/**\n * Thrown when a connection to a database has a hostname that was not found\n * @extends ConnectionError\n * @constructor\n */\nerror.HostNotFoundError = function (parent) {\n  error.ConnectionError.call(this, parent);\n  this.name = 'SequelizeHostNotFoundError';\n};\nutil.inherits(error.HostNotFoundError, error.ConnectionError);\n\n/**\n * Thrown when a connection to a database has a hostname that was not reachable\n * @extends ConnectionError\n * @constructor\n */\nerror.HostNotReachableError = function (parent) {\n  error.ConnectionError.call(this, parent);\n  this.name = 'SequelizeHostNotReachableError';\n};\nutil.inherits(error.HostNotReachableError, error.ConnectionError);\n\n/**\n * Thrown when a connection to a database has invalid values for any of the connection parameters\n * @extends ConnectionError\n * @constructor\n */\nerror.InvalidConnectionError = function (parent) {\n  error.ConnectionError.call(this, parent);\n  this.name = 'SequelizeInvalidConnectionError';\n};\nutil.inherits(error.InvalidConnectionError, error.ConnectionError);\n\n/**\n * Thrown when a connection to a database times out\n * @extends ConnectionError\n * @constructor\n */\nerror.ConnectionTimedOutError = function (parent) {\n  error.ConnectionError.call(this, parent);\n  this.name = 'SequelizeConnectionTimedOutError';\n};\nutil.inherits(error.ConnectionTimedOutError, error.ConnectionError);\n\n/**\n * Thrown when a some problem occurred with Instance methods (see message for details)\n * @extends BaseError\n * @constructor\n */\nerror.InstanceError = function (message) {\n  error.BaseError.apply(this, arguments);\n  this.name = 'SequelizeInstanceError';\n  this.message = message;\n};\nutil.inherits(error.InstanceError, error.BaseError);\n\n/**\n * Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)\n * @extends BaseError\n * @constructor\n */\nerror.EmptyResultError = function (message) {\n  error.BaseError.apply(this, arguments);\n  this.name = 'SequelizeEmptyResultError';\n  this.message = message;\n};\nutil.inherits(error.EmptyResultError, error.BaseError);\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/postgres/data-types.js":"'use strict';\n\n/*jshint -W110 */\n\nvar _ = require('lodash')\n  , wkx = require('wkx');\n\nmodule.exports = function (BaseTypes) {\n  var warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n\n  BaseTypes.UUID.types.postgres = {\n    oids: [2950],\n    array_oids: [2951]\n  };\n\n  BaseTypes.JSON.types.postgres = {\n    oids: [114],\n    array_oids: [199]\n  };\n\n  BaseTypes.JSONB.types.postgres = {\n    oids: [3802],\n    array_oids: [3807]\n  };\n\n  BaseTypes.DATEONLY.types.postgres = {\n    oids: [1082],\n    array_oids: [1182]\n  };\n\n  BaseTypes.TIME.types.postgres = {\n    oids: [1083],\n    array_oids: [1183]\n  };\n\n  var DECIMAL = BaseTypes.DECIMAL.inherits();\n\n  DECIMAL.parse = function (value) {\n    return value;\n  };\n\n  // numeric\n  BaseTypes.DECIMAL.types.postgres = {\n    oids: [1700],\n    array_oids: [1231]\n  };\n\n  var STRING = BaseTypes.STRING.inherits();\n  STRING.prototype.toSql = function () {\n    if (this._binary) {\n      return 'BYTEA';\n    }\n    return BaseTypes.STRING.prototype.toSql.call(this);\n  };\n\n  BaseTypes.STRING.types.postgres = {\n    oids: [1043],\n    array_oids: [1015]\n  };\n\n  var TEXT = BaseTypes.TEXT.inherits();\n\n  TEXT.prototype.toSql = function() {\n    if (this._length) {\n      warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n      this._length = undefined;\n    }\n    return 'TEXT';\n  };\n\n  BaseTypes.TEXT.types.postgres = {\n    oids: [25],\n    array_oids: [1009]\n  };\n\n  var CHAR = BaseTypes.CHAR.inherits();\n\n  CHAR.prototype.toSql = function() {\n    if (this._binary) {\n      return 'BYTEA';\n    }\n    return BaseTypes.CHAR.prototype.toSql.call(this);\n  };\n\n  BaseTypes.CHAR.types.postgres = {\n    oids: [18, 1042],\n    array_oids: [1002, 1014]\n  };\n\n  var BOOLEAN = BaseTypes.BOOLEAN.inherits();\n\n  BOOLEAN.prototype.toSql = function() {\n    return 'BOOLEAN';\n  };\n\n  BaseTypes.BOOLEAN.types.postgres = {\n    oids: [16],\n    array_oids: [1000]\n  };\n\n  var DATE = BaseTypes.DATE.inherits();\n\n  DATE.prototype.toSql = function() {\n    return 'TIMESTAMP WITH TIME ZONE';\n  };\n\n  BaseTypes.DATE.types.postgres = {\n    oids: [1184],\n    array_oids: [1185]\n  };\n\n  var INTEGER = BaseTypes.INTEGER.inherits(function() {\n    if (!(this instanceof INTEGER)) return new INTEGER();\n    BaseTypes.INTEGER.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for integer\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support INTEGER with options. Plain `INTEGER` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  });\n\n  INTEGER.parse = function (value) {\n    return parseInt(value, 10);\n  };\n\n  // int4\n  BaseTypes.INTEGER.types.postgres = {\n    oids: [23],\n    array_oids: [1007]\n  };\n\n  var BIGINT = BaseTypes.BIGINT.inherits(function() {\n    if (!(this instanceof BIGINT)) return new BIGINT();\n    BaseTypes.BIGINT.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for bigint\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support BIGINT with options. Plain `BIGINT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  });\n\n  // int8\n  BaseTypes.BIGINT.types.postgres = {\n    oids: [20],\n    array_oids: [1016]\n  };\n\n  var REAL = BaseTypes.REAL.inherits(function() {\n    if (!(this instanceof REAL)) return new REAL();\n    BaseTypes.REAL.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for real\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support REAL with options. Plain `REAL` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  });\n\n  // float4\n  BaseTypes.REAL.types.postgres = {\n    oids: [700],\n    array_oids: [1021]\n  };\n\n  var DOUBLE = BaseTypes.DOUBLE.inherits(function() {\n    if (!(this instanceof DOUBLE)) return new DOUBLE();\n    BaseTypes.DOUBLE.apply(this, arguments);\n\n    // POSTGRES does not support any parameters for double\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('PostgreSQL does not support DOUBLE with options. Plain `DOUBLE` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  });\n\n  // float8\n  BaseTypes.DOUBLE.types.postgres = {\n    oids: [701],\n    array_oids: [1022]\n  };\n\n  var FLOAT = BaseTypes.FLOAT.inherits(function() {\n    if (!(this instanceof FLOAT)) return new FLOAT();\n    BaseTypes.FLOAT.apply(this, arguments);\n\n    // POSTGRES does only support lengths as parameter.\n    // Values between 1-24 result in REAL\n    // Values between 25-53 result in DOUBLE PRECISION\n    // If decimals are provided remove these and print a warning\n    if (this._decimals) {\n      warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._decimals = undefined;\n    }\n    if (this._unsigned) {\n      warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n      this._unsigned = undefined;\n    }\n    if (this._zerofill) {\n      warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n      this._zerofill = undefined;\n    }\n  });\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  var BLOB = BaseTypes.BLOB.inherits();\n\n  BLOB.prototype.toSql = function() {\n    if (this._length) {\n      warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n      this._length = undefined;\n    }\n    return 'BYTEA';\n  };\n\n  BLOB.prototype.$hexify = function (hex) {\n    // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n      return \"E'\\\\\\\\x\" + hex + \"'\";\n  };\n\n  BaseTypes.BLOB.types.postgres = {\n    oids: [17],\n    array_oids: [1001]\n  };\n\n  var GEOMETRY = BaseTypes.GEOMETRY.inherits();\n\n  GEOMETRY.prototype.toSql = function() {\n    var result = this.key;\n\n    if (this.type){\n      result += '(' + this.type;\n\n      if (this.srid){\n        result += ',' + this.srid;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  };\n\n  BaseTypes.GEOMETRY.types.postgres = {\n    oids: [],\n    array_oids: []\n  };\n\n  GEOMETRY.parse = GEOMETRY.prototype.parse = function(value) {\n    var b = new Buffer(value, 'hex');\n    return wkx.Geometry.parse(b).toGeoJSON();\n  };\n\n  GEOMETRY.prototype.$stringify = function (value, options) {\n    return 'ST_GeomFromGeoJSON(' + options.escape(JSON.stringify(value)) + ')';\n  };\n\n  var GEOGRAPHY = BaseTypes.GEOGRAPHY.inherits();\n\n  GEOGRAPHY.prototype.toSql = function() {\n    var result = 'GEOGRAPHY';\n\n    if (this.type){\n      result += '(' + this.type;\n\n      if (this.srid){\n        result += ',' + this.srid;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  };\n\n  BaseTypes.GEOGRAPHY.types.postgres = {\n    oids: [],\n    array_oids: []\n  };\n\n  GEOGRAPHY.parse = GEOGRAPHY.prototype.parse = function(value) {\n    var b = new Buffer(value, 'hex');\n    return wkx.Geometry.parse(b).toGeoJSON();\n  };\n\n  GEOGRAPHY.prototype.$stringify = function (value, options) {\n    return 'ST_GeomFromGeoJSON(' + options.escape(JSON.stringify(value)) + ')';\n  };\n\n  var hstore;\n  var HSTORE = BaseTypes.HSTORE.inherits(function () {\n    if (!(this instanceof HSTORE)) return new HSTORE();\n    BaseTypes.HSTORE.apply(this, arguments);\n\n    if (!hstore) {\n      // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n      hstore = require('./hstore');\n    }\n  });\n\n  HSTORE.parse = function (value) {\n    if (!hstore) {\n      // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n      hstore = require('./hstore');\n    }\n    return hstore.parse(value);\n  };\n\n  HSTORE.prototype.escape = false;\n  HSTORE.prototype.$stringify = function (value) {\n    if (!hstore) {\n      // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n      hstore = require('./hstore');\n    }\n    return \"'\" + hstore.stringify(value) + \"'\";\n  };\n\n  BaseTypes.HSTORE.types.postgres = {\n    oids: [],\n    array_oids: []\n  };\n\n  var RANGE = BaseTypes.RANGE.inherits();\n\n  RANGE.oid_map = {\n    3904: 23, // int4\n    3905: 23,\n    3906: 1700, // Numeric\n    3907: 1700,\n    3908: 1114, // timestamp\n    3909: 1114,\n    3910: 1184, // timestamptz\n    3911: 1184,\n    3912: 1082, // date\n    3913: 1082,\n    3926: 20,    // int8\n    3927: 20,\n  };\n\n  var range = require('./range');\n  RANGE.parse = function (value, oid, getTypeParser) {\n    var parser = getTypeParser(RANGE.oid_map[oid]);\n\n    return range.parse(value, parser);\n  };\n\n  RANGE.prototype.escape = false;\n  RANGE.prototype.$stringify = function (values, options) {\n    var valuesStringified = values.map(function (value) {\n      if (this.options.subtype.stringify) {\n        return this.options.subtype.stringify(value, options);\n      } else {\n        return options.escape(value);\n      }\n    }, this);\n\n    // Array.map does not preserve extra array properties\n    valuesStringified.inclusive = values.inclusive;\n\n    return  '\\'' + range.stringify(valuesStringified) + '\\'';\n  };\n\n  BaseTypes.RANGE.types.postgres = {\n    oids: [3904, 3906, 3908, 3910, 3912, 3926],\n    array_oids: [3905, 3907, 3909, 3911, 3913, 3927]\n  };\n\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype.$stringify = function (values, options) {\n    var str = 'ARRAY[' + values.map(function (value) {\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this).join(',') + ']';\n\n    if (this.type) {\n      str += '::' + this.toSql();\n    }\n\n    return str;\n  };\n\n  var exports = {\n    DECIMAL: DECIMAL,\n    BLOB: BLOB,\n    STRING: STRING,\n    CHAR: CHAR,\n    TEXT: TEXT,\n    INTEGER: INTEGER,\n    BOOLEAN: BOOLEAN,\n    DATE: DATE,\n    BIGINT: BIGINT,\n    REAL: REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT: FLOAT,\n    GEOMETRY: GEOMETRY,\n    GEOGRAPHY: GEOGRAPHY,\n    HSTORE: HSTORE,\n    RANGE: RANGE\n  };\n\n  _.forIn(exports, function (DataType, key) {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = function(oldType) {\n        return new DataType(oldType.options);\n      };\n    }\n  });\n\n  return exports;\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/postgres/range.js":"'use strict';\n\nvar _ = require('lodash');\n\nfunction stringifyRangeBound (bound) {\n  if (bound === null) {\n    return '' ;\n  } else if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  } else {\n    return JSON.stringify(bound);\n  }\n}\n\nfunction parseRangeBound (bound, parseType) {\n  if (!bound) {\n    return null;\n  } else if (bound === 'infinity') {\n    return Infinity;\n  } else if (bound === '-infinity') {\n    return -Infinity;\n  } else {\n    return parseType(bound);\n  }\n}\n\nfunction stringify (data) {\n  if (data === null) return null;\n\n  if (!_.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (data.hasOwnProperty('inclusive')) {\n    if (!data.inclusive) data.inclusive = [false, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [false, false];\n  }\n\n  _.each(data, function (value, index) {\n    if (_.isObject(value)) {\n      if (value.hasOwnProperty('inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (value.hasOwnProperty('value')) data[index] = value.value;\n    }\n  });\n\n  var lowerBound = stringifyRangeBound(data[0]);\n  var upperBound = stringifyRangeBound(data[1]);\n\n  return (data.inclusive[0] ? '[' : '(') + lowerBound + ',' + upperBound + (data.inclusive[1] ? ']' : ')');\n}\n\nfunction parse (value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    var empty = [];\n    empty.inclusive = [];\n    return empty;\n  }\n\n  var result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result\n    .map(function (value) {\n      return parseRangeBound(value, parser);\n    });\n\n  result.inclusive = [(value[0] === '['), (value[value.length - 1] === ']')];\n\n  return result;\n}\n\nmodule.exports = {\n  stringify: stringify,\n  parse: parse\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/mysql/data-types.js":"'use strict';\n\nvar wkx = require('wkx')\n  , _ = require('lodash')\n  , moment = require('moment-timezone');\n\nmodule.exports = function (BaseTypes) {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.mysql.com/doc/refman/5.7/en/data-types.html';\n\n  BaseTypes.DATE.types.mysql = ['DATETIME'];\n  BaseTypes.STRING.types.mysql = ['VAR_STRING'];\n  BaseTypes.CHAR.types.mysql = ['STRING'];\n  BaseTypes.TEXT.types.mysql = ['BLOB'];\n  BaseTypes.INTEGER.types.mysql = ['LONG'];\n  BaseTypes.BIGINT.types.mysql = ['LONGLONG'];\n  BaseTypes.FLOAT.types.mysql = ['FLOAT'];\n  BaseTypes.TIME.types.mysql = ['TIME'];\n  BaseTypes.DATEONLY.types.mysql = ['DATE'];\n  BaseTypes.BOOLEAN.types.mysql = ['TINY'];\n  BaseTypes.BLOB.types.mysql = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.mysql = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.mysql = ['DOUBLE'];\n\n  var DATE = BaseTypes.DATE.inherits();\n\n  DATE.prototype.toSql = function () {\n    return 'DATETIME' + (this._length ? '(' + this._length + ')' : '');\n  };\n\n  DATE.prototype.$stringify = function (date, options) {\n    date = BaseTypes.DATE.prototype.$applyTimezone(date, options);\n    // Fractional DATETIMEs only supported on MySQL 5.6.4+\n    if (this._length) {\n      return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n    }\n\n    return date.format('YYYY-MM-DD HH:mm:ss');\n  };\n\n  DATE.parse = function (value, options) {\n    value = value.string();\n\n    if (value === null) {\n      return value;\n    }\n\n    if (moment.tz.zone(options.timezone)) {\n      value = moment.tz(value, options.timezone).toDate();\n    } else {\n      value = new Date(value + ' ' + options.timezone);\n    }\n\n    return value;\n  };\n\n  var UUID = BaseTypes.UUID.inherits();\n\n  UUID.prototype.toSql = function() {\n    return 'CHAR(36) BINARY';\n  };\n\n  var SUPPORTED_GEOMETRY_TYPES = ['POINT', 'LINESTRING', 'POLYGON'];\n  var GEOMETRY = BaseTypes.GEOMETRY.inherits(function() {\n    if (!(this instanceof GEOMETRY)) return new GEOMETRY();\n    BaseTypes.GEOMETRY.apply(this, arguments);\n\n    if (_.isEmpty(this.type)) {\n      this.sqlType = this.key;\n    } else if (_.includes(SUPPORTED_GEOMETRY_TYPES, this.type)) {\n      this.sqlType = this.type;\n    } else {\n      throw new Error('Supported geometry types are: ' + SUPPORTED_GEOMETRY_TYPES.join(', '));\n    }\n  });\n\n  GEOMETRY.parse = GEOMETRY.prototype.parse = function(value) {\n    value = value.buffer();\n\n    //MySQL doesn't support POINT EMPTY, https://dev.mysql.com/worklog/task/?id=2381\n    if (value === null) {\n      return null;\n    }\n\n    // For some reason, discard the first 4 bytes\n    value = value.slice(4);\n\n    return wkx.Geometry.parse(value).toGeoJSON();\n  };\n\n  GEOMETRY.prototype.toSql = function() {\n    return this.sqlType;\n  };\n\n  var ENUM = BaseTypes.ENUM.inherits();\n\n  ENUM.prototype.toSql = function (options) {\n    return 'ENUM(' + _.map(this.values, function(value) {\n      return options.escape(value);\n    }).join(', ') + ')';\n  };\n\n  BaseTypes.GEOMETRY.types.mysql = ['GEOMETRY'];\n\n  var exports = {\n    ENUM: ENUM,\n    DATE: DATE,\n    UUID: UUID,\n    GEOMETRY: GEOMETRY\n  };\n\n  _.forIn(exports, function (DataType, key) {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = function(oldType) {\n        return new DataType(oldType.options);\n      };\n    }\n  });\n\n  return exports;\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/sqlite/data-types.js":"'use strict';\n\nvar _ = require('lodash');\n\nmodule.exports = function (BaseTypes) {\n  var warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');\n\n  BaseTypes.DATE.types.sqlite = ['DATETIME'];\n  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];\n  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];\n  BaseTypes.TEXT.types.sqlite = ['TEXT'];\n  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];\n  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];\n  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];\n  BaseTypes.TIME.types.sqlite = ['TIME'];\n  BaseTypes.DATEONLY.types.sqlite = ['DATE'];\n  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];\n  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];\n  BaseTypes.UUID.types.sqlite = ['UUID'];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = ['REAL'];\n  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n\n  var DATE = BaseTypes.DATE.inherits();\n  DATE.parse = function (date, options) {\n    if (date.indexOf('+') === -1) {\n      // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set\n      return new Date(date + options.timezone);\n    } else {\n      return new Date(date); // We already have a timezone stored in the string\n    }\n  };\n\n  var STRING = BaseTypes.STRING.inherits();\n  STRING.prototype.toSql = function() {\n    if (this._binary) {\n      return 'VARCHAR BINARY(' + this._length + ')';\n    } else {\n      return BaseTypes.STRING.prototype.toSql.call(this);\n    }\n  };\n\n  var TEXT = BaseTypes.TEXT.inherits();\n  TEXT.prototype.toSql = function() {\n    if (this._length) {\n      warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');\n      this._length = undefined;\n    }\n    return 'TEXT';\n  };\n\n  var CHAR = BaseTypes.CHAR.inherits();\n  CHAR.prototype.toSql = function() {\n    if (this._binary) {\n      return 'CHAR BINARY(' + this._length + ')';\n    } else {\n      return BaseTypes.CHAR.prototype.toSql.call(this);\n    }\n  };\n\n  var NUMBER = BaseTypes.NUMBER.inherits();\n  NUMBER.prototype.toSql = function() {\n    var result = this.key;\n\n    if (this._unsigned) {\n      result += ' UNSIGNED';\n    }\n    if (this._zerofill) {\n      result += ' ZEROFILL';\n    }\n\n    if (this._length) {\n      result += '(' + this._length;\n      if (typeof this._decimals === 'number') {\n        result += ',' + this._decimals;\n      }\n      result += ')';\n    }\n    return result;\n  };\n\n  var INTEGER = BaseTypes.INTEGER.inherits(function(length) {\n    var options = typeof length === 'object' && length || {\n      length: length\n    };\n    if (!(this instanceof INTEGER)) return new INTEGER(options);\n    BaseTypes.INTEGER.call(this, options);\n  });\n  INTEGER.prototype.key = INTEGER.key = 'INTEGER';\n  INTEGER.prototype.toSql = function() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  var BIGINT = BaseTypes.BIGINT.inherits(function(length) {\n    var options = typeof length === 'object' && length || {\n      length: length\n    };\n    if (!(this instanceof BIGINT)) return new BIGINT(options);\n    BaseTypes.BIGINT.call(this, options);\n  });\n  BIGINT.prototype.key = BIGINT.key = 'BIGINT';\n  BIGINT.prototype.toSql = function() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  var FLOAT = BaseTypes.FLOAT.inherits(function(length, decimals) {\n    var options = typeof length === 'object' && length || {\n      length: length,\n      decimals: decimals\n    };\n    if (!(this instanceof FLOAT)) return new FLOAT(options);\n    BaseTypes.FLOAT.call(this, options);\n  });\n  FLOAT.prototype.key = FLOAT.key = 'FLOAT';\n  FLOAT.prototype.toSql = function() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  var DOUBLE = BaseTypes.DOUBLE.inherits(function(length, decimals) {\n    var options = typeof length === 'object' && length || {\n      length: length,\n      decimals: decimals\n    };\n    if (!(this instanceof DOUBLE)) return new DOUBLE(options);\n    BaseTypes.DOUBLE.call(this, options);\n  });\n  DOUBLE.prototype.key = DOUBLE.key = 'DOUBLE PRECISION';\n  DOUBLE.prototype.toSql = function() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  var REAL = BaseTypes.REAL.inherits(function(length, decimals) {\n    var options = typeof length === 'object' && length || {\n      length: length,\n      decimals: decimals\n    };\n    if (!(this instanceof REAL)) return new REAL(options);\n    BaseTypes.REAL.call(this, options);\n  });\n  REAL.prototype.key = REAL.key = 'REAL';\n  REAL.prototype.toSql = function() {\n    return NUMBER.prototype.toSql.call(this);\n  };\n\n  [FLOAT, DOUBLE, REAL].forEach(function (floating) {\n    floating.parse = function (value) {\n      if (_.isString(value)) {\n        if (value === 'NaN') {\n          return NaN;\n        } else if (value === 'Infinity') {\n          return Infinity;\n        } else if (value === '-Infinity') {\n          return -Infinity;\n        }\n      }\n      return value;\n    };\n  });\n\n  var ENUM = BaseTypes.ENUM.inherits();\n\n  ENUM.prototype.toSql = function () {\n    return 'TEXT';\n  };\n\n  var exports = {\n    DATE: DATE,\n    STRING: STRING,\n    CHAR: CHAR,\n    NUMBER: NUMBER,\n    FLOAT: FLOAT,\n    REAL: REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    INTEGER: INTEGER,\n    BIGINT: BIGINT,\n    TEXT: TEXT,\n    ENUM: ENUM\n  };\n\n  _.forIn(exports, function (DataType, key) {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = function(oldType) {\n        return new DataType(oldType.options);\n      };\n    }\n  });\n\n  return exports;\n\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/mssql/data-types.js":"'use strict';\n\nvar _ = require('lodash');\n\nmodule.exports = function (BaseTypes) {\n  var warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx');\n\n  BaseTypes.DATE.types.mssql = [42];\n  BaseTypes.STRING.types.mssql = [231, 173];\n  BaseTypes.CHAR.types.mssql = [175];\n  BaseTypes.TEXT.types.mssql = false;\n  BaseTypes.INTEGER.types.mssql = [38];\n  BaseTypes.BIGINT.types.mssql = false;\n  BaseTypes.FLOAT.types.mssql = [109];\n  BaseTypes.TIME.types.mssql = [41];\n  BaseTypes.DATEONLY.types.mssql = [40];\n  BaseTypes.BOOLEAN.types.mssql = [104];\n  BaseTypes.BLOB.types.mssql = [165];\n  BaseTypes.DECIMAL.types.mssql = [106];\n  BaseTypes.UUID.types.mssql = false;\n  BaseTypes.ENUM.types.mssql = false;\n  BaseTypes.REAL.types.mssql = [109];\n  BaseTypes.DOUBLE.types.mssql = [109];\n  // BaseTypes.GEOMETRY.types.mssql = [240]; // not yet supported\n  BaseTypes.GEOMETRY.types.mssql = false;\n\n  var BLOB = BaseTypes.BLOB.inherits();\n\n  BLOB.prototype.toSql = function() {\n    if (this._length) {\n      if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8\n        warn('MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.');\n        return 'VARBINARY(256)';\n      }\n      warn('MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.');\n    }\n    return 'VARBINARY(MAX)';\n  };\n\n  BLOB.prototype.$hexify = function (hex) {\n    return '0x' + hex;\n  };\n\n  var STRING = BaseTypes.STRING.inherits();\n\n  STRING.prototype.toSql = function() {\n    if (!this._binary) {\n      return 'NVARCHAR(' + this._length + ')';\n    } else{\n      return 'BINARY(' + this._length + ')';\n    }\n  };\n\n  STRING.prototype.escape = false;\n  STRING.prototype.$stringify = function (value, options) {\n    if (this._binary) {\n      return BLOB.prototype.$stringify(value);\n    } else {\n      return options.escape(value);\n    }\n  };\n\n  var TEXT = BaseTypes.TEXT.inherits();\n\n  TEXT.prototype.toSql = function() {\n    // TEXT is deprecated in mssql and it would normally be saved as a non-unicode string.\n    // Using unicode is just future proof\n    if (this._length) {\n      if (this._length.toLowerCase() === 'tiny') { // tiny = 2^8\n        warn('MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.');\n        return 'NVARCHAR(256)';\n      }\n      warn('MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.');\n    }\n    return 'NVARCHAR(MAX)';\n  };\n\n  var BOOLEAN = BaseTypes.BOOLEAN.inherits();\n\n  BOOLEAN.prototype.toSql = function() {\n    return 'BIT';\n  };\n\n  var UUID = BaseTypes.UUID.inherits();\n\n  UUID.prototype.toSql = function() {\n    return 'CHAR(36)';\n  };\n\n  var NOW = BaseTypes.NOW.inherits();\n\n  NOW.prototype.toSql = function() {\n    return 'GETDATE()';\n  };\n\n  var DATE = BaseTypes.DATE.inherits();\n\n  DATE.prototype.toSql = function() {\n    return 'DATETIME2';\n  };\n\n  DATE.prototype.$stringify = function (date, options) {\n    date = this.$applyTimezone(date, options);\n\n    // mssql not allow +timezone datetime format\n    return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n  };\n\n  var INTEGER = BaseTypes.INTEGER.inherits(function() {\n    if (!(this instanceof INTEGER)) return new INTEGER();\n    BaseTypes.INTEGER.apply(this, arguments);\n\n    // MSSQL does not support any options for integer\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('MSSQL does not support INTEGER with options. Plain `INTEGER` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  });\n\n  var BIGINT = BaseTypes.BIGINT.inherits(function() {\n    if (!(this instanceof BIGINT)) return new BIGINT();\n    BaseTypes.BIGINT.apply(this, arguments);\n\n    // MSSQL does not support any options for bigint\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('MSSQL does not support BIGINT with options. Plain `BIGINT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  });\n\n  var REAL = BaseTypes.REAL.inherits(function() {\n    if (!(this instanceof REAL)) return new REAL();\n    BaseTypes.REAL.apply(this, arguments);\n\n    // MSSQL does not support any options for real\n    if (this._length || this.options.length || this._unsigned || this._zerofill) {\n      warn('MSSQL does not support REAL with options. Plain `REAL` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n      this._unsigned = undefined;\n      this._zerofill = undefined;\n    }\n  });\n\n  var FLOAT = BaseTypes.FLOAT.inherits(function() {\n    if (!(this instanceof FLOAT)) return new FLOAT();\n    BaseTypes.FLOAT.apply(this, arguments);\n\n    // MSSQL does only support lengths as option.\n    // Values between 1-24 result in 7 digits precision (4 bytes storage size)\n    // Values between 25-53 result in 15 digits precision (8 bytes storage size)\n    // If decimals are provided remove these and print a warning\n    if (this._decimals) {\n      warn('MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.');\n      this._length = undefined;\n      this.options.length = undefined;\n    }\n    if (this._unsigned) {\n      warn('MSSQL does not support Float unsigned. `UNSIGNED` was removed.');\n      this._unsigned = undefined;\n    }\n    if (this._zerofill) {\n      warn('MSSQL does not support Float zerofill. `ZEROFILL` was removed.');\n      this._zerofill = undefined;\n    }\n  });\n\n  var ENUM = BaseTypes.ENUM.inherits();\n  ENUM.prototype.toSql = function() {\n    return 'VARCHAR(255)';\n  };\n\n  var exports = {\n    BLOB: BLOB,\n    BOOLEAN: BOOLEAN,\n    ENUM: ENUM,\n    STRING: STRING,\n    UUID: UUID,\n    DATE: DATE,\n    NOW: NOW,\n    INTEGER: INTEGER,\n    BIGINT: BIGINT,\n    REAL: REAL,\n    FLOAT: FLOAT,\n    TEXT: TEXT\n  };\n\n  _.forIn(exports, function (DataType, key) {\n    if (!DataType.key) DataType.key = key;\n    if (!DataType.extend) {\n      DataType.extend = function(oldType) {\n        return new DataType(oldType.options);\n      };\n    }\n  });\n\n  return exports;\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/sql-string.js":"'use strict';\n\n/* jshint -W110 */\nvar dataTypes = require('./data-types')\n  , _ = require('lodash')\n  , SqlString = exports;\n\nSqlString.escapeId = function(val, forbidQualified) {\n  if (forbidQualified) {\n    return '`' + val.replace(/`/g, '``') + '`';\n  }\n  return '`' + val.replace(/`/g, '``').replace(/\\./g, '`.`') + '`';\n};\n\nSqlString.escape = function(val, timeZone, dialect, format) {\n  var prependN = false;\n  if (val === undefined || val === null) {\n    return 'NULL';\n  }\n  switch (typeof val) {\n  case 'boolean':\n    // SQLite doesn't have true/false support. MySQL aliases true/false to 1/0\n    // for us. Postgres actually has a boolean type with true/false literals,\n    // but sequelize doesn't use it yet.\n    if (dialect === 'sqlite' || dialect === 'mssql') {\n      return +!!val;\n    }\n    return '' + !!val;\n  case 'number':\n    return val + '';\n  case 'string':\n    // In mssql, prepend N to all quoted vals which are originally a string (for\n    // unicode compatibility)\n    prependN = dialect === 'mssql';\n    break;\n  }\n\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });\n  }\n\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n\n  if (Array.isArray(val)) {\n    var escape = _.partial(SqlString.escape, _, timeZone, dialect, format);\n    if (dialect === 'postgres' && !format) {\n      return dataTypes.ARRAY.prototype.stringify(val, {escape: escape});\n    }\n    return val.map(escape);\n  }\n\n  if (dialect === 'postgres' || dialect === 'sqlite' || dialect === 'mssql') {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\\\'\\\"\\x1a]/g, function(s) {\n      switch (s) {\n        case '\\0': return '\\\\0';\n        case '\\n': return '\\\\n';\n        case '\\r': return '\\\\r';\n        case '\\b': return '\\\\b';\n        case '\\t': return '\\\\t';\n        case '\\x1a': return '\\\\Z';\n        default: return '\\\\' + s;\n      }\n    });\n  }\n  return (prependN ? \"N'\" : \"'\") + val + \"'\";\n};\n\nSqlString.format = function(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  return sql.replace(/\\?/g, function(match) {\n    if (!values.length) {\n      return match;\n    }\n\n    return SqlString.escape(values.shift(), timeZone, dialect, true);\n  });\n};\n\nSqlString.formatNamedParameters = function(sql, values, timeZone, dialect) {\n  return sql.replace(/\\:+(?!\\d)(\\w+)/g, function(value, key) {\n    if ('postgres' === dialect && '::' === value.slice(0, 2)) {\n      return value;\n    }\n\n    if (values[key] !== undefined) {\n      return SqlString.escape(values[key], timeZone, dialect, true);\n    } else {\n      throw new Error('Named parameter \"' + value + '\" has no value in the given object.');\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/utils/parameter-validator.js":"'use strict';\n\nvar _ = require('lodash');\nvar util = require('util');\n\nfunction validateDeprecation (value, expectation, options) {\n  if (!options.deprecated) {\n    return;\n  }\n\n  var valid = value instanceof options.deprecated || Object.prototype.toString.call(value) === Object.prototype.toString.call(options.deprecated.call());\n\n  if (valid) {\n    var message = util.format('%s should not be of type \"%s\"', util.inspect(value), options.deprecated.name);\n\n    console.log('DEPRECATION WARNING:', options.deprecationWarning || message);\n  }\n\n  return valid;\n}\n\nfunction validate (value, expectation) {\n  // the second part of this check is a workaround to deal with an issue that occurs in node-webkit when\n  // using object literals.  https://github.com/sequelize/sequelize/issues/2685\n  if (value instanceof expectation || Object.prototype.toString.call(value) === Object.prototype.toString.call(expectation.call())) {\n    return true;\n  }\n\n  throw new Error(util.format('The parameter (value: %s) is no %s.', value, expectation.name));\n}\n\nfunction check (value, expectation, options) {\n  options = _.extend({\n    deprecated: false,\n    index: null,\n    method: null,\n    optional: false\n  }, options || {});\n\n  if (!value && options.optional) {\n    return true;\n  }\n\n  if (value === undefined) {\n    throw new Error('No value has been passed.');\n  }\n\n  if (expectation === undefined) {\n    throw new Error('No expectation has been passed.');\n  }\n\n  return false\n    || validateDeprecation(value, expectation, options)\n    || validate(value, expectation, options);\n}\n\nmodule.exports = check;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/promise.js":"'use strict';\n\nvar Promise = require('bluebird')\n  , shimmer = require('shimmer');\n\n// functionName: The Promise function that should be shimmed\n// fnArgs: The arguments index that should be CLS enabled (typically all callbacks). Offset from last if negative\nfunction shimCLS(object, functionName, fnArgs){\n  shimmer.wrap(object, functionName, function(fn) {\n    return function () {\n      if (Promise.Sequelize && Promise.Sequelize.cls) {\n        var ns = Promise.Sequelize.cls;\n        for(var x=0; x<fnArgs.length; x++) {\n          var argIndex = fnArgs[x] < 0 ? arguments.length + fnArgs[x] : fnArgs[x];\n          if ( argIndex < arguments.length && typeof arguments[argIndex] === 'function' ) {\n            arguments[argIndex] = ns.bind( arguments[argIndex] );\n          }\n        }\n      }\n\n      return fn.apply(this, arguments);\n    };\n  });\n}\n\n// Core\nshimCLS(Promise, 'join', [-1]);\nshimCLS(Promise.prototype, 'then', [0, 1, 2]);\nshimCLS(Promise.prototype, 'spread', [0, 1]);\nshimCLS(Promise.prototype, 'catch', [-1]);\nshimCLS(Promise.prototype, 'error', [0]);\nshimCLS(Promise.prototype, 'finally', [0]);\n\n// Collections\nshimCLS(Promise, 'map', [1]);\nshimCLS(Promise, 'mapSeries', [1]);\nshimCLS(Promise, 'reduce', [1]);\nshimCLS(Promise, 'filter', [1]);\nshimCLS(Promise, 'each', [1]);\nshimCLS(Promise.prototype, 'map', [0]);\nshimCLS(Promise.prototype, 'mapSeries', [0]);\nshimCLS(Promise.prototype, 'reduce', [0]);\nshimCLS(Promise.prototype, 'filter', [0]);\nshimCLS(Promise.prototype, 'each', [0]);\n\n// Promisification\nshimCLS(Promise.prototype, 'nodeify', [0]);\n\n// Utility\nshimCLS(Promise.prototype, 'tap', [0]);\n\n// Error management configuration\nshimCLS(Promise.prototype, 'done', [0, 1]);\n\nmodule.exports = Promise;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/model.js":"'use strict';\n\n/* jshint -W110 */\n\nvar Utils = require('./utils')\n  , Instance = require('./instance')\n  , Association = require('./associations/base')\n  , HasMany = require('./associations/has-many')\n  , DataTypes = require('./data-types')\n  , Util = require('util')\n  , Promise = require('./promise')\n  , QueryTypes = require('./query-types')\n  , Hooks = require('./hooks')\n  , sequelizeErrors = require('./errors')\n  , _ = require('lodash')\n  , associationsMixin = require('./associations/mixin');\n\n/**\n * A Model represents a table in the database. Sometimes you might also see it referred to as model, or simply as factory.\n * This class should _not_ be instantiated directly, it is created using `sequelize.define`, and already created models can be loaded using `sequelize.import`\n *\n * @class Model\n * @mixes Hooks\n * @mixes Associations\n */\nvar Model = function(name, attributes, options) {\n\n  this.options = Utils._.extend({\n    timestamps: true,\n    instanceMethods: {},\n    classMethods: {},\n    validate: {},\n    freezeTableName: false,\n    underscored: false,\n    underscoredAll: false,\n    paranoid: false,\n    rejectOnEmpty: false,\n    whereCollection: null,\n    schema: null,\n    schemaDelimiter: '',\n    defaultScope: {},\n    scopes: [],\n    hooks: {},\n    indexes: []\n  }, options || {});\n\n  this.associations = {};\n  this.modelManager = null;\n  this.name = name;\n  this.options.hooks = _.mapValues(this.replaceHookAliases(this.options.hooks), function (hooks) {\n    if (!Array.isArray(hooks)) hooks = [hooks];\n    return hooks;\n  });\n\n  this.sequelize = options.sequelize;\n  this.underscored = this.underscored || this.underscoredAll;\n\n  if (!this.options.tableName) {\n    this.tableName = this.options.freezeTableName ? name : Utils.underscoredIf(Utils.pluralize(name), this.options.underscoredAll);\n  } else {\n    this.tableName = this.options.tableName;\n  }\n\n  this.$schema = this.options.schema;\n  this.$schemaDelimiter = this.options.schemaDelimiter;\n\n  // error check options\n  _.each(options.validate, function(validator, validatorType) {\n    if (_.includes(Utils._.keys(attributes), validatorType)) {\n      throw new Error('A model validator function must not have the same name as a field. Model: ' + name + ', field/validation name: ' + validatorType);\n    }\n\n    if (!_.isFunction(validator)) {\n      throw new Error('Members of the validate option must be functions. Model: ' + name + ', error with validate member ' + validatorType);\n    }\n  });\n\n this.attributes = this.rawAttributes = _.mapValues(attributes, function(attribute, name) {\n   if (!Utils._.isPlainObject(attribute)) {\n     attribute = { type: attribute };\n   }\n\n\n    attribute = this.sequelize.normalizeAttribute(attribute);\n\n    if (attribute.references) {\n      attribute = Utils.formatReferences(attribute);\n\n      if (attribute.references.model instanceof Model) {\n        attribute.references.model = attribute.references.model.tableName;\n      }\n    }\n\n    if (attribute.type === undefined) {\n      throw new Error('Unrecognized data type for field ' + name);\n    }\n\n    return attribute;\n  }.bind(this));\n};\n\nObject.defineProperty(Model.prototype, 'QueryInterface', {\n  get: function() {\n    return this.modelManager.sequelize.getQueryInterface();\n  }\n});\n\nObject.defineProperty(Model.prototype, 'QueryGenerator', {\n  get: function() {\n    return this.QueryInterface.QueryGenerator;\n  }\n});\n\nModel.prototype.toString = function () {\n  return '[object SequelizeModel:'+this.name+']';\n};\n\n// private\n\n// validateIncludedElements should have been called before this method\nvar paranoidClause = function(model, options) {\n  options = options || {};\n\n  // Apply on each include\n  // This should be handled before handling where conditions because of logic with returns\n  // otherwise this code will never run on includes of a already conditionable where\n  if (options.include) {\n    options.include.forEach(function(include) {\n      paranoidClause(include.model, include);\n    });\n  }\n\n  // apply paranoid when groupedLimit is used\n  if (_.get(options, 'groupedLimit.on.options.paranoid')) {\n    var throughModel = _.get(options, 'groupedLimit.on.through.model');\n    if (throughModel) {\n      options.groupedLimit.through = paranoidClause(throughModel, options.groupedLimit.through);\n    }\n  }\n\n  if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {\n    // This model is not paranoid, nothing to do here;\n    return options;\n  }\n\n  var deletedAtCol = model._timestampAttributes.deletedAt\n    , deletedAtAttribute = model.rawAttributes[deletedAtCol]\n    , deletedAtObject = {}\n    , deletedAtDefaultValue = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n  deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n\n  if (Utils._.isEmpty(options.where)) {\n    options.where = deletedAtObject;\n  } else {\n    options.where = { $and: [deletedAtObject, options.where] };\n  }\n\n  return options;\n};\n\nvar addOptionalClassMethods = function() {\n  var self = this;\n  Utils._.each(this.options.classMethods || {}, function(fct, name) { self[name] = fct; });\n};\n\nvar addDefaultAttributes = function() {\n  var self = this\n    , tail = {}\n    , head = {};\n\n  // Add id if no primary key was manually added to definition\n  // Can't use this.primaryKeys here, since this function is called before PKs are identified\n  if (!_.some(this.rawAttributes, 'primaryKey')) {\n    if ('id' in this.rawAttributes) {\n      // Something is fishy here!\n      throw new Error(\"A column called 'id' was added to the attributes of '\" + this.tableName + \"' but not marked with 'primaryKey: true'\");\n    }\n\n    head = {\n      id: {\n        type: new DataTypes.INTEGER(),\n        allowNull: false,\n        primaryKey: true,\n        autoIncrement: true,\n        _autoGenerated: true\n      }\n    };\n  }\n\n  if (this._timestampAttributes.createdAt) {\n    tail[this._timestampAttributes.createdAt] = {\n      type: DataTypes.DATE,\n      allowNull: false,\n      _autoGenerated: true\n    };\n  }\n  if (this._timestampAttributes.updatedAt) {\n    tail[this._timestampAttributes.updatedAt] = {\n      type: DataTypes.DATE,\n      allowNull: false,\n      _autoGenerated: true\n    };\n  }\n  if (this._timestampAttributes.deletedAt) {\n    tail[this._timestampAttributes.deletedAt] = {\n      type: DataTypes.DATE,\n      _autoGenerated: true\n    };\n  }\n\n  var existingAttributes = Utils._.clone(self.rawAttributes);\n  self.rawAttributes = {};\n\n  Utils._.each(head, function(value, attr) {\n    self.rawAttributes[attr] = value;\n  });\n\n  Utils._.each(existingAttributes, function(value, attr) {\n    self.rawAttributes[attr] = value;\n  });\n\n  Utils._.each(tail, function(value, attr) {\n    if (Utils._.isUndefined(self.rawAttributes[attr])) {\n      self.rawAttributes[attr] = value;\n    }\n  });\n\n  if (!Object.keys(this.primaryKeys).length) {\n    self.primaryKeys.id = self.rawAttributes.id;\n  }\n};\n\nvar findAutoIncrementField = function() {\n  var fields = this.QueryGenerator.findAutoIncrementField(this);\n\n  this.autoIncrementField = null;\n\n  fields.forEach(function(field) {\n    if (this.autoIncrementField) {\n      throw new Error('Invalid Instance definition. Only one autoincrement field allowed.');\n    } else {\n      this.autoIncrementField = field;\n    }\n  }.bind(this));\n};\n\nfunction conformOptions(options, self) {\n  if (self) {\n    self.$expandAttributes(options);\n  }\n\n  if (!options.include) {\n    return;\n  }\n  // if include is not an array, wrap in an array\n  if (!Array.isArray(options.include)) {\n    options.include = [options.include];\n  } else if (!options.include.length) {\n    delete options.include;\n    return;\n  }\n\n  // convert all included elements to { model: Model } form\n  options.include = options.include.map(function(include) {\n    include = conformInclude(include, self);\n\n    return include;\n  });\n}\n\nModel.$conformOptions = conformOptions;\n\nfunction conformInclude(include, self) {\n  var model;\n\n  if (include._pseudo) return include;\n\n  if (include instanceof Association) {\n    if (self && include.target.name === self.name) {\n      model = include.source;\n    } else {\n      model = include.target;\n    }\n\n    include = { model: model, association: include, as: include.as };\n  } else if (include instanceof Model) {\n    include = { model: include };\n  } else if (_.isPlainObject(include)) {\n    if (include.association) {\n      if (self && include.association.target.name === self.name) {\n        model = include.association.source;\n      } else {\n        model = include.association.target;\n      }\n\n      if (!include.model) {\n        include.model = model;\n      }\n      if (!include.as) {\n        include.as = include.association.as;\n      }\n    } else {\n      model = include.model;\n    }\n\n    conformOptions(include, model);\n  } else {\n    throw new Error('Include unexpected. Element has to be either a Model, an Association or an object.');\n  }\n\n  return include;\n}\n\nModel.$conformInclude = conformInclude;\n\nvar expandIncludeAllElement = function(includes, include) {\n  // check 'all' attribute provided is valid\n  var all = include.all;\n  delete include.all;\n\n  if (all !== true) {\n    if (!Array.isArray(all)) {\n      all = [all];\n    }\n\n    var validTypes = {\n      BelongsTo: true,\n      HasOne: true,\n      HasMany: true,\n      One: ['BelongsTo', 'HasOne'],\n      Has: ['HasOne', 'HasMany'],\n      Many: ['HasMany']\n    };\n\n    for (var i = 0; i < all.length; i++) {\n      var type = all[i];\n      if (type === 'All') {\n        all = true;\n        break;\n      }\n\n      var types = validTypes[type];\n      if (!types) {\n        throw new Error('include all \\'' + type + '\\' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All');\n      }\n\n      if (types !== true) {\n        // replace type placeholder e.g. 'One' with it's constituent types e.g. 'HasOne', 'BelongsTo'\n        all.splice(i, 1);\n        i--;\n        for (var j = 0; j < types.length; j++) {\n          if (all.indexOf(types[j]) === -1) {\n            all.unshift(types[j]);\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  // add all associations of types specified to includes\n  var nested = include.nested;\n  if (nested) {\n    delete include.nested;\n\n    if (!include.include) {\n      include.include = [];\n    } else if (!Array.isArray(include.include)) {\n      include.include = [include.include];\n    }\n  }\n\n  var used = [];\n  (function addAllIncludes(parent, includes) {\n    Utils._.forEach(parent.associations, function(association) {\n      if (all !== true && all.indexOf(association.associationType) === -1) {\n        return;\n      }\n\n      // check if model already included, and skip if so\n      var model = association.target;\n      var as = association.options.as;\n\n      var predicate = {model: model};\n      if (as) {\n        // We only add 'as' to the predicate if it actually exists\n        predicate.as = as;\n      }\n\n      if (Utils._.find(includes, predicate)) {\n        return;\n      }\n\n      // skip if recursing over a model already nested\n      if (nested && used.indexOf(model) !== -1) {\n        return;\n      }\n      used.push(parent);\n\n      // include this model\n      var thisInclude = Utils.cloneDeep(include);\n      thisInclude.model = model;\n      if (as) {\n        thisInclude.as = as;\n      }\n      includes.push(thisInclude);\n\n      // run recursively if nested\n      if (nested) {\n        addAllIncludes(model, thisInclude.include);\n        if (thisInclude.include.length === 0) delete thisInclude.include;\n      }\n    });\n    used.pop();\n  })(this, includes);\n};\n\nvar validateIncludedElement;\nvar validateIncludedElements = function(options, tableNames) {\n  if (!options.model) options.model = this;\n\n  tableNames = tableNames || {};\n  options.includeNames = [];\n  options.includeMap = {};\n\n  /* Legacy */\n  options.hasSingleAssociation = false;\n  options.hasMultiAssociation = false;\n\n  if (!options.parent) {\n    options.topModel = options.model;\n    options.topLimit = options.limit;\n  }\n\n  options.include = options.include.map(function (include) {\n    include = conformInclude(include);\n    include.parent = options;\n\n    validateIncludedElement.call(options.model, include, tableNames, options);\n\n    if (include.duplicating === undefined) {\n      include.duplicating = include.association.isMultiAssociation;\n    }\n\n    include.hasDuplicating = include.hasDuplicating || include.duplicating;\n    include.hasRequired = include.hasRequired || include.required;\n\n    options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\n    options.hasRequired = options.hasRequired || include.required;\n\n    options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;\n    return include;\n  });\n\n  options.include.forEach(function (include) {\n    include.hasParentWhere = options.hasParentWhere || !!options.where;\n    include.hasParentRequired = options.hasParentRequired || !!options.required;\n\n    if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\n      if (include.duplicating) {\n        include.subQuery = false;\n        include.subQueryFilter = include.hasRequired;\n      } else {\n        include.subQuery = include.hasRequired;\n        include.subQueryFilter = false;\n      }\n    } else {\n      include.subQuery = include.subQuery || false;\n      if (include.duplicating) {\n        include.subQueryFilter = include.subQuery;\n        include.subQuery = false;\n      } else {\n        include.subQueryFilter = false;\n        include.subQuery = include.subQuery || (include.hasParentRequired && include.hasRequired);\n      }\n    }\n\n    options.includeMap[include.as] = include;\n    options.includeNames.push(include.as);\n\n    // Set top level options\n    if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {\n      if (include.subQuery) {\n        options.subQuery = include.subQuery;\n      } else if (include.hasDuplicating) {\n        options.subQuery = true;\n      }\n    }\n\n    /* Legacy */\n    options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;\n    options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;\n\n    if (include.association.isMultiAssociation || include.hasMultiAssociation) {\n      options.hasMultiAssociation = true;\n    }\n    if (include.association.isSingleAssociation || include.hasSingleAssociation) {\n      options.hasSingleAssociation = true;\n    }\n\n    return include;\n  });\n\n  if (options.topModel === options.model && options.subQuery === undefined) {\n    options.subQuery = false;\n  }\n  return options;\n};\nModel.$validateIncludedElements = validateIncludedElements;\n\nvalidateIncludedElement = function(include, tableNames, options) {\n  tableNames[include.model.getTableName()] = true;\n\n  if (include.attributes && !options.raw) {\n    include.model.$expandAttributes(include);\n\n    // Need to make sure virtuals are mapped before setting originalAttributes\n    include = Utils.mapFinderOptions(include, include.model);\n\n    include.originalAttributes = include.attributes.slice(0);\n\n    if (include.attributes.length) {\n      _.each(include.model.primaryKeys, function (attr, key) {\n        // Include the primary key if its not already take - take into account that the pk might be aliassed (due to a .field prop)\n        if (!_.some(include.attributes, function (includeAttr) {\n            if (attr.field !== key) {\n              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;\n            }\n            return includeAttr === key;\n          })) {\n          include.attributes.unshift(key);\n        }\n      });\n    }\n  } else {\n    include = Utils.mapFinderOptions(include, include.model);\n  }\n\n  // pseudo include just needed the attribute logic, return\n  if (include._pseudo) {\n    include.attributes = Object.keys(include.model.tableAttributes);\n    return Utils.mapFinderOptions(include, include.model);\n  }\n\n  // check if the current Model is actually associated with the passed Model - or it's a pseudo include\n  var association = include.association || this.getAssociation(include.model, include.as);\n\n  if (!association) {\n    var msg = include.model.name;\n\n    if (include.as) {\n      msg += ' (' + include.as + ')';\n    }\n\n    msg += ' is not associated to ' + this.name + '!';\n\n    throw new Error(msg);\n  }\n\n  include.association = association;\n  include.as = association.as;\n\n  // If through, we create a pseudo child include, to ease our parsing later on\n  if (include.association.through && Object(include.association.through.model) === include.association.through.model) {\n    if (!include.include) include.include = [];\n    var through = include.association.through;\n\n    include.through = Utils._.defaults(include.through || {}, {\n      model: through.model,\n      as: through.model.name,\n      association: {\n        isSingleAssociation: true\n      },\n      _pseudo: true,\n      parent: include\n    });\n\n\n    if (through.scope) {\n      include.through.where = include.through.where ? { $and: [include.through.where, through.scope]} :  through.scope;\n    }\n\n    include.include.push(include.through);\n    tableNames[through.tableName] = true;\n  }\n\n  // include.model may be the main model, while the association target may be scoped - thus we need to look at association.target/source\n  var model;\n  if (include.model.scoped === true) {\n    // If the passed model is already scoped, keep that\n    model = include.model;\n  } else {\n    // Otherwise use the model that was originally passed to the association\n    model = include.association.target.name === include.model.name ? include.association.target : include.association.source;\n  }\n\n  model.$injectScope(include);\n\n  // This check should happen after injecting the scope, since the scope may contain a .attributes\n  if (!include.attributes) {\n    include.attributes = Object.keys(include.model.tableAttributes);\n  }\n\n  include = Utils.mapFinderOptions(include, include.model);\n\n  if (include.required === undefined) {\n    include.required = !!include.where;\n  }\n\n  if (include.association.scope) {\n    include.where = include.where ? { $and: [include.where, include.association.scope] }:  include.association.scope;\n  }\n\n  if (include.limit && include.separate === undefined) {\n    include.separate = true;\n  }\n\n  if (include.separate === true && !(include.association instanceof HasMany)) {\n    throw new Error('Only HasMany associations support include.separate');\n  }\n\n  if (include.separate === true) {\n    include.duplicating = false;\n  }\n\n  if (include.separate === true && options.attributes && options.attributes.length && !_.includes(options.attributes, association.source.primaryKeyAttribute)) {\n    options.attributes.push(association.source.primaryKeyAttribute);\n  }\n\n  // Validate child includes\n  if (include.hasOwnProperty('include')) {\n    validateIncludedElements.call(include.model, include, tableNames, options);\n  }\n\n  return include;\n};\n\nvar expandIncludeAll = Model.$expandIncludeAll = function(options) {\n  var includes = options.include;\n  if (!includes) {\n    return;\n  }\n\n for (var index = 0; index < includes.length; index++) {\n    var include = includes[index];\n\n    if (include.all) {\n      includes.splice(index, 1);\n      index--;\n\n      expandIncludeAllElement.call(this, includes, include);\n    }\n  }\n\n  Utils._.forEach(includes, function(include) {\n    expandIncludeAll.call(include.model, include);\n  });\n};\n\nModel.prototype.init = function(modelManager) {\n  var self = this;\n\n  this.modelManager = modelManager;\n  this.primaryKeys = {};\n\n  // Setup names of timestamp attributes\n  this._timestampAttributes = {};\n  if (this.options.timestamps) {\n    if (this.options.createdAt !== false) {\n      this._timestampAttributes.createdAt = this.options.createdAt || Utils.underscoredIf('createdAt', this.options.underscored);\n    }\n    if (this.options.updatedAt !== false) {\n      this._timestampAttributes.updatedAt = this.options.updatedAt || Utils.underscoredIf('updatedAt', this.options.underscored);\n    }\n    if (this.options.paranoid && this.options.deletedAt !== false) {\n      this._timestampAttributes.deletedAt = this.options.deletedAt || Utils.underscoredIf('deletedAt', this.options.underscored);\n    }\n  }\n\n  // Add head and tail default attributes (id, timestamps)\n  addOptionalClassMethods.call(this);\n\n  // Instance prototype\n  this.Instance = function() {\n    Instance.apply(this, arguments);\n  };\n\n  Util.inherits(this.Instance, Instance);\n\n  this._readOnlyAttributes = Utils._.values(this._timestampAttributes);\n  this._hasReadOnlyAttributes = this._readOnlyAttributes && this._readOnlyAttributes.length;\n  this._isReadOnlyAttribute = Utils._.memoize(function(key) {\n    return self._hasReadOnlyAttributes && self._readOnlyAttributes.indexOf(key) !== -1;\n  });\n\n  if (this.options.instanceMethods) {\n    Utils._.each(this.options.instanceMethods, function(fct, name) {\n      self.Instance.prototype[name] = fct;\n    });\n  }\n\n  addDefaultAttributes.call(this);\n  this.refreshAttributes();\n\n  findAutoIncrementField.call(this);\n\n  this.$scope = this.options.defaultScope;\n\n  if (_.isPlainObject(this.$scope)) {\n    conformOptions(this.$scope, this);\n  }\n\n  _.each(this.options.scopes, function (scope) {\n    if (_.isPlainObject(scope)) {\n      conformOptions(scope, this);\n    }\n  }.bind(this));\n\n  this.options.indexes = this.options.indexes.map(this.$conformIndex);\n\n  this.Instance.prototype.$Model =\n  this.Instance.prototype.Model = this;\n\n  return this;\n};\n\nModel.prototype.$conformIndex = function (index) {\n  index = _.defaults(index, {\n    type: '',\n    parser: null\n  });\n\n  if (index.type && index.type.toLowerCase() === 'unique') {\n    index.unique = true;\n    delete index.type;\n  }\n  return index;\n};\n\nModel.prototype.refreshAttributes = function() {\n  var self = this\n    , attributeManipulation = {};\n\n  this.Instance.prototype._customGetters = {};\n  this.Instance.prototype._customSetters = {};\n\n  Utils._.each(['get', 'set'], function(type) {\n    var opt = type + 'terMethods'\n      , funcs = Utils._.clone(Utils._.isObject(self.options[opt]) ? self.options[opt] : {})\n      , _custom = type === 'get' ? self.Instance.prototype._customGetters : self.Instance.prototype._customSetters;\n\n    Utils._.each(funcs, function(method, attribute) {\n      _custom[attribute] = method;\n\n      if (type === 'get') {\n        funcs[attribute] = function() {\n          return this.get(attribute);\n        };\n      }\n      if (type === 'set') {\n        funcs[attribute] = function(value) {\n          return this.set(attribute, value);\n        };\n      }\n    });\n\n    Utils._.each(self.rawAttributes, function(options, attribute) {\n      if (options.hasOwnProperty(type)) {\n        _custom[attribute] = options[type];\n      }\n\n      if (type === 'get') {\n        funcs[attribute] = function() {\n          return this.get(attribute);\n        };\n      }\n      if (type === 'set') {\n        funcs[attribute] = function(value) {\n          return this.set(attribute, value);\n        };\n      }\n    });\n\n    Utils._.each(funcs, function(fct, name) {\n      if (!attributeManipulation[name]) {\n        attributeManipulation[name] = {\n          configurable: true\n        };\n      }\n      attributeManipulation[name][type] = fct;\n    });\n  });\n\n  this._booleanAttributes = [];\n  this._dateAttributes = [];\n  this._hstoreAttributes = [];\n  this._rangeAttributes = [];\n  this._jsonAttributes = [];\n  this._geometryAttributes = [];\n  this._virtualAttributes = [];\n  this._defaultValues = {};\n  this.Instance.prototype.validators = {};\n\n  this.fieldRawAttributesMap = {};\n\n  this.primaryKeys = {};\n  self.options.uniqueKeys = {};\n\n  _.each(this.rawAttributes, function(definition, name) {\n    definition.type = self.sequelize.normalizeDataType(definition.type);\n\n    definition.Model = self;\n    definition.fieldName = name;\n    definition._modelAttribute = true;\n\n    if (definition.field === undefined) {\n      definition.field = name;\n    }\n\n    if (definition.primaryKey === true) {\n      self.primaryKeys[name] = definition;\n    }\n\n    self.fieldRawAttributesMap[definition.field] = definition;\n\n    if (definition.type instanceof DataTypes.BOOLEAN) {\n      self._booleanAttributes.push(name);\n    } else if (definition.type instanceof DataTypes.DATE) {\n      self._dateAttributes.push(name);\n    } else if (definition.type instanceof DataTypes.HSTORE || DataTypes.ARRAY.is(definition.type, DataTypes.HSTORE)) {\n      self._hstoreAttributes.push(name);\n    } else if (definition.type instanceof DataTypes.RANGE || DataTypes.ARRAY.is(definition.type, DataTypes.RANGE)) {\n      self._rangeAttributes.push(name);\n    } else if (definition.type instanceof DataTypes.JSON) {\n      self._jsonAttributes.push(name);\n    } else if (definition.type instanceof DataTypes.VIRTUAL) {\n      self._virtualAttributes.push(name);\n    } else if (definition.type instanceof DataTypes.GEOMETRY) {\n      self._geometryAttributes.push(name);\n    }\n\n    if (definition.hasOwnProperty('defaultValue')) {\n      self._defaultValues[name] = Utils._.partial(Utils.toDefaultValue, definition.defaultValue);\n    }\n\n    if (definition.hasOwnProperty('unique') && definition.unique !== false) {\n      var idxName;\n      if (typeof definition.unique === 'object' && definition.unique.hasOwnProperty('name')) {\n        idxName = definition.unique.name;\n      } else if (typeof definition.unique === 'string') {\n        idxName = definition.unique;\n      } else {\n        idxName = self.tableName + '_' + name + '_unique';\n      }\n\n      var idx = self.options.uniqueKeys[idxName] || { fields: [] };\n      idx = idx || {fields: [], msg: null};\n      idx.fields.push(definition.field);\n      idx.msg = idx.msg || definition.unique.msg || null;\n      idx.name = idxName || false;\n      idx.column = name;\n\n      self.options.uniqueKeys[idxName] = idx;\n    }\n\n    if (definition.hasOwnProperty('validate')) {\n      self.Instance.prototype.validators[name] = definition.validate;\n    }\n\n    if (definition.index === true && definition.type instanceof DataTypes.JSONB) {\n      self.options.indexes.push({\n        fields: [definition.field || name],\n        using: 'gin'\n      });\n\n      delete definition.index;\n    }\n  });\n  // Create a map of field to attribute names\n  this.fieldAttributeMap = Utils._.reduce(this.fieldRawAttributesMap, function(map, value, key) {\n    if (key !== value.fieldName) {\n      map[key] = value.fieldName;\n    }\n    return map;\n  }, {});\n\n  this.uniqueKeys = this.options.uniqueKeys;\n\n  this._hasBooleanAttributes = !!this._booleanAttributes.length;\n  this._isBooleanAttribute = Utils._.memoize(function(key) {\n    return self._booleanAttributes.indexOf(key) !== -1;\n  });\n\n  this._hasDateAttributes = !!this._dateAttributes.length;\n  this._isDateAttribute = Utils._.memoize(function(key) {\n    return self._dateAttributes.indexOf(key) !== -1;\n  });\n\n  this._hasHstoreAttributes = !!this._hstoreAttributes.length;\n  this._isHstoreAttribute = Utils._.memoize(function(key) {\n    return self._hstoreAttributes.indexOf(key) !== -1;\n  });\n\n  this._hasRangeAttributes = !!this._rangeAttributes.length;\n  this._isRangeAttribute = Utils._.memoize(function(key) {\n    return self._rangeAttributes.indexOf(key) !== -1;\n  });\n\n  this._hasJsonAttributes = !!this._jsonAttributes.length;\n  this._isJsonAttribute = Utils._.memoize(function(key) {\n    return self._jsonAttributes.indexOf(key) !== -1;\n  });\n\n  this._hasVirtualAttributes = !!this._virtualAttributes.length;\n  this._isVirtualAttribute = Utils._.memoize(function(key) {\n    return self._virtualAttributes.indexOf(key) !== -1;\n  });\n\n  this._hasGeometryAttributes = !!this._geometryAttributes.length;\n  this._isGeometryAttribute = Utils._.memoize(function(key) {\n    return self._geometryAttributes.indexOf(key) !== -1;\n  });\n\n  this._hasDefaultValues = !Utils._.isEmpty(this._defaultValues);\n\n  this.attributes = this.rawAttributes;\n  this.tableAttributes = Utils._.omit(this.rawAttributes, this._virtualAttributes);\n\n  this.Instance.prototype._hasCustomGetters = Object.keys(this.Instance.prototype._customGetters).length;\n  this.Instance.prototype._hasCustomSetters = Object.keys(this.Instance.prototype._customSetters).length;\n\n  Object.keys(attributeManipulation).forEach((function(key){\n    if (Instance.prototype.hasOwnProperty(key)) {\n      this.sequelize.log(\"Not overriding built-in method from model attribute: \" + key);\n      return;\n    }\n    Object.defineProperty(this.Instance.prototype, key, attributeManipulation[key]);\n  }).bind(this));\n\n\n  this.Instance.prototype.rawAttributes = this.rawAttributes;\n  this.Instance.prototype.attributes = Object.keys(this.Instance.prototype.rawAttributes);\n  this.Instance.prototype._isAttribute = Utils._.memoize(function(key) {\n    return self.Instance.prototype.attributes.indexOf(key) !== -1;\n  });\n\n  // Primary key convenience variables\n  this.primaryKeyAttributes = Object.keys(this.primaryKeys);\n  this.primaryKeyAttribute = this.primaryKeyAttributes[0];\n  if (this.primaryKeyAttribute) {\n    this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;\n  }\n\n  this.primaryKeyCount = this.primaryKeyAttributes.length;\n  this._hasPrimaryKeys = this.options.hasPrimaryKeys = this.hasPrimaryKeys = this.primaryKeyCount > 0;\n\n  this._isPrimaryKey = Utils._.memoize(function(key) {\n    return self.primaryKeyAttributes.indexOf(key) !== -1;\n  });\n\n};\n\n/**\n * Remove attribute from model definition\n * @param {String} [attribute]\n */\nModel.prototype.removeAttribute = function(attribute) {\n  delete this.rawAttributes[attribute];\n  this.refreshAttributes();\n};\n\n/**\n * Sync this Model to the DB, that is create the table. Upon success, the callback will be called with the model instance (this)\n * @see {Sequelize#sync} for options\n * @return {Promise<this>}\n */\nModel.prototype.sync = function(options) {\n  options = _.extend({}, this.options, options);\n  options.hooks = options.hooks === undefined ? true : !!options.hooks;\n\n  var self = this\n    , attributes = this.tableAttributes;\n\n  return Promise.try(function () {\n    if (options.hooks) {\n      return self.runHooks('beforeSync', options);\n    }\n  }).then(function () {\n    if (options.force) {\n      return self.drop(options);\n    }\n  }).then(function () {\n    return self.QueryInterface.createTable(self.getTableName(options), attributes, options, self);\n  }).then(function () {\n    return self.QueryInterface.showIndex(self.getTableName(options), options);\n  }).then(function (indexes) {\n    // Assign an auto-generated name to indexes which are not named by the user\n    self.options.indexes = self.QueryInterface.nameIndexes(self.options.indexes, self.tableName);\n\n    indexes = _.filter(self.options.indexes, function (item1) {\n      return !_.some(indexes, function (item2) {\n        return item1.name === item2.name;\n      });\n    });\n\n    return Promise.map(indexes, function (index) {\n      return self.QueryInterface.addIndex(\n                self.getTableName(options),\n                _.assign({logging: options.logging,\n                          benchmark: options.benchmark,\n                          transaction: options.transaction}, index),\n                self.tableName);\n    });\n  }).then(function () {\n    if (options.hooks) {\n      return self.runHooks('afterSync', options);\n    }\n  }).return(this);\n};\n\n/**\n * Drop the table represented by this Model\n * @param {Object}   [options]\n * @param {Boolean}  [options.cascade=false]   Also drop all objects depending on this table, such as views. Only works in postgres\n * @param {Function} [options.logging=false]   A function that gets executed while running the query to log the sql.\n * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @return {Promise}\n */\nModel.prototype.drop = function(options) {\n  return this.QueryInterface.dropTable(this.getTableName(options), options);\n};\n\nModel.prototype.dropSchema = function(schema) {\n  return this.QueryInterface.dropSchema(schema);\n};\n\n/**\n * Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - `\"schema\".\"tableName\"`,\n * while the schema will be prepended to the table name for mysql and sqlite - `'schema.tablename'`.\n *\n * @param {String} schema The name of the schema\n * @param {Object} [options]\n * @param {String} [options.schemaDelimiter='.'] The character(s) that separates the schema name from the table name\n * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @return {this}\n */\nModel.prototype.schema = function(schema, options) { // testhint options:none\n  var self = this;\n  var clone = Object.create(self);\n\n  clone.$schema = schema;\n\n  if (!!options) {\n    if (typeof options === 'string') {\n      clone.$schemaDelimiter = options;\n    } else {\n      if (!!options.schemaDelimiter) {\n        clone.$schemaDelimiter = options.schemaDelimiter;\n      }\n    }\n  }\n\n  clone.Instance = function() {\n    self.Instance.apply(this, arguments);\n  };\n  clone.Instance.prototype = Object.create(self.Instance.prototype);\n  clone.Instance.prototype.$Model = clone;\n\n  return clone;\n};\n\n/**\n * Get the tablename of the model, taking schema into account. The method will return The name as a string if the model has no schema,\n * or an object with `tableName`, `schema` and `delimiter` properties.\n *\n * @param {Object}   [options] The hash of options from any query. You can use one model to access tables with matching schemas by overriding `getTableName` and using custom key/values to alter the name of the table. (eg. subscribers_1, subscribers_2)\n * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @return {String|Object}\n */\nModel.prototype.getTableName = function(options) { // testhint options:none\n  return this.QueryGenerator.addSchema(this);\n};\n\n/**\n * @return {Model}\n */\nModel.prototype.unscoped = function () {\n  return this.scope();\n};\n\n/**\n * Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined.\n *\n * By default this will throw an error if a scope with that name already exists. Pass `override: true` in the options object to silence this error.\n *\n * @param {String}          name The name of the scope. Use `defaultScope` to override the default scope\n * @param {Object|Function} scope\n * @param {Object}          [options]\n * @param {Boolean}         [options.override=false]\n */\nModel.prototype.addScope = function (name, scope, options) {\n  options = _.assign({\n    override: false\n  }, options);\n\n  if ((name === 'defaultScope' || name in this.options.scopes) && options.override === false) {\n    throw new Error('The scope ' + name + ' already exists. Pass { override: true } as options to silence this error');\n  }\n\n  conformOptions(scope, this);\n\n  if (name === 'defaultScope') {\n    this.options.defaultScope = this.$scope = scope;\n  } else {\n    this.options.scopes[name] = scope;\n  }\n};\n\n/**\n * Apply a scope created in `define` to the model. First let's look at how to create scopes:\n * ```js\n * var Model = sequelize.define('model', attributes, {\n *   defaultScope: {\n *     where: {\n *       username: 'dan'\n *     },\n *     limit: 12\n *   },\n *   scopes: {\n *     isALie: {\n *       where: {\n *         stuff: 'cake'\n *       }\n *     },\n *     complexFunction: function(email, accessLevel) {\n *       return {\n *         where: {\n *           email: {\n *             $like: email\n *           },\n *           accesss_level {\n *             $gte: accessLevel\n *           }\n *         }\n *       }\n *     }\n *   }\n * })\n * ```\n * Now, since you defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples:\n * ```js\n * Model.findAll() // WHERE username = 'dan'\n * Model.findAll({ where: { age: { gt: 12 } } }) // WHERE age > 12 AND username = 'dan'\n * ```\n *\n * To invoke scope functions you can do:\n * ```js\n * Model.scope({ method: ['complexFunction' 'dan@sequelize.com', 42]}).findAll()\n * // WHERE email like 'dan@sequelize.com%' AND access_level >= 42\n * ```\n *\n * @param {Array|Object|String|null}    options* The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a `method` property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.\n * @return {Model}                      A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope.\n */\nModel.prototype.scope = function(option) {\n  var self = Object.create(this)\n    , options\n    , scope\n    , scopeName;\n\n  self.$scope = {};\n  self.scoped = true;\n\n  if (!option) {\n    return self;\n  }\n\n  options = _.flatten(arguments);\n  options.forEach(function(option) {\n    scope = null;\n    scopeName = null;\n\n    if (_.isPlainObject(option)) {\n      if (!!option.method) {\n        if (Array.isArray(option.method) && !!self.options.scopes[option.method[0]]) {\n          scopeName = option.method[0];\n          scope = self.options.scopes[scopeName].apply(self, option.method.splice(1));\n        }\n        else if (!!self.options.scopes[option.method]) {\n          scopeName = option.method;\n          scope = self.options.scopes[scopeName].apply(self);\n        }\n      } else {\n        scope = option;\n      }\n    } else {\n      if (option === 'defaultScope' && _.isPlainObject(self.options.defaultScope)) {\n        scope = self.options.defaultScope;\n      } else {\n        scopeName = option;\n        scope = self.options.scopes[scopeName];\n\n        if (_.isFunction(scope)) {\n          scope = scope();\n          conformOptions(scope, self);\n        }\n      }\n    }\n\n    if (!!scope) {\n      _.assignWith(self.$scope, scope, function scopeCustomizer(objectValue, sourceValue, key) {\n        if (key === 'where') {\n          return Array.isArray(sourceValue) ? sourceValue : _.assign(objectValue || {}, sourceValue);\n        } else if ( (['attributes','include'].indexOf(key) >= 0) && Array.isArray(objectValue) && Array.isArray(sourceValue)) {\n          return objectValue.concat(sourceValue);\n        }\n\n        return objectValue ? objectValue : sourceValue;\n      });\n    } else {\n      throw new Error('Invalid scope ' + scopeName + ' called.');\n    }\n  });\n\n  return self;\n};\n\nModel.prototype.all = function(options) {\n  return this.findAll(options);\n};\n\n/**\n * Search for multiple instances.\n *\n * __Simple search using AND and =__\n * ```js\n * Model.findAll({\n *   where: {\n *     attr1: 42,\n *     attr2: 'cake'\n *   }\n * })\n * ```\n * ```sql\n * WHERE attr1 = 42 AND attr2 = 'cake'\n *```\n *\n * __Using greater than, less than etc.__\n * ```js\n *\n * Model.findAll({\n *   where: {\n *     attr1: {\n *       gt: 50\n *     },\n *     attr2: {\n *       lte: 45\n *     },\n *     attr3: {\n *       in: [1,2,3]\n *     },\n *     attr4: {\n *       ne: 5\n *     }\n *   }\n * })\n * ```\n * ```sql\n * WHERE attr1 > 50 AND attr2 <= 45 AND attr3 IN (1,2,3) AND attr4 != 5\n * ```\n * Possible options are: `$ne, $in, $not, $notIn, $gte, $gt, $lte, $lt, $like, $ilike/$iLike, $notLike, $notILike, '..'/$between, '!..'/$notBetween, '&&'/$overlap, '@>'/$contains, '<@'/$contained`\n *\n * __Queries using OR__\n * ```js\n * Model.findAll({\n *   where: {\n *     name: 'a project',\n *     $or: [\n *       {id: [1, 2, 3]},\n *       {\n *         $and: [\n *           {id: {gt: 10}},\n *           {id: {lt: 100}}\n *         ]\n *       }\n *     ]\n *   }\n * });\n * ```\n * ```sql\n * WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` < 100));\n * ```\n *\n * The success listener is called with an array of instances if the query succeeds.\n *\n * @param  {Object}                    [options] A hash of options to describe the scope of the search\n * @param  {Object}                    [options.where] A hash of attributes to describe your search. See above for examples.\n * @param  {Array<String>|Object}      [options.attributes] A list of the attributes that you want to select, or an object with `include` and `exclude` keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance\n * @param  {Array<String>}             [options.attributes.include] Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. `{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }`\n * @param  {Array<String>}             [options.attributes.exclude] Select all the attributes of the model, except some few. Useful for security purposes e.g. `{ attributes: { exclude: ['password'] } }`\n * @param  {Boolean}                   [options.paranoid=true] If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if `options.paranoid` is true for the model.\n * @param  {Array<Object|Model>}       [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).\n * @param  {Model}                     [options.include[].model] The model you want to eagerly load\n * @param  {String}                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliased. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural\n * @param  {Association}               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)\n * @param  {Object}                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`\n * @param  {Boolean}                   [options.include[].or=false] Whether to bind the ON and WHERE clause together by OR instead of AND.\n * @param  {Object}                    [options.include[].on] Supply your own ON condition for the join.\n * @param  {Array<String>}             [options.include[].attributes] A list of attributes to select from the child model\n * @param  {Boolean}                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.\n * @param  {Boolean}                   [options.include[].separate] If true, runs a separate query to fetch the associated instances, only supported for hasMany associations\n * @param  {Number}                    [options.include[].limit] Limit the joined rows, only supported with include.separate=true\n * @param  {Object}                    [options.include[].through.where] Filter on the join model for belongsToMany relations\n * @param  {Array}                     [options.include[].through.attributes] A list of attributes to select from the join model for belongsToMany relations\n * @param  {Array<Object|Model>}       [options.include[].include] Load further nested related models\n * @param  {String|Array|Sequelize.fn} [options.order] Specifies an ordering. If a string is provided, it will be escaped. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.\n * @param  {Number}                    [options.limit]\n * @param  {Number}                    [options.offset]\n * @param  {Transaction}               [options.transaction] Transaction to run query under\n * @param  {String|Object}             [options.lock] Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See [transaction.LOCK for an example](transaction#lock)\n * @param  {Boolean}                   [options.raw] Return raw result. See sequelize.query for more information.\n * @param  {Function}                  [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param  {Boolean}                   [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param  {Object}                    [options.having]\n * @param  {String}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n * @param  {Boolean|Error Instance}    [options.rejectOnEmpty=false] Throws an error when no records found\n *\n * @see    {Sequelize#query}\n * @return {Promise<Array<Instance>>}\n * @alias all\n */\n\nModel.prototype.findAll = function(options) {\n  if (options !== undefined && !_.isPlainObject(options)) {\n    throw new Error('The argument passed to findAll must be an options object, use findById if you wish to pass a single primary key value');\n  }\n  // TODO: Remove this in the next major version (4.0)\n  if (arguments.length > 1) {\n    throw new Error('Please note that find* was refactored and uses only one options object from now on.');\n  }\n  var tableNames = {}\n    , originalOptions;\n\n  tableNames[this.getTableName(options)] = true;\n  options = Utils.cloneDeep(options);\n\n  _.defaults(options, { hooks: true, rejectOnEmpty: this.options.rejectOnEmpty });\n\n    //set rejectOnEmpty option from model config\n    options.rejectOnEmpty = options.rejectOnEmpty || this.options.rejectOnEmpty;\n\n  return Promise.bind(this).then(function() {\n    conformOptions(options, this);\n    this.$injectScope(options);\n\n    if (options.hooks) {\n      return this.runHooks('beforeFind', options);\n    }\n  }).then(function() {\n    expandIncludeAll.call(this, options);\n\n    if (options.hooks) {\n      return this.runHooks('beforeFindAfterExpandIncludeAll', options);\n    }\n  }).then(function() {\n    if (options.include) {\n      options.hasJoin = true;\n\n      validateIncludedElements.call(this, options, tableNames);\n\n      // If we're not raw, we have to make sure we include the primary key for deduplication\n      if (options.attributes && !options.raw && this.primaryKeyAttribute &&  options.attributes.indexOf(this.primaryKeyAttribute) === -1) {\n        options.originalAttributes = options.attributes;\n        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);\n      }\n    }\n\n    if (!options.attributes) {\n      options.attributes = Object.keys(this.tableAttributes);\n    }\n\n    // whereCollection is used for non-primary key updates\n    this.options.whereCollection = options.where || null;\n\n    Utils.mapFinderOptions(options, this);\n\n    options = paranoidClause(this, options);\n\n    if (options.hooks) {\n      return this.runHooks('beforeFindAfterOptions', options);\n    }\n  }).then(function() {\n    originalOptions = Utils.cloneDeep(options);\n    options.tableNames = Object.keys(tableNames);\n    return this.QueryInterface.select(this, this.getTableName(options), options);\n  }).tap(function(results) {\n    if (options.hooks) {\n      return this.runHooks('afterFind', results, options);\n    }\n  }).then(function (results) {\n\n    //rejectOnEmpty mode\n    if (_.isEmpty(results) && options.rejectOnEmpty) {\n      if (typeof options.rejectOnEmpty === 'function') {\n        throw new options.rejectOnEmpty();\n      } else if (typeof options.rejectOnEmpty === 'object') {\n        throw options.rejectOnEmpty;\n      } else {\n        throw new sequelizeErrors.EmptyResultError();\n      }\n    }\n\n    return Model.$findSeparate(results, originalOptions);\n  });\n};\n\nModel.$findSeparate = function(results, options) {\n  if (!options.include || options.raw || !results) return Promise.resolve(results);\n\n  var original = results;\n  if (options.plain) results = [results];\n\n  if (!results.length) return original;\n\n  return Promise.map(options.include, function (include) {\n    if (!include.separate) {\n      return Model.$findSeparate(\n        results.reduce(function (memo, result) {\n          var associations = result.get(include.association.as);\n\n          // Might be an empty belongsTo relation\n          if (!associations) return memo;\n\n          // Force array so we can concat no matter if it's 1:1 or :M\n          if (!Array.isArray(associations)) associations = [associations];\n\n          return memo.concat(associations);\n        }, []),\n        _.assign(\n          {},\n          _.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'plain', 'scope'),\n          {include: include.include || []}\n        )\n      );\n    }\n\n    return include.association.get(results, _.assign(\n      {},\n      _.omit(options, 'include', 'attributes', 'order', 'where', 'limit', 'plain'),\n      _.omit(include, 'parent', 'association', 'as')\n    )).then(function (map) {\n      results.forEach(function (result) {\n        result.set(\n          include.association.as,\n          map[result.get(include.association.source.primaryKeyAttribute)],\n          {\n            raw: true\n          }\n        );\n      });\n    });\n  }).return(original);\n};\n\n/**\n* Search for a single instance by its primary key.\n*\n* @param  {Number|String|Buffer}      id The value of the desired instance's primary key.\n* @param  {Object}                    [options]\n* @param  {Transaction}               [options.transaction] Transaction to run query under\n* @param  {String}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n*\n* @see {Model#findAll}           for a full explanation of options\n* @return {Promise<Instance>}\n* @alias findByPrimary\n*/\nModel.prototype.findById = function(param, options) {\n  // return Promise resolved with null if no arguments are passed\n  if ([null, undefined].indexOf(param) !== -1) {\n    return Promise.resolve(null);\n  }\n\n  options = Utils.cloneDeep(options) || {};\n\n  if (typeof param === 'number' || typeof param === 'string' || Buffer.isBuffer(param)) {\n    options.where = {};\n    options.where[this.primaryKeyAttribute] = param;\n  } else {\n    throw new Error('Argument passed to findById is invalid: '+param);\n  }\n\n  // Bypass a possible overloaded findOne\n  return Model.prototype.findOne.call(this, options);\n};\nModel.prototype.findByPrimary = Model.prototype.findById;\n\n/**\n* Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance.\n*\n* @param  {Object}                    [options] A hash of options to describe the scope of the search\n* @param  {Transaction}               [options.transaction] Transaction to run query under\n* @param  {String}                    [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n*\n* @see {Model#findAll}           for an explanation of options\n* @return {Promise<Instance>}\n* @alias find\n*/\nModel.prototype.findOne = function(options) {\n  if (options !== undefined && !_.isPlainObject(options)) {\n    throw new Error('The argument passed to findOne must be an options object, use findById if you wish to pass a single primary key value');\n  }\n  options = Utils.cloneDeep(options);\n\n  if (options.limit === undefined) {\n    var pkVal = options.where && options.where[this.primaryKeyAttribute];\n\n    // Don't add limit if querying directly on the pk\n    if (!options.where || !(Utils.isPrimitive(pkVal) || Buffer.isBuffer(pkVal))) {\n      options.limit = 1;\n    }\n  }\n\n  // Bypass a possible overloaded findAll.\n  return Model.prototype.findAll.call(this, _.defaults(options, {\n    plain: true,\n    rejectOnEmpty: false\n  }));\n};\nModel.prototype.find = Model.prototype.findOne;\n\n/**\n * Run an aggregation method on the specified field\n *\n * @param {String}          field The field to aggregate over. Can be a field name or *\n * @param {String}          aggregateFunction The function to use for aggregation, e.g. sum, max etc.\n * @param {Object}          [options] Query options. See sequelize.query for full options\n * @param {Object}          [options.where] A hash of search attributes.\n * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Boolean}         [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param {DataType|String} [options.dataType] The type of the result. If `field` is a field in this Model, the default will be the type of that field, otherwise defaults to float.\n * @param {boolean}         [options.distinct] Applies DISTINCT to the field being aggregated over\n * @param {Transaction}     [options.transaction] Transaction to run query under\n * @param {Boolean}         [options.plain] When `true`, the first returned value of `aggregateFunction` is cast to `dataType` and returned. If additional attributes are specified, along with `group` clauses, set `plain` to `false` to return all values of all returned rows.  Defaults to `true`\n *\n * @return {Promise<options.dataType|object>}                Returns the aggregate result cast to `options.dataType`, unless `options.plain` is false, in which case the complete data result is returned.\n */\nModel.prototype.aggregate = function(attribute, aggregateFunction, options) {\n  options = Utils.cloneDeep(options);\n  options = _.defaults(options, { attributes: [] });\n  conformOptions(options, this);\n  this.$injectScope(options);\n\n  if (options.include) {\n    expandIncludeAll.call(this, options);\n    validateIncludedElements.call(this, options);\n  }\n\n  var attrOptions = this.rawAttributes[attribute]\n    , field = attrOptions && attrOptions.field || attribute\n    , aggregateColumn = this.sequelize.col(field);\n\n  if (options.distinct) {\n    aggregateColumn = this.sequelize.fn('DISTINCT', aggregateColumn);\n  }\n  options.attributes.push([this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]);\n\n  if (!options.dataType) {\n    if (attrOptions) {\n      options.dataType = attrOptions.type;\n    } else {\n      // Use FLOAT as fallback\n      options.dataType = new DataTypes.FLOAT();\n    }\n  } else {\n    options.dataType = this.sequelize.normalizeDataType(options.dataType);\n  }\n\n  Utils.mapOptionFieldNames(options, this);\n  options = paranoidClause(this, options);\n\n  return this.QueryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);\n};\n\n/**\n * Count the number of records matching the provided where clause.\n *\n * If you provide an `include` option, the number of matching associations will be counted instead.\n *\n * @param {Object}        [options]\n * @param {Object}        [options.where] A hash of search attributes.\n * @param {Object}        [options.include] Include options. See `find` for details\n * @param {boolean}       [options.distinct] Apply COUNT(DISTINCT(col)) on primary key, `Model.aggregate` should be used for other columns\n * @param {Object}        [options.attributes] Used in conjunction with `group`\n * @param {Object}        [options.group] For creating complex counts. Will return multiple rows as needed.\n * @param {Transaction}   [options.transaction] Transaction to run query under\n * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param {String}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise<Integer>}\n */\nModel.prototype.count = function(options) {\n  return Promise.bind(this).then(function() {\n    options = _.defaults(Utils.cloneDeep(options), { hooks: true });\n    if (options.hooks) {\n      return this.runHooks('beforeCount', options);\n    }\n  }).then(function() {\n    var col = options.include ? this.name + '.' + this.primaryKeyField : '*';\n\n    options.plain = !options.group;\n    options.dataType = new DataTypes.INTEGER();\n    options.includeIgnoreAttributes = false;\n\n    // No limit, offset, order or attributes for the options max be given to count()\n    // Set them to null to prevent scopes setting those values\n    options.limit = null;\n    options.offset = null;\n    options.order = null;\n\n    return this.aggregate(col, 'count', options);\n  });\n};\n\n/**\n * Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging\n *\n * ```js\n * Model.findAndCountAll({\n *   where: ...,\n *   limit: 12,\n *   offset: 12\n * }).then(function (result) {\n *   ...\n * })\n * ```\n * In the above example, `result.rows` will contain rows 13 through 24, while `result.count` will return the total number of rows that matched your query.\n *\n * When you add includes, only those which are required (either because they have a where clause, or because `required` is explicitly set to true on the include) will be added to the count part.\n *\n * Suppose you want to find all users who have a profile attached:\n * ```js\n * User.findAndCountAll({\n *   include: [\n *      { model: Profile, required: true}\n *   ],\n *   distinct: true,\n *   limit 3\n * });\n * ```\n * Because the include for `Profile` has `required` set it will result in an inner join, and only the users who have a profile will be counted. If we remove `required` from the include, both users with and without profiles will be counted\n *\n * @param {Object} [findOptions] See findAll\n *\n * @see {Model#findAll} for a specification of find and query options\n * @return {Promise<Object>}\n * @alias findAndCountAll\n */\nModel.prototype.findAndCount = function(options) {\n  if (options !== undefined && !_.isPlainObject(options)) {\n    throw new Error('The argument passed to findAndCount must be an options object, use findById if you wish to pass a single primary key value');\n  }\n\n  var self = this;\n  var countOptions = Utils.cloneDeep(options);\n  if (countOptions.attributes) {\n    countOptions.attributes = undefined;\n  }\n  return self.count(countOptions).then(function(count) {\n    if (count === 0) {\n      return {\n        count: count || 0,\n        rows: []\n      };\n    }\n    return self.findAll(options).then(function(results) {\n      return {\n        count: count || 0,\n        rows: results\n      };\n    });\n  });\n};\nModel.prototype.findAndCountAll = Model.prototype.findAndCount;\n\n\n/**\n * Find the maximum value of field\n *\n * @param {String} field\n * @param {Object} [options] See aggregate\n * @see {Model#aggregate} for options\n *\n * @return {Promise<Any>}\n */\nModel.prototype.max = function(field, options) {\n  return this.aggregate(field, 'max', options);\n};\n\n/**\n * Find the minimum value of field\n *\n * @param {String} field\n * @param {Object} [options] See aggregate\n * @see {Model#aggregate} for options\n *\n * @return {Promise<Any>}\n */\nModel.prototype.min = function(field, options) {\n  return this.aggregate(field, 'min', options);\n};\n\n/**\n * Find the sum of field\n *\n * @param {String} field\n * @param {Object} [options] See aggregate\n * @see {Model#aggregate} for options\n *\n * @return {Promise<Number>}\n */\nModel.prototype.sum = function(field, options) {\n  return this.aggregate(field, 'sum', options);\n};\n\n/**\n * Builds a new model instance. Values is an object of key value pairs, must be defined but can be empty.\n\n * @param {Object}  values\n * @param {Object}  [options]\n * @param {Boolean} [options.raw=false] If set to true, values will ignore field and virtual setters.\n * @param {Boolean} [options.isNewRecord=true]\n * @param {Array}   [options.include] an array of include options - Used to build prefetched/included model instances. See `set`\n *\n * @return {Instance}\n */\nModel.prototype.build = function(values, options) { // testhint options:none\n  if (Array.isArray(values)) {\n    return this.bulkBuild(values, options);\n  }\n  options = _.extend({\n    isNewRecord: true,\n    $schema: this.$schema,\n    $schemaDelimiter: this.$schemaDelimiter\n  }, options || {});\n\n  if (options.attributes) {\n    options.attributes = options.attributes.map(function(attribute) {\n      return Array.isArray(attribute) ? attribute[1] : attribute;\n    });\n  }\n\n  if (!options.includeValidated) {\n    conformOptions(options, this);\n    if (options.include) {\n      expandIncludeAll.call(this, options);\n      validateIncludedElements.call(this, options);\n    }\n  }\n\n  return new this.Instance(values, options);\n};\n\n\nModel.prototype.bulkBuild = function(valueSets, options) { // testhint options:none\n  options = _.extend({\n    isNewRecord: true\n  }, options || {});\n\n  if (!options.includeValidated) {\n    conformOptions(options, this);\n    if (options.include) {\n      expandIncludeAll.call(this, options);\n      validateIncludedElements.call(this, options);\n    }\n  }\n\n  if (options.attributes) {\n    options.attributes = options.attributes.map(function(attribute) {\n      return Array.isArray(attribute) ? attribute[1] : attribute;\n    });\n  }\n\n  return valueSets.map(function(values) {\n    return this.build(values, options);\n  }.bind(this));\n};\n\n/**\n * Builds a new model instance and calls save on it.\n\n * @see {Instance#build}\n * @see {Instance#save}\n *\n * @param {Object}        values\n * @param {Object}        [options]\n * @param {Boolean}       [options.raw=false] If set to true, values will ignore field and virtual setters.\n * @param {Boolean}       [options.isNewRecord=true]\n * @param {Array}         [options.fields] If set, only columns matching those in fields will be saved\n * @param {Array}         [options.include] an array of include options - Used to build prefetched/included model instances\n * @param {String}        [options.onDuplicate]\n * @param {Transaction}   [options.transaction] Transaction to run query under\n * @param {Function}      [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Boolean}       [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param {String}        [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise<Instance>}\n */\nModel.prototype.create = function(values, options) {\n  options = Utils.cloneDeep(options || {});\n\n  return this.build(values, {\n    isNewRecord: true,\n    attributes: options.fields,\n    include: options.include,\n    raw: options.raw,\n    silent: options.silent\n  }).save(options);\n};\n\n/**\n * Find a row that matches the query, or build (but don't save) the row if none is found.\n * The successful result of the promise will be (instance, initialized) - Make sure to use .spread()\n *\n * @param {Object}   options\n * @param {Object}   options.where A hash of search attributes.\n * @param {Object}   [options.defaults] Default values to use if building a new instance\n * @param {Object}   [options.transaction] Transaction to run query under\n * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n *\n * @return {Promise<Instance,initialized>}\n * @alias findOrBuild\n */\nModel.prototype.findOrInitialize = Model.prototype.findOrBuild = function(options) {\n  if (!options || !options.where || arguments.length > 1) {\n    throw new Error(\n      'Missing where attribute in the options parameter passed to findOrInitialize. ' +\n      'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'\n    );\n  }\n\n  var self = this\n    , values;\n\n  return self.find(options).then(function(instance) {\n    if (instance === null) {\n      values = Utils._.clone(options.defaults) || {};\n      if (Utils._.isPlainObject(options.where)) {\n        values = Utils._.defaults(values, options.where);\n      }\n\n      instance = self.build(values);\n\n      return Promise.resolve([instance, true]);\n    }\n\n    return Promise.resolve([instance, false]);\n  });\n};\n\n/**\n * Find a row that matches the query, or build and save the row if none is found\n * The successful result of the promise will be (instance, created) - Make sure to use .spread()\n *\n * If no transaction is passed in the `options` object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call.\n * However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize.TimeoutError will be thrown instead.\n * If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.\n *\n * @param {Object}      options\n * @param {Object}      options.where where A hash of search attributes.\n * @param {Object}      [options.defaults] Default values to use if creating a new instance\n * @param {Transaction} [options.transaction] Transaction to run query under\n * @see {Model#findAll} for a full specification of find and options\n * @return {Promise<Instance,created>}\n */\nModel.prototype.findOrCreate = function(options) {\n  if (!options || !options.where || arguments.length > 1) {\n    throw new Error(\n      'Missing where attribute in the options parameter passed to findOrCreate. '+\n      'Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)'\n    );\n  }\n\n  options = _.assign({}, options);\n\n  if (options.transaction === undefined && this.sequelize.constructor.cls) {\n    var t = this.sequelize.constructor.cls.get('transaction');\n    if (t) {\n      options.transaction = t;\n    }\n  }\n\n  var self = this\n    , internalTransaction = !options.transaction\n    , values\n    , whereFields = Object.keys(options.where)\n    , defaultFields\n    , transaction;\n\n  if (options.defaults) defaultFields = Object.keys(options.defaults);\n\n  // Create a transaction or a savepoint, depending on whether a transaction was passed in\n  return self.sequelize.transaction(options).bind({}).then(function (t) {\n    transaction = t;\n    options.transaction = t;\n\n    return self.findOne(_.defaults({\n      transaction: transaction\n    }, options));\n  }).then(function(instance) {\n    if (instance !== null) {\n      return [instance, false];\n    }\n\n    values = Utils._.clone(options.defaults) || {};\n    if (Utils._.isPlainObject(options.where)) {\n      values = _.defaults(values, options.where);\n    }\n\n    options.exception = true;\n\n    return self.create(values, options).bind(this).then(function(instance) {\n      if (instance.get(self.primaryKeyAttribute, { raw: true }) === null) {\n        // If the query returned an empty result for the primary key, we know that this was actually a unique constraint violation\n        throw new self.sequelize.UniqueConstraintError();\n      }\n\n      return [instance, true];\n    }).catch(self.sequelize.UniqueConstraintError, function (err) {\n      if (defaultFields) {\n        if (!_.intersection(err.fields, whereFields).length && _.intersection(err.fields, defaultFields).length) {\n          throw err;\n        }\n      }\n\n      // Someone must have created a matching instance inside the same transaction since we last did a find. Let's find it!\n      return self.findOne(_.defaults({\n        transaction: internalTransaction ? null : transaction\n      }, options)).then(function(instance) {\n        // Sanity check, ideally we caught this at the defaultFeilds/err.fields check\n        // But if we didn't and instance is null, we will throw\n        if (instance === null) throw err;\n        return [instance, false];\n      });\n    });\n  }).finally(function () {\n    if (internalTransaction && transaction) {\n      // If we created a transaction internally (and not just a savepoint), we should clean it up\n      return transaction.commit();\n    }\n  });\n};\n\n/**\n * A more performant findOrCreate that will not work under a transaction (at least not in postgres)\n * Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again\n *\n * @param {Object}      options\n * @param {Object}      options.where where A hash of search attributes.\n * @param {Object}      [options.defaults] Default values to use if creating a new instance\n * @see {Model#findAll} for a full specification of find and options\n * @return {Promise<Instance,created>}\n */\nModel.prototype.findCreateFind = function(options) {\n  if (!options || !options.where) {\n    throw new Error(\n      'Missing where attribute in the options parameter passed to findOrCreate.'\n    );\n  }\n\n  var values = Utils._.clone(options.defaults) || {};\n  if (Utils._.isPlainObject(options.where)) {\n    values = _.defaults(values, options.where);\n  }\n\n\n  return this.findOne(options).bind(this).then(function (result) {\n    if (result) return [result, false];\n\n    return this.create(values, options).bind(this).then(function (result) {\n      return [result, true];\n    }).catch(this.sequelize.UniqueConstraintError, function (err) {\n      return this.findOne(options).then(function (result) {\n        return [result, false];\n      });\n    });\n  });\n};\n\n/**\n * Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.\n *\n * **Implementation details:**\n *\n * * MySQL - Implemented as a single query `INSERT values ON DUPLICATE KEY UPDATE values`\n * * PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE\n * * SQLite - Implemented as two queries `INSERT; UPDATE`. This means that the update is executed regardless of whether the row already existed or not\n * * MSSQL - Implemented as a single query using `MERGE` and `WHEN (NOT) MATCHED THEN`\n * **Note** that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.\n *\n * @param  {Object}       values\n * @param  {Object}       [options]\n * @param  {Boolean}      [options.validate=true] Run validations before the row is inserted\n * @param  {Array}        [options.fields=Object.keys(this.attributes)] The fields to insert / update. Defaults to all fields\n * @param  {Transaction}  [options.transaction] Transaction to run query under\n * @param  {Function}     [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param  {Boolean}      [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @alias insertOrUpdate\n * @return {Promise<created>} Returns a boolean indicating whether the row was created or updated.\n */\nModel.prototype.upsert = function (values, options) {\n  options = Utils.cloneDeep(options) || {};\n\n  if (!options.fields) {\n    options.fields = Object.keys(this.attributes);\n  }\n\n  var createdAtAttr = this._timestampAttributes.createdAt\n    , updatedAtAttr = this._timestampAttributes.updatedAt\n    , hadPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values\n    , instance = this.build(values);\n\n  return instance.hookValidate(options).bind(this).then(function () {\n    // Map field names\n    var updatedDataValues = _.pick(instance.dataValues, Object.keys(instance._changed))\n      , insertValues = Utils.mapValueFieldNames(instance.dataValues, options.fields, this)\n      , updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this)\n      , now = Utils.now(this.sequelize.options.dialect);\n\n    // Attach createdAt\n    if (createdAtAttr && !updateValues[createdAtAttr]) {\n      insertValues[createdAtAttr] = this.$getDefaultTimestamp(createdAtAttr) || now;\n    }\n    if (updatedAtAttr && !insertValues[updatedAtAttr]) {\n      insertValues[updatedAtAttr] = updateValues[updatedAtAttr] = this.$getDefaultTimestamp(updatedAtAttr) || now;\n    }\n\n    // Build adds a null value for the primary key, if none was given by the user.\n    // We need to remove that because of some Postgres technicalities.\n    if (!hadPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {\n      delete insertValues[this.primaryKeyField];\n      delete updateValues[this.primaryKeyField];\n    }\n\n    return this.QueryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), this, options);\n  });\n};\n\nModel.prototype.insertOrUpdate = Model.prototype.upsert;\n\n/**\n * Create and insert multiple instances in bulk.\n *\n * The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL\n * and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records.\n * To obtain Instances for the newly created values, you will need to query for them again.\n *\n * @param  {Array}        records                          List of objects (key/value pairs) to create instances from\n * @param  {Object}       [options]\n * @param  {Array}        [options.fields]                 Fields to insert (defaults to all fields)\n * @param  {Boolean}      [options.validate=false]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation\n * @param  {Boolean}      [options.hooks=true]             Run before / after bulk create hooks?\n * @param  {Boolean}      [options.individualHooks=false]  Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.\n * @param  {Boolean}      [options.ignoreDuplicates=false] Ignore duplicate values for primary keys? (not supported by postgres)\n * @param  {Array}        [options.updateOnDuplicate]      Fields to update if row key already exists (on duplicate key update)? (only supported by mysql & mariadb). By default, all fields are updated.\n * @param  {Transaction}  [options.transaction] Transaction to run query under\n * @param  {Function}     [options.logging=false]          A function that gets executed while running the query to log the sql.\n * @param  {Boolean}      [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param  {Boolean}      [options.returning=false] Append RETURNING * to get back auto generated values (Postgres only)\n * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise<Array<Instance>>}\n */\nModel.prototype.bulkCreate = function(records, options) {\n  if (!records.length) {\n    return Promise.resolve([]);\n  }\n\n  options = Utils._.extend({\n    validate: false,\n    hooks: true,\n    individualHooks: false,\n    ignoreDuplicates: false\n  }, options || {});\n\n  options.fields = options.fields || Object.keys(this.tableAttributes);\n\n  // Expose model to global hooks\n  options.model = this;\n\n  var dialect = this.sequelize.options.dialect;\n  if (options.ignoreDuplicates && ['postgres', 'mssql'].indexOf(dialect) !== -1) {\n    return Promise.reject(new Error(dialect + ' does not support the \\'ignoreDuplicates\\' option.'));\n  }\n  if (options.updateOnDuplicate && ['mysql', 'mariadb'].indexOf(dialect) === -1) {\n    return Promise.reject(new Error(dialect + ' does not support the \\'updateOnDuplicate\\' option.'));\n  }\n\n  if (options.updateOnDuplicate) {\n    // By default, all attributes except 'createdAt' can be updated\n    var updatableFields = Utils._.pull(Object.keys(this.tableAttributes), 'createdAt');\n    if (Utils._.isArray(options.updateOnDuplicate) && !Utils._.isEmpty(options.updateOnDuplicate)) {\n      updatableFields = Utils._.intersection(updatableFields, options.updateOnDuplicate);\n    }\n    options.updateOnDuplicate = updatableFields;\n  }\n\n  var self = this\n    , createdAtAttr = this._timestampAttributes.createdAt\n    , updatedAtAttr = this._timestampAttributes.updatedAt\n    , now = Utils.now(self.modelManager.sequelize.options.dialect);\n\n  var instances = records.map(function(values) {\n    return self.build(values, {isNewRecord: true});\n  });\n\n  return Promise.try(function() {\n    // Run before hook\n    if (options.hooks) {\n      return self.runHooks('beforeBulkCreate', instances, options);\n    }\n  }).then(function() {\n    // Validate\n    if (options.validate) {\n      var errors = [];\n      return Promise.map(instances, function(instance) {\n        // hookValidate rejects with errors, validate returns with errors\n        if (options.individualHooks) {\n          return instance.hookValidate(options).catch(function (err) {\n            if (err) {\n              errors.push({record: instance, errors: err});\n            }\n          });\n        } else {\n          return instance.validate(options).then(function (err) {\n            if (err) {\n              errors.push({record: instance, errors: err});\n            }\n          });\n        }\n      }).then(function() {\n        delete options.skip;\n        if (errors.length) {\n          return Promise.reject(errors);\n        }\n      });\n    }\n  }).then(function() {\n    instances.forEach(function(instance) {\n      var values = Utils.mapValueFieldNames(instance.dataValues, options.fields, self);\n\n      // set createdAt/updatedAt attributes\n      if (createdAtAttr && !values[createdAtAttr]) {\n        values[createdAtAttr] = now;\n      }\n      if (updatedAtAttr && !values[updatedAtAttr]) {\n        values[updatedAtAttr] = now;\n      }\n\n      instance.dataValues = values;\n    });\n\n    if (options.individualHooks) {\n      // Create each instance individually\n      return Promise.map(instances, function(instance) {\n        var individualOptions = Utils._.clone(options);\n        delete individualOptions.fields;\n        delete individualOptions.individualHooks;\n        delete individualOptions.ignoreDuplicates;\n        individualOptions.validate = false;\n        individualOptions.hooks = true;\n\n        return instance.save(individualOptions);\n      }).then(function(_instances) {\n        instances = _instances;\n      });\n    } else {\n      // Create all in one query\n      // Recreate records from instances to represent any changes made in hooks or validation\n      records = instances.map(function(instance) {\n        return Utils._.omit(instance.dataValues, self._virtualAttributes);\n      });\n\n      // Map attributes for serial identification\n      var attributes = {};\n      for (var attr in self.tableAttributes) {\n        attributes[attr] = self.rawAttributes[attr];\n        if (self.rawAttributes[attr].field) {\n          attributes[self.rawAttributes[attr].field] = self.rawAttributes[attr];\n        }\n      }\n\n      return self.QueryInterface.bulkInsert(self.getTableName(options), records, options, attributes).then(function (results) {\n        if (Array.isArray(results)) {\n          results.forEach(function (result, i) {\n            instances[i].set(self.primaryKeyAttribute, result[self.rawAttributes[self.primaryKeyAttribute].field], {raw: true});\n            instances[i].isNewRecord = false;\n          });\n        }\n        return results;\n      });\n    }\n  }).then(function() {\n    // Run after hook\n    if (options.hooks) {\n      return self.runHooks('afterBulkCreate', instances, options);\n    }\n  }).then(function() {\n    return instances;\n  });\n};\n\n/**\n * Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).\n *\n * @param {object} [options] The options passed to Model.destroy in addition to truncate\n * @param {Boolean|function} [options.transaction] Transaction to run query under\n * @param {Boolean|function} [options.cascade = false] Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n * @param {Transaction}      [options.transaction] Transaction to run query under\n * @param {Boolean|function} [options.logging] A function that logs sql queries, or false for no logging\n * @param {Boolean}          [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param {String}           [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise}\n *\n * @see {Model#destroy} for more information\n */\nModel.prototype.truncate = function(options) {\n  options = Utils.cloneDeep(options) || {};\n  options.truncate = true;\n  return this.destroy(options);\n};\n\n/**\n * Delete multiple instances, or set their deletedAt timestamp to the current time if `paranoid` is enabled.\n *\n * @param  {Object}       options\n * @param  {Object}       [options.where]                 Filter the destroy\n * @param  {Boolean}      [options.hooks=true]            Run before / after bulk destroy hooks?\n * @param  {Boolean}      [options.individualHooks=false] If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row\n * @param  {Number}       [options.limit]                 How many rows to delete\n * @param  {Boolean}      [options.force=false]           Delete instead of setting deletedAt to current timestamp (only applicable if `paranoid` is enabled)\n * @param  {Boolean}      [options.truncate=false]        If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored\n * @param  {Boolean}      [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n * @param  {Boolean}      [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n * @param  {Transaction}  [options.transaction] Transaction to run query under\n * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.\n * @param  {Boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @return {Promise<Integer>} The number of destroyed rows\n */\nModel.prototype.destroy = function(options) {\n  var self = this\n    , instances;\n\n  if (!options || !(options.where || options.truncate)) {\n    throw new Error('Missing where or truncate attribute in the options parameter of model.destroy.');\n  }\n\n  if (!options.truncate && !_.isPlainObject(options.where) && !_.isArray(options.where) && options.where._isSequelizeMethod !== true) {\n    throw new Error('Expected plain object, array or sequelize method in the options.where parameter of model.destroy.');\n  }\n\n  options = Utils.cloneDeep(options);\n  options = _.defaults(options, {\n    hooks: true,\n    individualHooks: false,\n    force: false,\n    cascade: false,\n    restartIdentity: false\n  });\n\n  options.type = QueryTypes.BULKDELETE;\n  this.$injectScope(options);\n\n  Utils.mapOptionFieldNames(options, this);\n  options.model = self;\n\n  return Promise.try(function() {\n    // Run before hook\n    if (options.hooks) {\n      return self.runHooks('beforeBulkDestroy', options);\n    }\n  }).then(function() {\n    // Get daos and run beforeDestroy hook on each record individually\n    if (options.individualHooks) {\n      return self.findAll({where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark}).map(function(instance) {\n        return self.runHooks('beforeDestroy', instance, options).then(function() {\n          return instance;\n        });\n      }).then(function(_instances) {\n        instances = _instances;\n      });\n    }\n  }).then(function() {\n\n    // Run delete query (or update if paranoid)\n    if (self._timestampAttributes.deletedAt && !options.force) {\n      // Set query type appropriately when running soft delete\n      options.type = QueryTypes.BULKUPDATE;\n\n      var attrValueHash = {}\n        , deletedAtAttribute = self.rawAttributes[self._timestampAttributes.deletedAt]\n        , field = self.rawAttributes[self._timestampAttributes.deletedAt].field\n        , where = {};\n\n      where[field] = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n      attrValueHash[field] = Utils.now(self.modelManager.sequelize.options.dialect);\n      return self.QueryInterface.bulkUpdate(self.getTableName(options), attrValueHash, _.defaults(where, options.where), options, self.rawAttributes);\n    } else {\n      return self.QueryInterface.bulkDelete(self.getTableName(options), options.where, options, self);\n    }\n  }).tap(function() {\n    // Run afterDestroy hook on each record individually\n    if (options.individualHooks) {\n      return Promise.map(instances, function(instance) {\n        return self.runHooks('afterDestroy', instance, options);\n      });\n    }\n  }).tap(function() {\n    // Run after hook\n    if (options.hooks) {\n      return self.runHooks('afterBulkDestroy', options);\n    }\n  }).then(function(affectedRows) {\n    return affectedRows;\n  });\n};\n\n/**\n * Restore multiple instances if `paranoid` is enabled.\n *\n * @param  {Object}       options\n * @param  {Object}       [options.where]                 Filter the restore\n * @param  {Boolean}      [options.hooks=true]            Run before / after bulk restore hooks?\n * @param  {Boolean}      [options.individualHooks=false] If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row\n * @param  {Number}       [options.limit]                 How many rows to undelete\n * @param  {Function}     [options.logging=false]         A function that gets executed while running the query to log the sql.\n * @param  {Boolean}      [options.benchmark=false]       Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param  {Transaction}  [options.transaction] Transaction to run query under\n *\n * @return {Promise<undefined>}\n */\nModel.prototype.restore = function(options) {\n  if (!this._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');\n\n  options = Utils._.extend({\n    hooks: true,\n    individualHooks: false\n  }, options || {});\n\n  options.type = QueryTypes.RAW;\n\n  // Expose model to global hooks\n  options.model = this;\n\n  var self = this\n    , instances;\n\n  Utils.mapOptionFieldNames(options, this);\n\n  return Promise.try(function() {\n    // Run before hook\n    if (options.hooks) {\n      return self.runHooks('beforeBulkRestore', options);\n    }\n  }).then(function() {\n    // Get daos and run beforeRestore hook on each record individually\n    if (options.individualHooks) {\n      return self.findAll({where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false}).map(function(instance) {\n        return self.runHooks('beforeRestore', instance, options).then(function() {\n          return instance;\n        });\n      }).then(function(_instances) {\n        instances = _instances;\n      });\n    }\n  }).then(function() {\n    // Run undelete query\n    var attrValueHash = {}\n      , deletedAtCol = self._timestampAttributes.deletedAt\n      , deletedAtAttribute = self.rawAttributes[deletedAtCol]\n      , deletedAtDefaultValue = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n    attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n    options.omitNull = false;\n    return self.QueryInterface.bulkUpdate(self.getTableName(options), attrValueHash, options.where, options, self._timestampAttributes.deletedAt);\n  }).tap(function() {\n    // Run afterDestroy hook on each record individually\n    if (options.individualHooks) {\n      return Promise.map(instances, function(instance) {\n        return self.runHooks('afterRestore', instance, options);\n      });\n    }\n  }).tap(function() {\n    // Run after hook\n    if (options.hooks) {\n      return self.runHooks('afterBulkRestore', options);\n    }\n  }).then(function(affectedRows) {\n    return affectedRows;\n  });\n};\n\n/**\n * Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number\n * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true.)\n *\n * @param  {Object}       values\n * @param  {Object}       options\n * @param  {Object}       options.where                   Options to describe the scope of the search.\n * @param  {Array}        [options.fields]                Fields to update (defaults to all fields)\n * @param  {Boolean}      [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation\n * @param  {Boolean}      [options.hooks=true]            Run before / after bulk update hooks?\n * @param  {Boolean}      [options.sideEffects=true] Whether or not to update the side effects of any virtual setters.\n * @param  {Boolean}      [options.individualHooks=false] Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks\n * @param  {Boolean}      [options.returning=false]       Return the affected rows (only for postgres)\n * @param  {Number}       [options.limit]                 How many rows to update (only for mysql and mariadb)\n * @param  {Function}     [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param  {Boolean}      [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).\n * @param  {Transaction}  [options.transaction] Transaction to run query under\n * @param  {Boolean}      [options.silent=false] If true, the updatedAt timestamp will not be updated.\n *\n * @return {Promise<Array<affectedCount,affectedRows>>}\n */\nModel.prototype.update = function(values, options) {\n  var self = this;\n\n  if (!options || !options.where) {\n    throw new Error('Missing where attribute in the options parameter passed to update.');\n  }\n\n  if (!_.isPlainObject(options.where) && !_.isArray(options.where) && options.where._isSequelizeMethod !== true) {\n    throw new Error('Expected plain object, array or sequelize method in the options.where parameter of model.update.');\n  }\n\n  options = Utils.cloneDeep(options);\n  options = _.defaults(options, {\n    validate: true,\n    hooks: true,\n    individualHooks: false,\n    returning: false,\n    force: false,\n    sideEffects: true\n  });\n\n  options.type = QueryTypes.BULKUPDATE;\n\n  // Expose model to global hooks\n  options.model = this;\n\n  this.$injectScope(options);\n\n  // Clone values so it doesn't get modified for caller scope\n  values = _.clone(values);\n\n  // Remove values that are not in the options.fields\n  if (options.fields && options.fields instanceof Array) {\n    Object.keys(values).forEach(function(key) {\n      if (options.fields.indexOf(key) < 0) {\n        delete values[key];\n      }\n    });\n  } else {\n    var updatedAtAttr = this._timestampAttributes.updatedAt;\n    options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));\n    if (updatedAtAttr && options.fields.indexOf(updatedAtAttr) === -1) {\n      options.fields.push(updatedAtAttr);\n    }\n  }\n\n  if (this._timestampAttributes.updatedAt && !options.silent) {\n    values[this._timestampAttributes.updatedAt] = this.$getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);\n  }\n\n  var instances\n    , valuesUse;\n\n  return Promise.try(function() {\n    // Validate\n    if (options.validate) {\n      var build = self.build(values);\n      build.set(self._timestampAttributes.updatedAt, values[self._timestampAttributes.updatedAt], { raw: true });\n\n      if (options.sideEffects) {\n        values = Utils._.assign(values, Utils._.pick(build.get(), build.changed()));\n        options.fields = Utils._.union(options.fields, Object.keys(values));\n      }\n\n      // We want to skip validations for all other fields\n      options.skip = Utils._.difference(Object.keys(self.attributes), Object.keys(values));\n      return build.hookValidate(options).then(function(attributes) {\n        options.skip = undefined;\n        if (attributes && attributes.dataValues) {\n          values = Utils._.pick(attributes.dataValues, Object.keys(values));\n        }\n      });\n    }\n    return null;\n  }).then(function() {\n    // Run before hook\n    if (options.hooks) {\n      options.attributes = values;\n      return self.runHooks('beforeBulkUpdate', options).then(function() {\n        values = options.attributes;\n        delete options.attributes;\n      });\n    }\n    return null;\n  }).then(function() {\n    valuesUse = values;\n\n    // Get instances and run beforeUpdate hook on each record individually\n    if (options.individualHooks) {\n      return self.findAll({where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark}).then(function(_instances) {\n        instances = _instances;\n        if (!instances.length) {\n          return [];\n        }\n\n        // Run beforeUpdate hooks on each record and check whether beforeUpdate hook changes values uniformly\n        // i.e. whether they change values for each record in the same way\n        var changedValues\n          , different = false;\n\n        return Promise.map(instances, function(instance) {\n          // Record updates in instances dataValues\n          Utils._.extend(instance.dataValues, values);\n          // Set the changed fields on the instance\n          Utils._.forIn(valuesUse, function(newValue, attr) {\n            if (newValue !== instance._previousDataValues[attr]) {\n              instance.setDataValue(attr, newValue);\n            }\n          });\n\n          // Run beforeUpdate hook\n          return self.runHooks('beforeUpdate', instance, options).then(function() {\n            if (!different) {\n              var thisChangedValues = {};\n              Utils._.forIn(instance.dataValues, function(newValue, attr) {\n                if (newValue !== instance._previousDataValues[attr]) {\n                  thisChangedValues[attr] = newValue;\n                }\n              });\n\n              if (!changedValues) {\n                changedValues = thisChangedValues;\n              } else {\n                different = !Utils._.isEqual(changedValues, thisChangedValues);\n              }\n            }\n\n            return instance;\n          });\n        }).then(function(_instances) {\n          instances = _instances;\n\n          if (!different) {\n            var keys = Object.keys(changedValues);\n            // Hooks do not change values or change them uniformly\n            if (keys.length) {\n              // Hooks change values - record changes in valuesUse so they are executed\n              valuesUse = changedValues;\n              options.fields = Utils._.union(options.fields, keys);\n            }\n            return;\n          } else {\n            // Hooks change values in a different way for each record\n            // Do not run original query but save each record individually\n            return Promise.map(instances, function(instance) {\n              var individualOptions = Utils._.clone(options);\n              delete individualOptions.individualHooks;\n              individualOptions.hooks = false;\n              individualOptions.validate = false;\n\n              return instance.save(individualOptions);\n            }).tap(function(_instances) {\n              instances = _instances;\n            });\n          }\n        });\n      });\n    }\n  }).then(function(results) {\n    if (results) {\n      // Update already done row-by-row - exit\n      return [results.length, results];\n    }\n\n    valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, self);\n    options = Utils.mapOptionFieldNames(options, self);\n    options.hasTrigger =  self.options ? self.options.hasTrigger : false;\n\n    // Run query to update all rows\n    return self.QueryInterface.bulkUpdate(self.getTableName(options), valuesUse, options.where, options, self.tableAttributes).then(function(affectedRows) {\n      if (options.returning) {\n        instances = affectedRows;\n        return [affectedRows.length, affectedRows];\n      }\n\n      return [affectedRows];\n    });\n  }).tap(function(result) {\n    if (options.individualHooks) {\n      return Promise.map(instances, function(instance) {\n        return self.runHooks('afterUpdate', instance, options);\n      }).then(function() {\n        result[1] = instances;\n      });\n    }\n  }).tap(function() {\n    // Run after hook\n    if (options.hooks) {\n      options.attributes = values;\n      return self.runHooks('afterBulkUpdate', options).then(function() {\n        delete options.attributes;\n      });\n    }\n  }).then(function(result) {\n    // Return result in form [affectedRows, instances] (instances missed off if options.individualHooks != true)\n    return result;\n  });\n};\n\n/**\n * Run a describe query on the table. The result will be return to the listener as a hash of attributes and their types.\n *\n * @return {Promise}\n */\nModel.prototype.describe = function(schema, options) {\n  return this.QueryInterface.describeTable(this.tableName, _.assign({schema: schema || this.$schema || undefined}, options));\n};\n\nModel.prototype.$getDefaultTimestamp = function(attr) {\n  if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {\n    return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue);\n  }\n  return undefined;\n};\n\nModel.prototype.$expandAttributes = function (options) {\n  if (_.isPlainObject(options.attributes)) {\n    var attributes = Object.keys(this.rawAttributes);\n\n    if (options.attributes.exclude) {\n      attributes = attributes.filter(function (elem) {\n        return options.attributes.exclude.indexOf(elem) === -1;\n      });\n    }\n    if (options.attributes.include) {\n      attributes = attributes.concat(options.attributes.include);\n    }\n\n    options.attributes = attributes;\n  }\n};\n\n// Inject $scope into options. Includes should have been conformed (conformOptions) before calling this\nModel.prototype.$injectScope = function (options) {\n  var self = this;\n  var scope = Utils.cloneDeep(this.$scope);\n\n  var filteredScope = _.omit(scope, 'include'); // Includes need special treatment\n\n  _.defaults(options, filteredScope);\n  _.defaults(options.where, filteredScope.where);\n\n  if (scope.include) {\n    options.include = options.include || [];\n\n    // Reverse so we consider the latest include first.\n    // This is used if several scopes specify the same include - the last scope should take precedence\n    scope.include.reverse().forEach(function (scopeInclude) {\n      if (scopeInclude.all || !options.include.some(function matchesModelAndAlias(item) {\n        var isSameModel = item.model && item.model.name === scopeInclude.model.name;\n        if (!isSameModel || !item.as) return isSameModel;\n\n        if (scopeInclude.as) {\n          return item.as === scopeInclude.as;\n        } else {\n          var association = scopeInclude.association || self.getAssociation(scopeInclude.model, scopeInclude.as);\n          return association ? item.as === association.as : false;\n        }\n      })) {\n        options.include.push(scopeInclude);\n      }\n    });\n  }\n};\n\nModel.prototype.inspect = function() {\n  return this.name;\n};\n\nUtils._.extend(Model.prototype, associationsMixin);\nHooks.applyTo(Model);\n\nmodule.exports = Model;\nmodule.exports.Model = Model;\nmodule.exports.default = Model;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/instance.js":"'use strict';\n\nvar Utils = require('./utils')\n  , BelongsTo = require('./associations/belongs-to')\n  , BelongsToMany = require('./associations/belongs-to-many')\n  , InstanceValidator = require('./instance-validator')\n  , QueryTypes = require('./query-types')\n  , sequelizeErrors = require('./errors')\n  , Dottie = require('dottie')\n  , Promise = require('./promise')\n  , _ = require('lodash')\n  , defaultsOptions = { raw: true };\n\n// private\nvar initValues = function(values, options) {\n  var defaults\n    , key;\n\n  values = values && _.clone(values) || {};\n\n  if (options.isNewRecord) {\n    defaults = {};\n\n    if (this.Model._hasDefaultValues) {\n      defaults = _.mapValues(this.Model._defaultValues, function(valueFn) {\n        var value = valueFn();\n        return (value && value._isSequelizeMethod) ? value : _.cloneDeep(value);\n      });\n    }\n\n    // set id to null if not passed as value, a newly created dao has no id\n    // removing this breaks bulkCreate\n    // do after default values since it might have UUID as a default value\n    if (!defaults.hasOwnProperty(this.Model.primaryKeyAttribute)) {\n      defaults[this.Model.primaryKeyAttribute] = null;\n    }\n\n    if (this.Model._timestampAttributes.createdAt && defaults[this.Model._timestampAttributes.createdAt]) {\n      this.dataValues[this.Model._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.Model._timestampAttributes.createdAt]);\n      delete defaults[this.Model._timestampAttributes.createdAt];\n    }\n\n    if (this.Model._timestampAttributes.updatedAt && defaults[this.Model._timestampAttributes.updatedAt]) {\n      this.dataValues[this.Model._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.Model._timestampAttributes.updatedAt]);\n      delete defaults[this.Model._timestampAttributes.updatedAt];\n    }\n\n    if (this.Model._timestampAttributes.deletedAt && defaults[this.Model._timestampAttributes.deletedAt]) {\n      this.dataValues[this.Model._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.Model._timestampAttributes.deletedAt]);\n      delete defaults[this.Model._timestampAttributes.deletedAt];\n    }\n\n    if (Object.keys(defaults).length) {\n      for (key in defaults) {\n        if (values[key] === undefined) {\n          this.set(key, Utils.toDefaultValue(defaults[key]), defaultsOptions);\n          delete values[key];\n        }\n      }\n    }\n  }\n\n  this.set(values, options);\n};\n\n/**\n * This class represents an single instance, a database row. You might see it referred to as both Instance and instance. You should not\n * instantiate the Instance class directly, instead you access it using the finder and creation methods on the model.\n *\n * Instance instances operate with the concept of a `dataValues` property, which stores the actual values represented by the instance.\n * By default, the values from dataValues can also be accessed directly from the Instance, that is:\n * ```js\n * instance.field\n * // is the same as\n * instance.get('field')\n * // is the same as\n * instance.getDataValue('field')\n * ```\n * However, if getters and/or setters are defined for `field` they will be invoked, instead of returning the value from `dataValues`.\n * Accessing properties directly or using `get` is preferred for regular use, `getDataValue` should only be used for custom getters.\n *\n * @see {Sequelize#define} for more information about getters and setters\n * @class Instance\n */\nvar Instance = function(values, options) {\n  this.dataValues = {};\n  this._previousDataValues = {};\n  this._changed = {};\n  this.$modelOptions = this.Model.options;\n  this.$options = options || {};\n  this.hasPrimaryKeys = this.Model.options.hasPrimaryKeys;\n  this.__eagerlyLoadedAssociations = [];\n  /**\n   * Returns true if this instance has not yet been persisted to the database\n   * @property isNewRecord\n   * @return {Boolean}\n   */\n  this.isNewRecord = options.isNewRecord;\n\n  /**\n   * Returns the Model the instance was created from.\n   * @see {Model}\n   * @property Model\n   * @return {Model}\n   */\n\n  initValues.call(this, values, options);\n};\n\n/**\n * A reference to the sequelize instance\n * @see {Sequelize}\n * @property sequelize\n * @return {Sequelize}\n */\nObject.defineProperty(Instance.prototype, 'sequelize', {\n  get: function() { return this.Model.modelManager.sequelize; }\n});\n\n/**\n * Get an object representing the query for this instance, use with `options.where`\n *\n * @property where\n * @return {Object}\n */\nInstance.prototype.where = function() {\n  var where;\n\n  where = this.Model.primaryKeyAttributes.reduce(function (result, attribute) {\n    result[attribute] = this.get(attribute, {raw: true});\n    return result;\n  }.bind(this), {});\n\n  if (_.size(where) === 0) {\n    return this.$modelOptions.whereCollection;\n  }\n  return Utils.mapWhereFieldNames(where, this.$Model);\n};\n\nInstance.prototype.toString = function () {\n  return '[object SequelizeInstance:'+this.Model.name+']';\n};\n\n/**\n * Get the value of the underlying data value\n *\n * @param {String} key\n * @return {any}\n */\nInstance.prototype.getDataValue = function(key) {\n  return this.dataValues[key];\n};\n\n/**\n * Update the underlying data value\n *\n * @param {String} key\n * @param {any} value\n */\nInstance.prototype.setDataValue = function(key, value) {\n  var originalValue = this._previousDataValues[key];\n  if (!Utils.isPrimitive(value) || value !== originalValue) {\n    this.changed(key, true);\n  }\n\n  this.dataValues[key] = value;\n};\n\n/**\n * If no key is given, returns all values of the instance, also invoking virtual getters.\n *\n * If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.\n *\n * @param {String} [key]\n * @param {Object} [options]\n * @param {Boolean} [options.plain=false] If set to true, included instances will be returned as plain objects\n * @return {Object|any}\n */\nInstance.prototype.get = function(key, options) { // testhint options:none\n  if (options === undefined && typeof key === 'object') {\n    options = key;\n    key = undefined;\n  }\n\n  if (key) {\n    if (this._customGetters[key]) {\n      return this._customGetters[key].call(this, key);\n    }\n    if (options && options.plain && this.$options.include && this.$options.includeNames.indexOf(key) !== -1) {\n      if (Array.isArray(this.dataValues[key])) {\n        return this.dataValues[key].map(function (instance) {\n          return instance.get({plain: options.plain});\n        });\n      } else if (this.dataValues[key] instanceof Instance) {\n        return this.dataValues[key].get({plain: options.plain});\n      } else {\n        return this.dataValues[key];\n      }\n    }\n\t\treturn this.dataValues[key];\n  }\n\n  if (this._hasCustomGetters || (options && options.plain && this.$options.include) || (options && options.clone)) {\n    var values = {}\n      , _key;\n\n    if (this._hasCustomGetters) {\n      for (_key in this._customGetters) {\n        if (this._customGetters.hasOwnProperty(_key)) {\n          values[_key] = this.get(_key, options);\n        }\n      }\n    }\n\n    for (_key in this.dataValues) {\n      if (!values.hasOwnProperty(_key) && this.dataValues.hasOwnProperty(_key)) {\n        values[_key] = this.get(_key, options);\n      }\n    }\n    return values;\n  }\n  return this.dataValues;\n};\n\n/**\n * Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call `save`).\n * In its most basic form `set` will update a value stored in the underlying `dataValues` object. However, if a custom setter function is defined for the key, that function\n * will be called instead. To bypass the setter, you can pass `raw: true` in the options object.\n *\n * If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be\n * set directly to the object passed, or used to extend dataValues, if dataValues already contain values.\n *\n * When set is called, the previous value of the field is stored and sets a changed flag(see `changed`).\n *\n * Set can also be used to build instances for associations, if you have values for those.\n * When using set with associations you need to make sure the property key matches the alias of the association\n * while also making sure that the proper include options have been set (from .build() or .find())\n *\n * If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.\n *\n * @see {Model#find} for more information about includes\n * @param {String|Object} key\n * @param {any} value\n * @param {Object} [options]\n * @param {Boolean} [options.raw=false] If set to true, field and virtual setters will be ignored\n * @param {Boolean} [options.reset=false] Clear all previously set data values\n * @alias setAttributes\n */\nInstance.prototype.set = function(key, value, options) { // testhint options:none\n  var values\n    , originalValue\n    , keys\n    , i\n    , length;\n\n  if (typeof key === 'object' && key !== null) {\n    values = key;\n    options = value || {};\n\n    if (options.reset) {\n      this.dataValues = {};\n    }\n\n    // If raw, and we're not dealing with includes or special attributes, just set it straight on the dataValues object\n    if (options.raw && !(this.$options && this.$options.include) && !(options && options.attributes) && !this.Model._hasBooleanAttributes && !this.Model._hasDateAttributes) {\n      if (Object.keys(this.dataValues).length) {\n        this.dataValues = _.extend(this.dataValues, values);\n      } else {\n        this.dataValues = values;\n      }\n      // If raw, .changed() shouldn't be true\n      this._previousDataValues = _.clone(this.dataValues);\n    } else {\n      // Loop and call set\n\n      if (options.attributes) {\n        keys = options.attributes;\n        if (this.Model._hasVirtualAttributes) {\n          keys = keys.concat(this.Model._virtualAttributes);\n        }\n\n        if (this.$options.includeNames) {\n          keys = keys.concat(this.$options.includeNames);\n        }\n\n        for (i = 0, length = keys.length; i < length; i++) {\n          if (values[keys[i]] !== undefined) {\n            this.set(keys[i], values[keys[i]], options);\n          }\n        }\n      } else {\n        for (key in values) {\n          this.set(key, values[key], options);\n        }\n      }\n\n      if (options.raw) {\n        // If raw, .changed() shouldn't be true\n        this._previousDataValues = _.clone(this.dataValues);\n      }\n    }\n  } else {\n    if (!options)\n      options = {};\n    if (!options.raw) {\n      originalValue = this.dataValues[key];\n    }\n\n    // If not raw, and there's a customer setter\n    if (!options.raw && this._customSetters[key]) {\n      this._customSetters[key].call(this, value, key);\n      if (!Utils.isPrimitive(value) && value !== null || value !== originalValue) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n    } else {\n      // Check if we have included models, and if this key matches the include model names/aliases\n\n      if (this.$options && this.$options.include && this.$options.includeNames.indexOf(key) !== -1) {\n        // Pass it on to the include handler\n        this._setInclude(key, value, options);\n        return this;\n      } else {\n        // Bunch of stuff we won't do when its raw\n        if (!options.raw) {\n          // If attribute is not in model definition, return\n          if (!this._isAttribute(key)) {\n            if (key.indexOf('.') > -1 && this.Model._isJsonAttribute(key.split('.')[0])) {\n              var previousDottieValue = Dottie.get(this.dataValues, key);\n              if (!_.isEqual(previousDottieValue, value)) {\n                Dottie.set(this.dataValues, key, value);\n                this.changed(key.split('.')[0], true);\n              }\n            }\n            return this;\n          }\n\n          // If attempting to set primary key and primary key is already defined, return\n          if (this.Model._hasPrimaryKeys && originalValue && this.Model._isPrimaryKey(key)) {\n            return this;\n          }\n\n          // If attempting to set read only attributes, return\n          if (!this.isNewRecord && this.Model._hasReadOnlyAttributes && this.Model._isReadOnlyAttribute(key)) {\n            return this;\n          }\n\n          // Convert date fields to real date objects\n          if (this.Model._hasDateAttributes && this.Model._isDateAttribute(key) && !!value && !value._isSequelizeMethod) {\n            if (!(value instanceof Date)) {\n              value = new Date(value);\n            }\n            if (originalValue) {\n              if (!(originalValue instanceof Date)) {\n                originalValue = new Date(originalValue);\n              }\n              if (value.getTime() === originalValue.getTime()) {\n                return this;\n              }\n            }\n          }\n        }\n\n        // Convert boolean-ish values to booleans\n        if (this.Model._hasBooleanAttributes && this.Model._isBooleanAttribute(key) && value !== null && value !== undefined && !value._isSequelizeMethod) {\n          if (Buffer.isBuffer(value) && value.length === 1) {\n            // Bit fields are returned as buffers\n            value = value[0];\n          }\n\n          if (_.isString(value)) {\n            // Only take action on valid boolean strings.\n            value = (value === 'true') ? true : (value === 'false') ? false : value;\n\n          } else if (_.isNumber(value)) {\n            // Only take action on valid boolean integers.\n            value = (value === 1) ? true : (value === 0) ? false : value;\n          }\n        }\n\n        if (!options.raw && ((!Utils.isPrimitive(value) && value !== null) || value !== originalValue)) {\n          this._previousDataValues[key] = originalValue;\n          this.changed(key, true);\n        }\n        this.dataValues[key] = value;\n      }\n    }\n  }\n\n  return this;\n};\n\nInstance.prototype.setAttributes = function(updates) {\n  return this.set(updates);\n};\n\n/**\n * If changed is called with a string it will return a boolean indicating whether the value of that key in `dataValues` is different from the value in `_previousDataValues`.\n *\n * If changed is called without an argument, it will return an array of keys that have changed.\n *\n * If changed is called without an argument and no keys have changed, it will return `false`.\n *\n * @param {String} [key]\n * @return {Boolean|Array}\n */\nInstance.prototype.changed = function(key, value) {\n  if (key) {\n    if (value !== undefined) {\n      this._changed[key] = value;\n      return this;\n    }\n    return this._changed[key] || false;\n  }\n\n  var changed = Object.keys(this.dataValues).filter(function(key) {\n    return this.changed(key);\n  }.bind(this));\n\n  return changed.length ? changed : false;\n};\n\n/**\n * Returns the previous value for key from `_previousDataValues`.\n *\n * If called without a key, returns the previous values for all values which have changed\n *\n * @param {String} [key]\n * @return {any|Array<any>}\n */\nInstance.prototype.previous = function(key) {\n  if (key) {\n    return this._previousDataValues[key];\n  }\n\n  return _.pickBy(this._previousDataValues, function(value, key) {\n    return this.changed(key);\n  }.bind(this));\n};\n\nInstance.prototype._setInclude = function(key, value, options) {\n  if (!Array.isArray(value)) value = [value];\n  if (value[0] instanceof Instance) {\n    value = value.map(function(instance) {\n      return instance.dataValues;\n    });\n  }\n\n  var include = this.$options.includeMap[key]\n    , association = include.association\n    , self = this\n    , accessor = key\n    , childOptions\n    , primaryKeyAttribute  = include.model.primaryKeyAttribute\n    , isEmpty;\n\n  if (!isEmpty) {\n    childOptions = {\n      isNewRecord: this.isNewRecord,\n      include: include.include,\n      includeNames: include.includeNames,\n      includeMap: include.includeMap,\n      includeValidated: true,\n      raw: options.raw,\n      attributes: include.originalAttributes\n    };\n  }\n  if (include.originalAttributes === undefined || include.originalAttributes.length) {\n    if (association.isSingleAssociation) {\n      if (Array.isArray(value)) {\n        value = value[0];\n      }\n\n      isEmpty = (value && value[primaryKeyAttribute] === null) || (value === null);\n      self[accessor] = self.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);\n    } else {\n      isEmpty = value[0] && value[0][primaryKeyAttribute] === null;\n      self[accessor] = self.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);\n    }\n  }\n};\n\n/**\n * Validate this instance, and if the validation passes, persist it to the database. It will only save changed fields, and do nothing if no fields have changed.\n *\n * On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of `Sequelize.ValidationError`.\n * This error will have a property for each of the fields for which validation failed, with the error message for that field.\n *\n * @param {Object} [options]\n * @param {string[]} [options.fields] An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved.\n * @param {Boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n * @param {Boolean} [options.validate=true] If false, validations won't be run.\n * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Transaction} [options.transaction]\n * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise<this|Errors.ValidationError>}\n */\nInstance.prototype.save = function(options) {\n  if (arguments.length > 1) {\n    throw new Error('The second argument was removed in favor of the options object.');\n  }\n\n  options = Utils.cloneDeep(options);\n  options = _.defaults(options, {\n    hooks: true,\n    validate: true\n  });\n\n  if (!options.fields) {\n    if (this.isNewRecord) {\n      options.fields = Object.keys(this.Model.attributes);\n    } else {\n      options.fields = _.intersection(this.changed(), Object.keys(this.Model.attributes));\n    }\n\n    options.defaultFields = options.fields;\n  }\n\n  if (options.returning === undefined) {\n    if (options.association) {\n      options.returning = false;\n    } else if (this.isNewRecord) {\n      options.returning = true;\n    }\n  }\n\n  var self = this\n    , primaryKeyName = this.Model.primaryKeyAttribute\n    , primaryKeyAttribute = primaryKeyName && this.Model.rawAttributes[primaryKeyName]\n    , updatedAtAttr = this.Model._timestampAttributes.updatedAt\n    , createdAtAttr = this.Model._timestampAttributes.createdAt\n    , hook = self.isNewRecord ? 'Create' : 'Update'\n    , wasNewRecord = this.isNewRecord\n    , now = Utils.now(this.sequelize.options.dialect);\n\n  if (updatedAtAttr && options.fields.length >= 1 && options.fields.indexOf(updatedAtAttr) === -1) {\n    options.fields.push(updatedAtAttr);\n  }\n\n  if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, {raw: true}))) {\n    // UpdateAtAttr might have been added as a result of Object.keys(Model.attributes). In that case we have to remove it again\n    Utils._.remove(options.fields, function(val) {\n      return val === updatedAtAttr;\n    });\n    updatedAtAttr = false;\n  }\n\n  if (this.isNewRecord === true) {\n    if (createdAtAttr && options.fields.indexOf(createdAtAttr) === -1) {\n      options.fields.push(createdAtAttr);\n    }\n\n    if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && options.fields.indexOf(primaryKeyName) < 0) {\n      options.fields.unshift(primaryKeyName);\n    }\n  }\n\n  if (this.isNewRecord === false) {\n    if (primaryKeyName && this.get(primaryKeyName, {raw: true}) === undefined) {\n      throw new Error('You attempted to save an instance with no primary key, this is not allowed since it would result in a global update');\n    }\n  }\n\n  if (updatedAtAttr && !options.silent && options.fields.indexOf(updatedAtAttr) !== -1) {\n    this.dataValues[updatedAtAttr] = this.Model.$getDefaultTimestamp(updatedAtAttr) || now;\n  }\n\n  if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {\n    this.dataValues[createdAtAttr] = this.Model.$getDefaultTimestamp(createdAtAttr) || now;\n  }\n\n  return Promise.bind(this).then(function() {\n    // Validate\n    if (options.validate) {\n      return Promise.bind(this).then(function () {\n        // hookValidate rejects with errors, validate returns with errors\n        if (options.hooks) return this.hookValidate(options);\n\n        return this.validate(options).then(function (err) {\n          if (err) throw err;\n        });\n      });\n    }\n  }).then(function() {\n    return Promise.bind(this).then(function() {\n      // Run before hook\n      if (options.hooks) {\n        var beforeHookValues = _.pick(this.dataValues, options.fields)\n          , afterHookValues\n          , hookChanged\n          , ignoreChanged = _.difference(this.changed(), options.fields); // In case of update where it's only supposed to update the passed values and the hook values\n\n        if (updatedAtAttr && options.fields.indexOf(updatedAtAttr) !== -1) {\n          ignoreChanged = _.without(ignoreChanged, updatedAtAttr);\n        }\n\n        return this.Model.runHooks('before' + hook, this, options).bind(this).then(function() {\n          if (options.defaultFields && !this.isNewRecord) {\n            afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));\n\n            hookChanged = [];\n            Object.keys(afterHookValues).forEach(function (key) {\n              if (afterHookValues[key] !== beforeHookValues[key]) {\n                hookChanged.push(key);\n              }\n            });\n\n            options.fields = _.uniq(options.fields.concat(hookChanged));\n          }\n\n          if (hookChanged) {\n            if (options.validate) {\n              // Validate again\n\n              options.skip = _.difference(Object.keys(this.Model.rawAttributes), hookChanged);\n              return Promise.bind(this).then(function () {\n                // hookValidate rejects with errors, validate returns with errors\n                if (options.hooks) return this.hookValidate(options);\n\n                return this.validate(options).then(function (err) {\n                  if (err) throw err;\n                });\n              }).then(function() {\n                delete options.skip;\n              });\n            }\n          }\n        });\n      }\n    }).then(function() {\n      if (!options.fields.length) return this;\n      if (!this.isNewRecord) return this;\n      if (!this.$options.include || !this.$options.include.length) return this;\n\n      // Nested creation for BelongsTo relations\n      return Promise.map(this.$options.include.filter(function (include) {\n        return include.association instanceof BelongsTo;\n      }), function (include) {\n        var instance = self.get(include.as);\n        if (!instance) return Promise.resolve();\n\n        var includeOptions =  _(Utils.cloneDeep(include))\n          .omit(['association'])\n          .defaults({\n            transaction: options.transaction,\n            logging: options.logging,\n            parentRecord: self\n          }).value();\n\n        return instance.save(includeOptions).then(function () {\n          return self[include.association.accessors.set](instance, {save: false, logging: options.logging});\n        });\n      });\n    })\n    .then(function() {\n      var realFields = [];\n      options.fields.forEach(function(field) {\n        if (!self.Model._isVirtualAttribute(field)) {\n          realFields.push(field);\n        }\n      });\n      if (!realFields.length) return this;\n      if (!this.changed() && !this.isNewRecord) return this;\n\n      var values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.Model)\n        , query = null\n        , args = [];\n\n      if (self.isNewRecord) {\n        query = 'insert';\n        args = [self, self.$Model.getTableName(options), values, options];\n      } else {\n        var where = this.where();\n\n        where = Utils.mapValueFieldNames(where, Object.keys(where), this.Model);\n\n        query = 'update';\n        args = [self, self.$Model.getTableName(options), values, where, options];\n      }\n\n      return self.sequelize.getQueryInterface()[query].apply(self.sequelize.getQueryInterface(), args)\n        .then(function(result) {\n          // Transfer database generated values (defaults, autoincrement, etc)\n          Object.keys(self.Model.rawAttributes).forEach(function (attr) {\n            if (self.Model.rawAttributes[attr].field &&\n                values[self.Model.rawAttributes[attr].field] !== undefined &&\n                self.Model.rawAttributes[attr].field !== attr\n            ) {\n              values[attr] = values[self.Model.rawAttributes[attr].field];\n              delete values[self.Model.rawAttributes[attr].field];\n            }\n          });\n          values = _.extend(values, result.dataValues);\n\n          result.dataValues = _.extend(result.dataValues, values);\n          return result;\n        })\n        .tap(function(result) {\n          // Run after hook\n          if (options.hooks) {\n            return self.Model.runHooks('after' + hook, result, options);\n          }\n        })\n        .then(function(result) {\n          options.fields.forEach(function (field) {\n            result._previousDataValues[field] = result.dataValues[field];\n            self.changed(field, false);\n          });\n          self.isNewRecord = false;\n          return result;\n        })\n        .tap(function() {\n          if (!wasNewRecord) return self;\n          if (!self.$options.include || !self.$options.include.length) return self;\n\n          // Nested creation for HasOne/HasMany/BelongsToMany relations\n          return Promise.map(self.$options.include.filter(function (include) {\n            return !(include.association instanceof BelongsTo);\n          }), function (include) {\n            var instances = self.get(include.as);\n\n            if (!instances) return Promise.resolve();\n            if (!Array.isArray(instances)) instances = [instances];\n            if (!instances.length) return Promise.resolve();\n\n            var includeOptions =  _(Utils.cloneDeep(include))\n              .omit(['association'])\n              .defaults({\n                transaction: options.transaction,\n                logging: options.logging,\n                parentRecord: self\n              }).value();\n\n            // Instances will be updated in place so we can safely treat HasOne like a HasMany\n            return Promise.map(instances, function (instance) {\n              if (include.association instanceof BelongsToMany) {\n                return instance.save(includeOptions).then(function () {\n                  var values = {};\n                  values[include.association.foreignKey] = self.get(self.Model.primaryKeyAttribute, {raw: true});\n                  values[include.association.otherKey] = instance.get(instance.Model.primaryKeyAttribute, {raw: true});\n                  // Include values defined in the scope of the association\n                  _.assign(values, include.association.through.scope);\n                  return include.association.throughModel.create(values, includeOptions);\n                });\n              } else {\n                instance.set(include.association.foreignKey, self.get(self.Model.primaryKeyAttribute, {raw: true}));\n                return instance.save(includeOptions);\n              }\n            });\n          });\n        });\n    });\n  });\n};\n\n/*\n* Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object.\n* This is different from doing a `find(Instance.id)`, because that would create and return a new instance. With this method,\n* all references to the Instance are updated with the new data and no new objects are created.\n*\n* @see {Model#find}\n* @param {Object} [options] Options that are passed on to `Model.find`\n* @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n* @return {Promise<this>}\n*/\nInstance.prototype.reload = function(options) {\n  options = _.defaults({}, options, {\n    where: this.where(),\n    include: this.$options.include || null\n  });\n\n  return this.Model.findOne(options).bind(this)\n  .tap(function (reload) {\n    if (!reload) {\n      throw new sequelizeErrors.InstanceError(\n        'Instance could not be reloaded because it does not exist anymore (find call returned null)'\n      );\n    }\n  })\n  .then(function(reload) {\n    // update the internal options of the instance\n    this.$options = reload.$options;\n    // re-set instance values\n    this.set(reload.dataValues, {\n      raw: true,\n      reset: true && !options.attributes\n    });\n  }).return(this);\n};\n\n/*\n * Validate the attribute of this instance according to validation rules set in the model definition.\n *\n * Emits null if and only if validation successful; otherwise an Error instance containing { field name : [error msgs] } entries.\n *\n * @param {Object} [options] Options that are passed to the validator\n * @param {Array} [options.skip] An array of strings. All properties that are in this array will not be validated\n * @see {InstanceValidator}\n *\n * @return {Promise<undefined|Errors.ValidationError>}\n */\nInstance.prototype.validate = function(options) {\n  return new InstanceValidator(this, options).validate();\n};\n\nInstance.prototype.hookValidate = function(options) {\n  return new InstanceValidator(this, options).hookValidate();\n};\n\n/**\n * This is the same as calling `set` and then calling `save` but it only saves the\n * exact values passed to it, making it more atomic and safer.\n *\n * @see {Instance#set}\n * @see {Instance#save}\n * @param {Object} updates See `set`\n * @param {Object} options See `save`\n *\n * @return {Promise<this>}\n * @alias updateAttributes\n */\nInstance.prototype.update = function(values, options) {\n  var changedBefore = this.changed() || []\n    , sideEffects\n    , fields\n    , setOptions;\n\n  options = options || {};\n  if (Array.isArray(options)) options = {fields: options};\n\n  options = Utils.cloneDeep(options);\n  setOptions = Utils.cloneDeep(options);\n  setOptions.attributes = options.fields;\n  this.set(values, setOptions);\n\n  // Now we need to figure out which fields were actually affected by the setter.\n  sideEffects = _.without.apply(this, [this.changed() || []].concat(changedBefore));\n  fields = _.union(Object.keys(values), sideEffects);\n\n  if (!options.fields) {\n    options.fields = _.intersection(fields, this.changed());\n    options.defaultFields = options.fields;\n  }\n\n  return this.save(options);\n};\nInstance.prototype.updateAttributes = Instance.prototype.update;\n\n/**\n * Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.\n *\n * @param {Object}      [options={}]\n * @param {Boolean}     [options.force=false] If set to true, paranoid models will actually be deleted\n * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Transaction} [options.transaction]\n * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise<undefined>}\n */\n\nInstance.prototype.destroy = function(options) {\n  options = Utils._.extend({\n    hooks: true,\n    force: false\n  }, options);\n\n  return Promise.bind(this).then(function() {\n    // Run before hook\n    if (options.hooks) {\n      return this.Model.runHooks('beforeDestroy', this, options);\n    }\n  }).then(function() {\n    var where = this.where();\n\n    if (this.Model._timestampAttributes.deletedAt && options.force === false) {\n      var attribute = this.Model.rawAttributes[this.Model._timestampAttributes.deletedAt]\n        , field = attribute.field || this.Model._timestampAttributes.deletedAt\n        , values = {};\n\n      values[field] = new Date();\n      where[field] = attribute.hasOwnProperty('defaultValue') ? attribute.defaultValue : null;\n\n      this.setDataValue(field, values[field]);\n\n      return this.sequelize.getQueryInterface().update(this, this.$Model.getTableName(options), values, where, _.defaults({ hooks: false }, options));\n    } else {\n      return this.sequelize.getQueryInterface().delete(this, this.$Model.getTableName(options), where, _.assign({ type: QueryTypes.DELETE, limit: null }, options));\n    }\n  }).tap(function() {\n    // Run after hook\n    if (options.hooks) {\n      return this.Model.runHooks('afterDestroy', this, options);\n    }\n  }).then(function(result) {\n    return result;\n  });\n};\n\n/**\n * Restore the row corresponding to this instance. Only available for paranoid models.\n *\n * @param {Object}      [options={}]\n * @param {Function}    [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Transaction} [options.transaction]\n *\n * @return {Promise<undefined>}\n */\nInstance.prototype.restore = function(options) {\n  if (!this.Model._timestampAttributes.deletedAt) throw new Error('Model is not paranoid');\n\n  options = Utils._.extend({\n    hooks: true,\n    force: false\n  }, options);\n\n  return Promise.bind(this).then(function() {\n    // Run before hook\n    if (options.hooks) {\n      return this.Model.runHooks('beforeRestore', this, options);\n    }\n  }).then(function() {\n    var deletedAtCol = this.Model._timestampAttributes.deletedAt\n      , deletedAtAttribute = this.Model.rawAttributes[deletedAtCol]\n      , deletedAtDefaultValue = deletedAtAttribute.hasOwnProperty('defaultValue') ? deletedAtAttribute.defaultValue : null;\n\n    this.setDataValue(deletedAtCol, deletedAtDefaultValue);\n    return this.save(_.extend({}, options, {hooks : false, omitNull : false}));\n  }).tap(function() {\n    // Run after hook\n    if (options.hooks) {\n      return this.Model.runHooks('afterRestore', this, options);\n    }\n  });\n};\n\n/**\n * Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a\n * ```sql\n * SET column = column + X\n * ```\n * query. To get the correct value after an increment into the Instance you should do a reload.\n *\n *```js\n * instance.increment('number') // increment number by 1\n * instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2\n * instance.increment({ answer: 42, tries: 1}, { by: 2 }) // increment answer by 42, and tries by 1.\n *                                                        // `by` is ignored, since each column has its own value\n * ```\n *\n * @see {Instance#reload}\n * @param {String|Array|Object} fields If a string is provided, that column is incremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.\n * @param {Object} [options]\n * @param {Integer} [options.by=1] The number to increment by\n * @param {Boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Transaction} [options.transaction]\n * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise<this>}\n */\nInstance.prototype.increment = function(fields, options) {\n  var identifier = this.where()\n    , updatedAtAttr = this.Model._timestampAttributes.updatedAt\n    , values = {}\n    , where;\n\n  options = _.defaults({}, options, {\n    by: 1,\n    attributes: {},\n    where: {}\n  });\n\n  where = _.extend({}, options.where, identifier);\n\n  if (Utils._.isString(fields)) {\n    values[fields] = options.by;\n  } else if (Utils._.isArray(fields)) {\n    Utils._.each(fields, function(field) {\n      values[field] = options.by;\n    });\n  } else { // Assume fields is key-value pairs\n    values = fields;\n  }\n\n  if (!options.silent && updatedAtAttr && !values[updatedAtAttr]) {\n    options.attributes[updatedAtAttr] = this.Model.$getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);\n  }\n\n  Object.keys(values).forEach(function(attr) {\n    // Field name mapping\n    if (this.Model.rawAttributes[attr] && this.Model.rawAttributes[attr].field && this.Model.rawAttributes[attr].field !== attr) {\n      values[this.Model.rawAttributes[attr].field] = values[attr];\n      delete values[attr];\n    }\n  }, this);\n\n  return this.sequelize.getQueryInterface().increment(this, this.$Model.getTableName(options), values, where, options).return(this);\n};\n\n/**\n * Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a\n * ```sql\n * SET column = column - X\n * ```\n * query. To get the correct value after an decrement into the Instance you should do a reload.\n *\n * ```js\n * instance.decrement('number') // decrement number by 1\n * instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2\n * instance.decrement({ answer: 42, tries: 1}, { by: 2 }) // decrement answer by 42, and tries by 1.\n *                                                        // `by` is ignored, since each column has its own value\n * ```\n *\n * @see {Instance#reload}\n * @param {String|Array|Object} fields If a string is provided, that column is decremented by the value of `by` given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given\n * @param {Object} [options]\n * @param {Integer} [options.by=1] The number to decrement by\n * @param {Boolean} [options.silent=false] If true, the updatedAt timestamp will not be updated.\n * @param {Function} [options.logging=false] A function that gets executed while running the query to log the sql.\n * @param {Transaction} [options.transaction]\n * @param  {String}       [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)\n *\n * @return {Promise}\n */\nInstance.prototype.decrement = function(fields, options) {\n  options = _.defaults({}, options, {\n    by: 1\n  });\n\n  if (!Utils._.isString(fields) && !Utils._.isArray(fields)) { // Assume fields is key-value pairs\n    Utils._.each(fields, function(value, field) {\n      fields[field] = -value;\n    });\n  }\n\n  options.by = 0 - options.by;\n\n  return this.increment(fields, options);\n};\n\n/**\n * Check whether all values of this and `other` Instance are the same\n *\n * @param {Instance} other\n * @return {Boolean}\n */\nInstance.prototype.equals = function(other) {\n  var result = true;\n\n  if (!other || !other.dataValues) {\n    return false;\n  }\n\n  Utils._.each(this.dataValues, function(value, key) {\n    if (Utils._.isDate(value) && Utils._.isDate(other.dataValues[key])) {\n      result = result && (value.getTime() === other.dataValues[key].getTime());\n    } else {\n      result = result && (value === other.dataValues[key]);\n    }\n  });\n\n  return result;\n};\n\n/**\n * Check if this is equal to one of `others` by calling equals\n *\n * @param {Array} others\n * @return {Boolean}\n */\nInstance.prototype.equalsOneOf = function(others) {\n  var self = this;\n\n  return _.some(others, function(other) {\n    return self.equals(other);\n  });\n};\n\nInstance.prototype.setValidators = function(attribute, validators) {\n  this.validators[attribute] = validators;\n};\n\n/**\n * Convert the instance to a JSON representation. Proxies to calling `get` with no keys. This means get all values gotten from the DB, and apply all custom getters.\n *\n * @see {Instance#get}\n * @return {object}\n */\nInstance.prototype.toJSON = function() {\n  return this.get({\n    plain: true\n  });\n};\n\nmodule.exports = Instance;\nmodule.exports.Instance = Instance;\nmodule.exports.default = Instance;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/belongs-to.js":"'use strict';\n\nvar Utils = require('./../utils')\n  , Helpers = require('./helpers')\n  , _ = require('lodash')\n  , Transaction = require('../transaction')\n  , Association = require('./base')\n  , util = require('util');\n\n/**\n * One-to-one association\n *\n * In the API reference below, replace `Assocation` with the actual name of your association, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @mixin BelongsTo\n */\nvar BelongsTo = function(source, target, options) {\n  Association.call(this);\n\n  this.associationType = 'BelongsTo';\n  this.source = source;\n  this.target = target;\n  this.options = options;\n  this.scope = options.scope;\n  this.isSingleAssociation = true;\n  this.isSelfAssociation = (this.source === this.target);\n  this.as = this.options.as;\n  this.foreignKeyAttribute = {};\n\n  if (this.as) {\n    this.isAliased = true;\n    this.options.name = {\n      singular: this.as\n    };\n  } else {\n    this.as = this.target.options.name.singular;\n    this.options.name = this.target.options.name;\n  }\n\n  if (_.isObject(this.options.foreignKey)) {\n    this.foreignKeyAttribute = this.options.foreignKey;\n    this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n  } else if (this.options.foreignKey) {\n    this.foreignKey = this.options.foreignKey;\n  }\n\n  if (!this.foreignKey) {\n    this.foreignKey = Utils.camelizeIf(\n      [\n        Utils.underscoredIf(this.as, this.source.options.underscored),\n        this.target.primaryKeyAttribute\n      ].join('_'),\n      !this.source.options.underscored\n    );\n  }\n\n  this.identifier = this.foreignKey;\n\n  if (this.source.rawAttributes[this.identifier]) {\n    this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n  }\n\n  this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n  this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n  this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n\n  this.targetIdentifier = this.targetKey;\n  this.associationAccessor = this.as;\n  this.options.useHooks = options.useHooks;\n\n  // Get singular name, trying to uppercase the first letter, unless the model forbids it\n  var singular = Utils.uppercaseFirst(this.options.name.singular);\n\n  this.accessors = {\n    /**\n     * Get the associated instance.\n     *\n     * @param {Object} [options]\n     * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false.\n     * @param {String} [options.schema] Apply a schema on the related model\n     * @return {Promise<Instance>}\n     * @method getAssociation\n     */\n    get: 'get' + singular,\n    /**\n     * Set the associated model.\n     *\n     * @param {Instance|String|Number} [newAssociation] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n     * @param {Object} [options] Options passed to `this.save`\n     * @param {Boolean} [options.save=true] Skip saving this after setting the foreign key if false.\n     * @return {Promise}\n     * @method setAssociation\n     */\n    set: 'set' + singular,\n    /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Object} [values]\n     * @param {Object} [options] Options passed to `target.create` and setAssociation.\n     * @return {Promise}\n     * @method createAssociation\n     */\n    create: 'create' + singular\n  };\n};\n\nutil.inherits(BelongsTo, Association);\n\n// the id is in the source table\nBelongsTo.prototype.injectAttributes = function() {\n  var newAttributes = {};\n\n  newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n    type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n    allowNull : true\n  });\n\n  if (this.options.constraints !== false) {\n    var source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n    this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');\n    this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n  }\n\n  Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n  Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n\n  this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n  this.source.refreshAttributes();\n\n  Helpers.checkNamingCollision(this);\n\n  return this;\n};\n\nBelongsTo.prototype.mixin = function(obj) {\n  var association = this;\n\n  obj[this.accessors.get] = function(options) {\n    return association.get(this, options);\n  };\n\n  association.injectSetter(obj);\n  association.injectCreator(obj);\n};\n\nBelongsTo.prototype.get = function(instances, options) {\n  var association = this\n    , Target = association.target\n    , instance\n    , where = {};\n\n  options = Utils.cloneDeep(options);\n\n  if (options.hasOwnProperty('scope')) {\n    if (!options.scope) {\n      Target = Target.unscoped();\n    } else {\n      Target = Target.scope(options.scope);\n    }\n  }\n\n  if (options.hasOwnProperty('schema')) {\n    Target = Target.schema(options.schema, options.schemaDelimiter);\n  }\n\n  if (!Array.isArray(instances)) {\n    instance = instances;\n    instances = undefined;\n  }\n\n  if (instances) {\n    where[association.targetKey] = {\n      $in: instances.map(function (instance) {\n        return instance.get(association.foreignKey);\n      })\n    };\n  } else {\n    if (association.targetKeyIsPrimary && !options.where) {\n      return Target.findById(instance.get(association.foreignKey), options);\n    } else {\n      where[association.targetKey] = instance.get(association.foreignKey);\n      options.limit = null;\n    }\n  }\n\n  options.where = options.where ?\n                  {$and: [where, options.where]} :\n                  where;\n\n  if (instances) {\n    return Target.findAll(options).then(function (results) {\n      var result = {};\n      instances.forEach(function (instance) {\n        result[instance.get(association.foreignKey, {raw: true})] = null;\n      });\n\n      results.forEach(function (instance) {\n        result[instance.get(association.targetKey, {raw: true})] = instance;\n      });\n\n      return result;\n    });\n  }\n  return Target.findOne(options);\n};\n\n// Add setAssociaton method to the prototype of the model instance\nBelongsTo.prototype.injectSetter = function(instancePrototype) {\n  var association = this;\n\n  instancePrototype[this.accessors.set] = function(associatedInstance, options) {\n    options = options || {};\n\n    var value = associatedInstance;\n    if (associatedInstance instanceof association.target.Instance) {\n      value = associatedInstance[association.targetKey];\n    }\n\n    this.set(association.foreignKey, value);\n\n    if (options.save === false) return;\n\n    options = _.extend({\n      fields: [association.foreignKey],\n      allowNull: [association.foreignKey],\n      association: true\n    }, options);\n\n\n    // passes the changed field to save, so only that field get updated.\n    return this.save(options);\n  };\n\n  return this;\n};\n\n// Add createAssociation method to the prototype of the model instance\nBelongsTo.prototype.injectCreator = function(instancePrototype) {\n  var association = this;\n\n  instancePrototype[this.accessors.create] = function(values, fieldsOrOptions) {\n    var instance = this\n      , options = {};\n\n    if ((fieldsOrOptions || {}).transaction instanceof Transaction) {\n      options.transaction = fieldsOrOptions.transaction;\n    }\n    options.logging = (fieldsOrOptions || {}).logging;\n\n    return association.target.create(values, fieldsOrOptions).then(function(newAssociatedObject) {\n      return instance[association.accessors.set](newAssociatedObject, options);\n    });\n  };\n\n  return this;\n};\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/helpers.js":"'use strict';\n\nvar Utils = require('./../utils');\n\nfunction checkNamingCollision (association) {\n  if (association.source.rawAttributes.hasOwnProperty(association.as)) {\n    throw new Error(\n      'Naming collision between attribute \\'' + association.as +\n      '\\' and association \\'' + association.as + '\\' on model ' + association.source.name +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\n\nfunction addForeignKeyConstraints (newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behaviour\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n\n    // Find primary keys: composite keys not supported with this approach\n    var primaryKeys = Utils._.chain(source.rawAttributes).keys()\n      .filter(function($key) { return source.rawAttributes[$key].primaryKey; })\n      .map(function($key) { return source.rawAttributes[$key].field || $key; }).value();\n\n    if (primaryKeys.length === 1) {\n      if (!!source.$schema) {\n        newAttribute.references = {\n          model: source.modelManager.sequelize.queryInterface.QueryGenerator.addSchema({\n            tableName: source.tableName,\n            $schema: source.$schema,\n            $schemaDelimiter: source.$schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = { model: source.tableName };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\n\nmodule.exports = {\n  checkNamingCollision: checkNamingCollision,\n  addForeignKeyConstraints: addForeignKeyConstraints\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/transaction.js":"'use strict';\n\nvar Utils = require('./utils');\n\n/**\n * The transaction object is used to identify a running transaction. It is created by calling `Sequelize.transaction()`.\n *\n * To run a query under a transaction, you should pass the transaction in the options object.\n * @class Transaction\n * @constructor\n *\n * @param {Sequelize} sequelize A configured sequelize Instance\n * @param {Object} options An object with options\n * @param {Boolean} options.autocommit=true Sets the autocommit property of the transaction.\n * @param {String} options.type=true Sets the type of the transaction.\n * @param {String} options.isolationLevel=true Sets the isolation level of the transaction.\n * @param {String} options.deferrable Sets the constraints to be deferred or immediately checked.\n * @param {String} options.readOnly=false Sets the read-only property of the transaction. Such transactions\n *   will use read replicas when available\n */\nfunction Transaction(sequelize, options) {\n  this.sequelize = sequelize;\n  this.savepoints = [];\n  var generateTransactionId = this.sequelize.dialect.QueryGenerator.generateTransactionId;\n\n  this.options = Utils._.extend({\n    autocommit: true,\n    type: sequelize.options.transactionType,\n    isolationLevel: sequelize.options.isolationLevel,\n    readOnly: false\n  }, options || {});\n\n  this.parent = this.options.transaction;\n  this.id = this.parent ? this.parent.id : generateTransactionId();\n\n  if (this.parent) {\n    this.id = this.parent.id;\n    this.parent.savepoints.push(this);\n    this.name = this.id + '-savepoint-' + this.parent.savepoints.length;\n  } else {\n    this.id = this.name = generateTransactionId();\n  }\n\n  delete this.options.transaction;\n}\n\n/**\n * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n * Sqlite only.\n *\n * The possible types to use when starting a transaction:\n *\n * ```js\n * {\n *   DEFERRED: \"DEFERRED\",\n *   IMMEDIATE: \"IMMEDIATE\",\n *   EXCLUSIVE: \"EXCLUSIVE\"\n * }\n * ```\n *\n * Pass in the desired level as the first argument:\n *\n * ```js\n * return sequelize.transaction({\n *   type: Sequelize.Transaction.EXCLUSIVE\n * }, function (t) {\n *\n *  // your transactions\n *\n * }).then(function(result) {\n *   // transaction has been committed. Do something after the commit if required.\n * }).catch(function(err) {\n *   // do something with the err.\n * });\n * ```\n *\n * @property TYPES\n */\nTransaction.TYPES = {\n  DEFERRED: 'DEFERRED',\n  IMMEDIATE: 'IMMEDIATE',\n  EXCLUSIVE: 'EXCLUSIVE'\n};\n\n\n/**\n * Isolations levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n * Default to `REPEATABLE_READ` but you can override the default isolation level by passing `options.isolationLevel` in `new Sequelize`.\n *\n * The possible isolations levels to use when starting a transaction:\n *\n * ```js\n * {\n *   READ_UNCOMMITTED: \"READ UNCOMMITTED\",\n *   READ_COMMITTED: \"READ COMMITTED\",\n *   REPEATABLE_READ: \"REPEATABLE READ\",\n *   SERIALIZABLE: \"SERIALIZABLE\"\n * }\n * ```\n *\n * Pass in the desired level as the first argument:\n *\n * ```js\n * return sequelize.transaction({\n *   isolationLevel: Sequelize.Transaction.SERIALIZABLE\n * }, function (t) {\n *\n *  // your transactions\n *\n * }).then(function(result) {\n *   // transaction has been committed. Do something after the commit if required.\n * }).catch(function(err) {\n *   // do something with the err.\n * });\n * ```\n *\n * @property ISOLATION_LEVELS\n */\nTransaction.ISOLATION_LEVELS = {\n  READ_UNCOMMITTED: 'READ UNCOMMITTED',\n  READ_COMMITTED: 'READ COMMITTED',\n  REPEATABLE_READ: 'REPEATABLE READ',\n  SERIALIZABLE: 'SERIALIZABLE'\n};\n\n/**\n * Possible options for row locking. Used in conjunction with `find` calls:\n *\n * ```js\n * t1 // is a transaction\n * t1.LOCK.UPDATE,\n * t1.LOCK.SHARE,\n * t1.LOCK.KEY_SHARE, // Postgres 9.3+ only\n * t1.LOCK.NO_KEY_UPDATE // Postgres 9.3+ only\n * ```\n *\n * Usage:\n * ```js\n * t1 // is a transaction\n * Model.findAll({\n *   where: ...,\n *   transaction: t1,\n *   lock: t1.LOCK...\n * });\n * ```\n *\n * Postgres also supports specific locks while eager loading by using OF:\n * ```js\n * UserModel.findAll({\n *   where: ...,\n *   include: [TaskModel, ...],\n *   transaction: t1,\n *   lock: {\n *     level: t1.LOCK...,\n *     of: UserModel\n *   }\n * });\n * ```\n * UserModel will be locked but TaskModel won't!\n *\n * @property LOCK\n */\nTransaction.LOCK = Transaction.prototype.LOCK = {\n  UPDATE: 'UPDATE',\n  SHARE: 'SHARE',\n  KEY_SHARE: 'KEY SHARE',\n  NO_KEY_UPDATE: 'NO KEY UPDATE'\n};\n\n/**\n * Commit the transaction\n *\n * @return {Promise}\n */\nTransaction.prototype.commit = function() {\n  var self = this;\n\n  if (this.finished) {\n    throw new Error('Transaction cannot be committed because it has been finished with state: ' + self.finished);\n  }\n\n  this.$clearCls();\n\n  return this\n    .sequelize\n    .getQueryInterface()\n    .commitTransaction(this, this.options)\n    .finally(function() {\n      self.finished = 'commit';\n      if (!self.parent) {\n        return self.cleanup();\n      }\n      return null;\n    });\n};\n\n\n/**\n * Rollback (abort) the transaction\n *\n * @return {Promise}\n */\nTransaction.prototype.rollback = function() {\n  var self = this;\n\n  if (this.finished) {\n    throw new Error('Transaction cannot be rolled back because it has been finished with state: ' + self.finished);\n  }\n\n  this.$clearCls();\n\n  return this\n    .sequelize\n    .getQueryInterface()\n    .rollbackTransaction(this, this.options)\n    .finally(function() {\n      if (!self.parent) {\n        return self.cleanup();\n      }\n      return self;\n    });\n};\n\nTransaction.prototype.prepareEnvironment = function() {\n  var self = this;\n  var connectionPromise;\n\n  if (this.parent) {\n    connectionPromise = Utils.Promise.resolve(this.parent.connection);\n  } else {\n    var acquireOptions = {uuid: this.id};\n\n    if (this.options.readOnly) {\n      acquireOptions.type = 'SELECT';\n    }\n\n    connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n  }\n\n  return connectionPromise\n  .then(function (connection) {\n    self.connection = connection;\n    self.connection.uuid = self.id;\n  }).then(function () {\n    return self.begin();\n  }).then(function () {\n    return self.setDeferrable();\n  }).then(function () {\n    return self.setIsolationLevel();\n  }).then(function () {\n    return self.setAutocommit();\n  }).catch(function (setupErr) {\n    return self.rollback().finally(function () {\n      throw setupErr;\n    });\n  }).tap(function () {\n    if (self.sequelize.constructor.cls) {\n      self.sequelize.constructor.cls.set('transaction', self);\n    }\n    return null;\n  });\n};\n\nTransaction.prototype.begin = function() {\n  return this\n    .sequelize\n    .getQueryInterface()\n    .startTransaction(this, this.options);\n};\n\nTransaction.prototype.setDeferrable = function () {\n  if (this.options.deferrable) {\n    return this\n      .sequelize\n      .getQueryInterface()\n      .deferConstraints(this, this.options);\n  }\n};\n\nTransaction.prototype.setAutocommit = function() {\n  return this\n    .sequelize\n    .getQueryInterface()\n    .setAutocommit(this, this.options.autocommit, this.options);\n};\n\nTransaction.prototype.setIsolationLevel = function() {\n  return this\n    .sequelize\n    .getQueryInterface()\n    .setIsolationLevel(this, this.options.isolationLevel, this.options);\n};\n\nTransaction.prototype.cleanup = function() {\n  var res = this.sequelize.connectionManager.releaseConnection(this.connection);\n  this.connection.uuid = undefined;\n  return res;\n};\n\nTransaction.prototype.$clearCls = function () {\n  var cls = this.sequelize.constructor.cls;\n\n  if (cls) {\n    if (cls.get('transaction') === this) {\n      cls.set('transaction', null);\n    }\n  }\n};\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/base.js":"'use strict';\n\nvar Association = function() {};\n\n// Normalize input - may be array or single obj, instance or primary key - convert it to an array of built objects\nAssociation.prototype.toInstanceArray = function (objs) {\n  if (!Array.isArray(objs)) {\n    objs = [objs];\n  }\n  return objs.map(function(obj) {\n    if (!(obj instanceof this.target.Instance)) {\n      var tmpInstance = {};\n      tmpInstance[this.target.primaryKeyAttribute] = obj;\n      return this.target.build(tmpInstance, {\n        isNewRecord: false\n      });\n    }\n    return obj;\n  }, this);\n};\n\nAssociation.prototype.inspect = function() {\n  return this.as;\n};\n\nmodule.exports = Association;\nmodule.exports.Association = Association;\nmodule.exports.default = Association;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/belongs-to-many.js":"'use strict';\n\nvar Utils = require('./../utils')\n  , Helpers = require('./helpers')\n  , _ = require('lodash')\n  , Association = require('./base')\n  , BelongsTo = require('./belongs-to')\n  , HasMany = require('./has-many')\n  , HasOne = require('./has-one')\n  , CounterCache = require('../plugins/counter-cache')\n  , util = require('util');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { role: 'manager', transaction: t });\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(function (project) {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * In the API reference below, replace `Assocation(s)` with the actual name of your association, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @mixin BelongsToMany\n */\nvar BelongsToMany = function(source, target, options) {\n  Association.call(this);\n\n  options = options || {};\n\n  if (options.through === undefined || options.through === true || options.through === null) {\n    throw new Error('belongsToMany must be given a through option, either a string or a model');\n  }\n\n  if (!options.through.model) {\n    options.through = {\n      model: options.through\n    };\n  }\n\n  this.associationType = 'BelongsToMany';\n  this.source = source;\n  this.target = target;\n  this.targetAssociation = null;\n  this.options = options;\n  this.sequelize = source.modelManager.sequelize;\n  this.through = _.assign({}, options.through);\n  this.scope = options.scope;\n  this.isMultiAssociation = true;\n  this.isSelfAssociation = this.source === this.target;\n  this.doubleLinked = false;\n  this.as = this.options.as;\n\n  if (!this.as && this.isSelfAssociation) {\n    throw new Error('\\'as\\' must be defined for many-to-many self-associations');\n  }\n\n  if (this.as) {\n    this.isAliased = true;\n\n    if (Utils._.isPlainObject(this.as)) {\n      this.options.name = this.as;\n      this.as = this.as.plural;\n    } else {\n      this.options.name = {\n        plural: this.as,\n        singular: Utils.singularize(this.as)\n      };\n    }\n  } else {\n    this.as = this.target.options.name.plural;\n    this.options.name = this.target.options.name;\n  }\n\n  this.combinedTableName = Utils.combineTableNames(\n    this.source.tableName,\n    this.isSelfAssociation ? (this.as || this.target.tableName) : this.target.tableName\n  );\n\n  /*\n   * If self association, this is the target association - Unless we find a pairing association\n   */\n  if (this.isSelfAssociation) {\n    this.targetAssociation = this;\n  }\n\n  /*\n   * Default/generated foreign/other keys\n   */\n  if (_.isObject(this.options.foreignKey)) {\n    this.foreignKeyAttribute = this.options.foreignKey;\n    this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n  } else {\n    if (!this.options.foreignKey) {\n      this.foreignKeyDefault = true;\n    }\n\n    this.foreignKeyAttribute = {};\n    this.foreignKey = this.options.foreignKey || Utils.camelizeIf(\n      [\n        Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored),\n        this.source.primaryKeyAttribute\n      ].join('_'),\n      !this.source.options.underscored\n    );\n  }\n\n  if (_.isObject(this.options.otherKey)) {\n    this.otherKeyAttribute = this.options.otherKey;\n    this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n  } else {\n    if (!this.options.otherKey) {\n      this.otherKeyDefault = true;\n    }\n\n    this.otherKeyAttribute = {};\n    this.otherKey = this.options.otherKey || Utils.camelizeIf(\n      [\n        Utils.underscoredIf(\n          this.isSelfAssociation ?\n            Utils.singularize(this.as) :\n            this.target.options.name.singular,\n          this.target.options.underscored\n        ),\n        this.target.primaryKeyAttribute\n      ].join('_'),\n      !this.target.options.underscored\n    );\n  }\n\n  /*\n   * Find paired association (if exists)\n   */\n  _.each(this.target.associations, function(association) {\n    if (association.associationType !== 'BelongsToMany') return;\n    if (association.target !== this.source) return;\n\n    if (this.options.through.model === association.options.through.model) {\n      this.paired = association;\n      association.paired = this;\n    }\n  }.bind(this));\n\n  if (typeof this.through.model === 'string') {\n    if (!this.sequelize.isDefined(this.through.model)) {\n      this.through.model = this.sequelize.define(this.through.model, {}, _.extend(this.options, {\n        tableName: this.through.model,\n        indexes: [], //we don't want indexes here (as referenced in #2416)\n        paranoid: false,  // A paranoid join table does not make sense\n        validate: {} // Don't propagate model-level validations\n      }));\n    } else {\n      this.through.model = this.sequelize.model(this.through.model);\n    }\n  }\n\n  this.options = _.assign(this.options, _.pick(this.through.model.options, [\n    'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n  ]));\n\n  if (this.paired) {\n    if (this.otherKeyDefault) {\n      this.otherKey = this.paired.foreignKey;\n    }\n    if (this.paired.otherKeyDefault) {\n      // If paired otherKey was inferred we should make sure to clean it up before adding a new one that matches the foreignKey\n      if (this.paired.otherKey !== this.foreignKey) {\n        delete this.through.model.rawAttributes[this.paired.otherKey];\n      }\n      this.paired.otherKey = this.foreignKey;\n      this.paired.foreignIdentifier = this.foreignKey;\n      delete this.paired.foreignIdentifierField;\n    }\n  }\n\n  if (this.through) {\n    this.throughModel = this.through.model;\n  }\n\n  this.options.tableName = this.combinedName = (this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model);\n\n  this.associationAccessor = this.as;\n\n  // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n  var plural = Utils.uppercaseFirst(this.options.name.plural)\n    , singular = Utils.uppercaseFirst(this.options.name.singular);\n\n  this.accessors = {\n    /**\n     * Get everything currently associated with this, using an optional where clause.\n     *\n     * @param {Object} [options]\n     * @param {Object} [options.where] An optional where clause to limit the associated models\n     * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @param {String} [options.schema] Apply a schema on the related model\n     * @return {Promise<Array<Instance>>}\n     * @method getAssociations\n     */\n    get: 'get' + plural,\n    /**\n     * Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated.\n     *\n     * @param {Array<Instance|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n     * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`. Can also hold additional attributes for the join table\n     * @param {Object} [options.validate] Run validation for the join model\n     * @return {Promise}\n     * @method setAssociations\n     */\n    set: 'set' + plural,\n    /**\n     * Associate several persisted instances with this.\n     *\n     * @param {Array<Instance|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this.\n     * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`. Can also hold additional attributes for the join table.\n     * @param {Object} [options.validate] Run validation for the join model.\n     * @return {Promise}\n     * @method addAssociations\n     */\n    addMultiple: 'add' + plural,\n    /**\n     * Associate a persisted instance with this.\n     *\n     * @param {Instance|String|Number} [newAssociation] A persisted instance or primary key of instance to associate with this.\n     * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`. Can also hold additional attributes for the join table.\n     * @param {Object} [options.validate] Run validation for the join model.\n     * @return {Promise}\n     * @method addAssociation\n     */\n    add: 'add' + singular,\n     /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Object} [values]\n     * @param {Object} [options] Options passed to create and add. Can also hold additional attributes for the join table\n     * @return {Promise}\n     * @method createAssociation\n     */\n    create: 'create' + singular,\n    /**\n     * Un-associate the instance.\n     *\n     * @param {Instance|String|Number} [oldAssociated] Can be an Instance or its primary key\n     * @param {Object} [options] Options passed to `through.destroy`\n     * @return {Promise}\n     * @method removeAssociation\n     */\n    remove: 'remove' + singular,\n    /**\n     * Un-associate several instances.\n     *\n     * @param {Array<Instance|String|Number>} [oldAssociated] Can be an array of instances or their primary keys\n     * @param {Object} [options] Options passed to `through.destroy`\n     * @return {Promise}\n     * @method removeAssociations\n     */\n    removeMultiple: 'remove' + plural,\n    /**\n     * Check if an instance is associated with this.\n     *\n     * @param {Instance|String|Number} [instance] Can be an Instance or its primary key\n     * @param {Object} [options] Options passed to getAssociations\n     * @return {Promise}\n     * @method hasAssociation\n     */\n    hasSingle: 'has' + singular,\n    /**\n     * Check if all instances are associated with this.\n     *\n     * @param {Array<Instance|String|Number>} [instances] Can be an array of instances or their primary keys\n     * @param {Object} [options] Options passed to getAssociations\n     * @return {Promise}\n     * @method hasAssociations\n     */\n    hasAll: 'has' + plural,\n    /**\n     * Count everything currently associated with this, using an optional where clause.\n     *\n     * @param {Object} [options]\n     * @param {Object} [options.where] An optional where clause to limit the associated models\n     * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @return {Promise<Int>}\n     * @method countAssociations\n     */\n    count: 'count' + plural\n  };\n\n  if (this.options.counterCache) {\n    new CounterCache(this, this.options.counterCache !== true ? this.options.counterCache : {});\n  }\n};\n\nutil.inherits(BelongsToMany, Association);\n\n// the id is in the target table\n// or in an extra table which connects two tables\nBelongsToMany.prototype.injectAttributes = function() {\n  var self = this;\n\n  this.identifier = this.foreignKey;\n  this.foreignIdentifier = this.otherKey;\n\n  // remove any PKs previously defined by sequelize\n  // but ignore any keys that are part of this association (#5865)\n  _.each(this.through.model.rawAttributes, function(attribute, attributeName) {\n    if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n      if (attributeName === self.foreignKey || attributeName === self.otherKey) {\n        // this key is still needed as it's part of the association\n        // so just set primaryKey to false\n        attribute.primaryKey = false;\n      }\n      else {\n        delete self.through.model.rawAttributes[attributeName];\n      }\n      self.primaryKeyDeleted = true;\n    }\n  });\n\n  var sourceKey = this.source.rawAttributes[this.source.primaryKeyAttribute]\n    , sourceKeyType = sourceKey.type\n    , sourceKeyField = sourceKey.field || this.source.primaryKeyAttribute\n    , targetKey = this.target.rawAttributes[this.target.primaryKeyAttribute]\n    , targetKeyType = targetKey.type\n    , targetKeyField = targetKey.field || this.target.primaryKeyAttribute\n    , sourceAttribute = _.defaults({}, this.foreignKeyAttribute, { type: sourceKeyType })\n    , targetAttribute = _.defaults({}, this.otherKeyAttribute, { type: targetKeyType });\n\n  if (this.primaryKeyDeleted === true) {\n    targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n  } else if (this.through.unique !== false) {\n    var uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n    targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n  }\n\n  if (!this.through.model.rawAttributes[this.foreignKey]) {\n    this.through.model.rawAttributes[this.foreignKey] = {\n      _autoGenerated: true\n    };\n  }\n\n  if (!this.through.model.rawAttributes[this.otherKey]) {\n    this.through.model.rawAttributes[this.otherKey] = {\n      _autoGenerated: true\n    };\n  }\n\n  if (this.options.constraints !== false) {\n    sourceAttribute.references = {\n      model: this.source.getTableName(),\n      key:   sourceKeyField\n    };\n    // For the source attribute the passed option is the priority\n    sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n    sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n    if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n    if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n    targetAttribute.references = {\n      model: this.target.getTableName(),\n      key:   targetKeyField\n    };\n    // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n    targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n    targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n    if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n    if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n  }\n\n  this.through.model.rawAttributes[this.foreignKey] = _.extend(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n  this.through.model.rawAttributes[this.otherKey] = _.extend(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n  this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n  this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n  if (this.paired && !this.paired.foreignIdentifierField) {\n    this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n  }\n\n  this.through.model.refreshAttributes();\n\n  this.toSource = new BelongsTo(this.through.model, this.source, {\n    foreignKey: this.foreignKey\n  });\n  this.manyFromSource = new HasMany(this.source, this.through.model, {\n    foreignKey: this.foreignKey\n  });\n  this.oneFromSource = new HasOne(this.source, this.through.model, {\n    foreignKey: this.foreignKey,\n    as: this.through.model.name\n  });\n\n  this.toTarget = new BelongsTo(this.through.model, this.target, {\n    foreignKey: this.otherKey\n  });\n  this.manyFromTarget = new HasMany(this.target, this.through.model, {\n    foreignKey: this.otherKey\n  });\n  this.oneFromTarget = new HasOne(this.target, this.through.model, {\n    foreignKey: this.otherKey,\n    as: this.through.model.name\n  });\n\n  if (this.paired && this.paired.otherKeyDefault) {\n    this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n      foreignKey: this.paired.otherKey\n    });\n\n    this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n      foreignKey: this.paired.otherKey,\n      as: this.paired.through.model.name\n    });\n  }\n\n  Helpers.checkNamingCollision(this);\n\n  return this;\n};\n\nBelongsToMany.prototype.get = function(instance, options) {\n  options = Utils.cloneDeep(options) || {};\n\n  var association = this\n    , through = association.through\n    , scopeWhere\n    , throughWhere;\n\n  if (association.scope) {\n    scopeWhere = _.clone(association.scope);\n  }\n\n  options.where = {\n    $and: [\n      scopeWhere,\n      options.where\n    ]\n  };\n\n  if (Object(through.model) === through.model) {\n    throughWhere = {};\n    throughWhere[association.foreignKey] = instance.get(association.source.primaryKeyAttribute);\n\n    if (through.scope) {\n      _.assign(throughWhere, through.scope);\n    }\n\n    //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n    if (options.through && options.through.where) {\n      throughWhere = {\n        $and: [throughWhere, options.through.where]\n      };\n    }\n\n    options.include = options.include || [];\n    options.include.push({\n      association: association.oneFromTarget,\n      attributes: options.joinTableAttributes,\n      required: true,\n      where: throughWhere\n    });\n  }\n\n  var model = association.target;\n  if (options.hasOwnProperty('scope')) {\n    if (!options.scope) {\n      model = model.unscoped();\n    } else {\n      model = model.scope(options.scope);\n    }\n  }\n\n  if (options.hasOwnProperty('schema')) {\n    model = model.schema(options.schema, options.schemaDelimiter);\n  }\n\n  return model.findAll(options);\n};\n\nBelongsToMany.prototype.injectGetter = function(obj) {\n  var association = this;\n\n  obj[this.accessors.get] = function(options) {\n    return association.get(this, options);\n  };\n\n  obj[this.accessors.count] = function(options) {\n    var model = association.target\n      , sequelize = model.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([association.target.name, model.primaryKeyAttribute].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    return obj[association.accessors.get].call(this, options).then(function (result) {\n      return parseInt(result.count, 10);\n    });\n  };\n\n  obj[this.accessors.hasSingle] = obj[this.accessors.hasAll] = function(instances, options) {\n    var where = {};\n\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = _.assign({\n      raw: true\n    }, options, {\n      scope: false\n    });\n\n    where.$or = instances.map(function (instance) {\n      if (instance instanceof association.target.Instance) {\n        return instance.where();\n      } else {\n        var $where = {};\n        $where[association.target.primaryKeyAttribute] = instance;\n        return $where;\n      }\n    });\n\n    options.where = {\n      $and: [\n        where,\n        options.where\n      ]\n    };\n\n    return this[association.accessors.get](options).then(function(associatedObjects) {\n      return associatedObjects.length === instances.length;\n    });\n  };\n\n  return this;\n};\n\nBelongsToMany.prototype.injectSetter = function(obj) {\n  var association = this;\n\n  obj[this.accessors.set] = function(newAssociatedObjects, options) {\n    options = options || {};\n    var instance = this\n      , sourceKey = association.source.primaryKeyAttribute\n      , targetKey = association.target.primaryKeyAttribute\n      , identifier = association.identifier\n      , foreignIdentifier = association.foreignIdentifier\n      , where = {};\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = association.toInstanceArray(newAssociatedObjects);\n    }\n\n    where[identifier] = this.get(sourceKey);\n    _.assign(where, association.through.scope);\n    \n    return association.through.model.findAll(_.defaults({\n      where: where,\n      raw: true,\n    }, options)).then(function (currentRows) {\n      var obsoleteAssociations = []\n        , defaultAttributes = options\n        , promises = []\n        , unassociatedObjects;\n\n      // Don't try to insert the transaction as an attribute in the through table\n      defaultAttributes = _.omit(defaultAttributes, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging']);\n\n      unassociatedObjects = newAssociatedObjects.filter(function(obj) {\n        return !_.find(currentRows, function(currentRow) {\n          return currentRow[foreignIdentifier] === obj.get(targetKey);\n        });\n      });\n\n      currentRows.forEach(function(currentRow) {\n        var newObj = _.find(newAssociatedObjects, function(obj) {\n          return currentRow[foreignIdentifier] === obj.get(targetKey);\n        });\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          var throughAttributes = newObj[association.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof association.through.model.Instance) {\n            throughAttributes = {};\n          }\n\n          var where = {}\n            , attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          where[identifier] = instance.get(sourceKey);\n          where[foreignIdentifier] = newObj.get(targetKey);\n\n          if (Object.keys(attributes).length) {\n            promises.push(association.through.model.update(attributes, _.extend(options, {\n              where: where\n            })));\n          }\n        }\n      });\n\n      if (obsoleteAssociations.length > 0) {\n        var where = {};\n        where[identifier] = instance.get(sourceKey);\n        where[foreignIdentifier] = obsoleteAssociations.map(function(obsoleteAssociation) {\n          return obsoleteAssociation[foreignIdentifier];\n        });\n\n        promises.push(association.through.model.destroy(_.defaults({\n          where: where\n        }, options)));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        var bulk = unassociatedObjects.map(function(unassociatedObject) {\n          var attributes = {};\n\n          attributes[identifier] = instance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          attributes = _.defaults(attributes, unassociatedObject[association.through.model.name], defaultAttributes);\n\n          _.assign(attributes, association.through.scope);\n\n          return attributes;\n        }.bind(this));\n\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({ validate: true }, options)));\n      }\n\n      return Utils.Promise.all(promises);\n    });\n  };\n\n  obj[this.accessors.addMultiple] = obj[this.accessors.add] = function(newInstances, additionalAttributes) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Utils.Promise.resolve();\n\n    additionalAttributes = _.clone(additionalAttributes) || {};\n\n    var instance = this\n      , defaultAttributes = _.omit(additionalAttributes, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging'])\n      , sourceKey = association.source.primaryKeyAttribute\n      , targetKey = association.target.primaryKeyAttribute\n      , identifier = association.identifier\n      , foreignIdentifier = association.foreignIdentifier\n      , options = additionalAttributes;\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    var where = {};\n    where[identifier] = instance.get(sourceKey);\n    where[foreignIdentifier] = newInstances.map(function (newInstance) { return newInstance.get(targetKey); });\n\n    _.assign(where, association.through.scope);\n\n    return association.through.model.findAll(_.defaults({\n      where: where,\n      raw: true,\n    }, options)).then(function (currentRows) {\n      var promises = [];\n\n      var unassociatedObjects = [], changedAssociations = [];\n      newInstances.forEach(function(obj) {\n        var existingAssociation = _.find(currentRows, function(current) {\n          return current[foreignIdentifier] === obj.get(targetKey);\n        });\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          var throughAttributes = obj[association.through.model.name]\n            , attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (_.some(Object.keys(attributes), function (attribute) {\n            return attributes[attribute] !== existingAssociation[attribute];\n          })) {\n            changedAssociations.push(obj);\n          }\n        }\n      });\n\n      if (unassociatedObjects.length > 0) {\n        var bulk = unassociatedObjects.map(function(unassociatedObject) {\n          var throughAttributes = unassociatedObject[association.through.model.name]\n            , attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          attributes[identifier] = instance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          _.assign(attributes, association.through.scope);\n\n          return attributes;\n        }.bind(this));\n\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({ validate: true }, options)));\n      }\n\n      changedAssociations.forEach(function(assoc) {\n        var throughAttributes = assoc[association.through.model.name]\n          , attributes = _.defaults({}, throughAttributes, defaultAttributes)\n          , where = {};\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model.Instance) {\n          throughAttributes = {};\n        }\n\n        where[identifier] = instance.get(sourceKey);\n        where[foreignIdentifier] = assoc.get(targetKey);\n\n        promises.push(association.through.model.update(attributes, _.extend(options, {\n          where: where\n        })));\n      });\n\n      return Utils.Promise.all(promises);\n    });\n  };\n\n  obj[this.accessors.removeMultiple] = obj[this.accessors.remove] = function(oldAssociatedObjects, options) {\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    var where = {};\n    where[association.identifier] = this.get(association.source.primaryKeyAttribute);\n    where[association.foreignIdentifier] = oldAssociatedObjects.map(function (newInstance) { return newInstance.get(association.target.primaryKeyAttribute); });\n\n    return association.through.model.destroy(_.defaults({\n      where: where\n    }, options));\n  };\n\n  return this;\n};\n\nBelongsToMany.prototype.injectCreator = function(obj) {\n  var association = this;\n\n  obj[this.accessors.create] = function(values, options) {\n    var instance = this;\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      _.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    return association.target.create(values, options).then(function(newAssociatedObject) {\n      return instance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject);\n    });\n  };\n\n  return this;\n};\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/has-many.js":"'use strict';\n\nvar Utils = require('./../utils')\n  , Helpers = require('./helpers')\n  , _ = require('lodash')\n  , Association = require('./base')\n  , CounterCache = require('../plugins/counter-cache')\n  , util = require('util');\n\n/**\n * One-to-many association\n *\n * In the API reference below, replace `Association(s)` with the actual name of your association, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n *\n * @mixin HasMany\n */\nvar HasMany = function(source, target, options) {\n  Association.call(this);\n\n  this.associationType = 'HasMany';\n  this.source = source;\n  this.target = target;\n  this.targetAssociation = null;\n  this.options = options || {};\n  this.sequelize = source.modelManager.sequelize;\n  this.through = options.through;\n  this.scope = options.scope;\n  this.isMultiAssociation = true;\n  this.isSelfAssociation = this.source === this.target;\n  this.as = this.options.as;\n  this.foreignKeyAttribute = {};\n\n  if (this.options.through) {\n    throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n  }\n\n\n  /*\n   * If self association, this is the target association\n   */\n  if (this.isSelfAssociation) {\n    this.targetAssociation = this;\n  }\n\n  if (this.as) {\n    this.isAliased = true;\n\n    if (_.isPlainObject(this.as)) {\n      this.options.name = this.as;\n      this.as = this.as.plural;\n    } else {\n      this.options.name = {\n        plural: this.as,\n        singular: Utils.singularize(this.as)\n      };\n    }\n  } else {\n    this.as = this.target.options.name.plural;\n    this.options.name = this.target.options.name;\n  }\n\n  /*\n   * Foreign key setup\n   */\n  if (_.isObject(this.options.foreignKey)) {\n    this.foreignKeyAttribute = this.options.foreignKey;\n    this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n  } else if (this.options.foreignKey) {\n    this.foreignKey = this.options.foreignKey;\n  }\n\n  if (!this.foreignKey) {\n    this.foreignKey = Utils.camelizeIf(\n      [\n        Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored),\n        this.source.primaryKeyAttribute\n      ].join('_'),\n      !this.source.options.underscored\n    );\n  }\n\n  if (this.target.rawAttributes[this.foreignKey]) {\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n  }\n\n  this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n  if (this.target.rawAttributes[this.sourceKey]) {\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n  } else {\n    this.sourceKeyField = this.sourceKey;\n  }\n\n  if (this.source.fieldRawAttributesMap[this.sourceKey]) {\n    this.sourceKeyAttribute = this.source.fieldRawAttributesMap[this.sourceKey].fieldName;\n  } else {\n    this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n  }\n  this.sourceIdentifier = this.sourceKey;\n  this.associationAccessor = this.as;\n\n  // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n  var plural = Utils.uppercaseFirst(this.options.name.plural)\n    , singular = Utils.uppercaseFirst(this.options.name.singular);\n\n  this.accessors = {\n    /**\n     * Get everything currently associated with this, using an optional where clause.\n     *\n     * @param {Object} [options]\n     * @param {Object} [options.where] An optional where clause to limit the associated models\n     * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @param {String} [options.schema] Apply a schema on the related model\n     * @return {Promise<Array<Instance>>}\n     * @method getAssociations\n     */\n    get: 'get' + plural,\n    /**\n     * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n     *\n     * @param {Array<Instance|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n     * @param {Object} [options] Options passed to `target.findAll` and `update`.\n     * @param {Object} [options.validate] Run validation for the join model\n     * @return {Promise}\n     * @method setAssociations\n     */\n    set: 'set' + plural,\n    /**\n     * Associate several persisted instances with this.\n     *\n     * @param {Array<Instance|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this.\n     * @param {Object} [options] Options passed to `target.update`.\n     * @param {Object} [options.validate] Run validation for the join model.\n     * @return {Promise}\n     * @method addAssociations\n     */\n    addMultiple: 'add' + plural,\n    /**\n     * Associate a persisted instance with this.\n     *\n     * @param {Instance|String|Number} [newAssociation] A persisted instance or primary key of instance to associate with this.\n     * @param {Object} [options] Options passed to `target.update`.\n     * @param {Object} [options.validate] Run validation for the join model.\n     * @return {Promise}\n     * @method addAssociation\n     */\n    add: 'add' + singular,\n    /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Object} [values]\n     * @param {Object} [options] Options passed to `target.create`.\n     * @return {Promise}\n     * @method createAssociation\n     */\n    create: 'create' + singular,\n    /**\n     * Un-associate the instance.\n     *\n     * @param {Instance|String|Number} [oldAssociated] Can be an Instance or its primary key\n     * @param {Object} [options] Options passed to `target.update`\n     * @return {Promise}\n     * @method removeAssociation\n     */\n    remove: 'remove' + singular,\n    /**\n     * Un-associate several instances.\n     *\n     * @param {Array<Instance|String|Number>} [oldAssociatedArray] Can be an array of instances or their primary keys\n     * @param {Object} [options] Options passed to `through.destroy`\n     * @return {Promise}\n     * @method removeAssociations\n     */\n    removeMultiple: 'remove' + plural,\n    /**\n     * Check if an instance is associated with this.\n     *\n     * @param {Instance|String|Number} [instance] Can be an Instance or its primary key\n     * @param {Object} [options] Options passed to getAssociations\n     * @return {Promise}\n     * @method hasAssociation\n     */\n    hasSingle: 'has' + singular,\n    /**\n     * Check if all instances are associated with this.\n     *\n     * @param {Array<Instance|String|Number>} [instances] Can be an array of instances or their primary keys\n     * @param {Object} [options] Options passed to getAssociations\n     * @return {Promise}\n     * @method hasAssociations\n     */\n    hasAll: 'has' + plural,\n    /**\n     * Count everything currently associated with this, using an optional where clause.\n     *\n     * @param {Object} [options]\n     * @param {Object} [options.where] An optional where clause to limit the associated models\n     * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @return {Promise<Int>}\n     * @method countAssociations\n     */\n    count: 'count' + plural\n  };\n\n  if (this.options.counterCache) {\n    new CounterCache(this, this.options.counterCache !== true ? this.options.counterCache : {});\n    delete this.accessors.count;\n  }\n};\n\nutil.inherits(HasMany, Association);\n\n// the id is in the target table\n// or in an extra table which connects two tables\nHasMany.prototype.injectAttributes = function() {\n  var newAttributes = {};\n  var constraintOptions = _.clone(this.options); // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n  newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n    type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n    allowNull : true\n  });\n\n  if (this.options.constraints !== false) {\n    var target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n    constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n    constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n  }\n  Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n  Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n  this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n  this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n  this.target.refreshAttributes();\n  this.source.refreshAttributes();\n\n  Helpers.checkNamingCollision(this);\n\n  return this;\n};\n\nHasMany.prototype.mixin = function(obj) {\n  var association = this;\n\n  obj[this.accessors.get] = function(options) {\n    return association.get(this, options);\n  };\n\n  if (this.accessors.count) {\n    obj[this.accessors.count] = function(options) {\n      return association.count(this, options);\n    };\n  }\n\n  obj[this.accessors.hasSingle] = obj[this.accessors.hasAll] = function(instances, options) {\n    return association.has(this, instances, options);\n  };\n\n  obj[this.accessors.set] = function(instances, options) {\n    return association.set(this, instances, options);\n  };\n\n  obj[this.accessors.add] = obj[this.accessors.addMultiple] = function(instances, options) {\n    return association.add(this, instances, options);\n  };\n\n  obj[this.accessors.remove] = obj[this.accessors.removeMultiple] = function(instances, options) {\n    return association.remove(this, instances, options);\n  };\n\n  obj[this.accessors.create] = function(values, options) {\n    return association.create(this, values, options);\n  };\n};\n\nHasMany.prototype.get = function(instances, options) {\n  var association = this\n    , where = {}\n    , Model = association.target\n    , instance\n    , values;\n\n  if (!Array.isArray(instances)) {\n    instance = instances;\n    instances = undefined;\n  }\n\n  options = Utils.cloneDeep(options) || {};\n\n  if (association.scope) {\n    _.assign(where, association.scope);\n  }\n\n  if (instances) {\n    values = instances.map(function (instance) {\n      return instance.get(association.sourceKey, {raw: true});\n    });\n\n    if (options.limit && instances.length > 1) {\n      options.groupedLimit = {\n        limit: options.limit,\n        on: association.foreignKeyField,\n        values: values\n      };\n\n      delete options.limit;\n    } else {\n      where[association.foreignKey] = {\n        $in: values\n      };\n      delete options.groupedLimit;\n    }\n  } else {\n    where[association.foreignKey] = instance.get(association.sourceKey, {raw: true});\n  }\n\n\n  options.where = options.where ?\n                  {$and: [where, options.where]} :\n                  where;\n\n  if (options.hasOwnProperty('scope')) {\n    if (!options.scope) {\n      Model = Model.unscoped();\n    } else {\n      Model = Model.scope(options.scope);\n    }\n  }\n\n  if (options.hasOwnProperty('schema')) {\n    Model = Model.schema(options.schema, options.schemaDelimiter);\n  }\n\n\n  return Model.findAll(options).then(function (results) {\n    if (instance) return results;\n\n    var result = {};\n    instances.forEach(function (instance) {\n      result[instance.get(association.sourceKey, {raw: true})] = [];\n    });\n\n    results.forEach(function (instance) {\n      result[instance.get(association.foreignKey, {raw: true})].push(instance);\n    });\n\n    return result;\n  });\n};\n\nHasMany.prototype.count = function(instance, options) {\n  var association = this\n    , model = association.target\n    , sequelize = model.sequelize;\n\n  options = Utils.cloneDeep(options);\n  options.attributes = [\n    [sequelize.fn('COUNT', sequelize.col(model.primaryKeyField)), 'count']\n  ];\n  options.raw = true;\n  options.plain = true;\n\n  return this.get(instance, options).then(function (result) {\n    return parseInt(result.count, 10);\n  });\n};\n\nHasMany.prototype.has = function(sourceInstance, targetInstances, options) {\n  var association = this\n    , where = {};\n\n  if (!Array.isArray(targetInstances)) {\n    targetInstances = [targetInstances];\n  }\n\n  options = _.assign({}, options, {\n    scope: false,\n    raw: true\n  });\n\n  where.$or = targetInstances.map(function (instance) {\n    if (instance instanceof association.target.Instance) {\n      return instance.where();\n    } else {\n      var _where = {};\n      _where[association.target.primaryKeyAttribute] = instance;\n      return _where;\n    }\n  });\n\n  options.where = {\n    $and: [\n      where,\n      options.where\n    ]\n  };\n\n  return this.get(\n    sourceInstance,\n    options\n  ).then(function(associatedObjects) {\n    return associatedObjects.length === targetInstances.length;\n  });\n};\n\nHasMany.prototype.set = function(sourceInstance, targetInstances, options) {\n  var association = this;\n\n  if (targetInstances === null) {\n    targetInstances = [];\n  } else {\n    targetInstances = association.toInstanceArray(targetInstances);\n  }\n\n  return association.get(sourceInstance, _.defaults({\n    scope: false,\n    raw: true\n  }, options)).then(function(oldAssociations) {\n    var promises = []\n      , obsoleteAssociations = oldAssociations.filter(function(old) {\n          return !_.find(targetInstances, function(obj) {\n            return obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute];\n          });\n        })\n      , unassociatedObjects = targetInstances.filter(function(obj) {\n          return !_.find(oldAssociations, function(old) {\n            return obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute];\n          });\n        })\n      , updateWhere\n      , update;\n\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[association.foreignKey] = null;\n\n      updateWhere = {};\n\n      updateWhere[association.target.primaryKeyAttribute] = obsoleteAssociations.map(function(associatedObject) {\n        return associatedObject[association.target.primaryKeyAttribute];\n      });\n\n      promises.push(association.target.unscoped().update(\n        update,\n        _.defaults({\n          where: updateWhere\n        }, options)\n      ));\n    }\n\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n\n      update = {};\n      update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n\n      _.assign(update, association.scope);\n      updateWhere[association.target.primaryKeyAttribute] = unassociatedObjects.map(function(unassociatedObject) {\n        return unassociatedObject[association.target.primaryKeyAttribute];\n      });\n\n      promises.push(association.target.unscoped().update(\n        update,\n        _.defaults({\n          where: updateWhere\n        }, options)\n      ));\n    }\n\n    return Utils.Promise.all(promises).return(sourceInstance);\n  });\n};\n\nHasMany.prototype.add = function(sourceInstance, targetInstances, options) {\n  if (!targetInstances) return Utils.Promise.resolve();\n\n  var association = this\n    , update = {}\n    , where = {};\n\n  options = options || {};\n\n  targetInstances = association.toInstanceArray(targetInstances);\n\n  update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n  _.assign(update, association.scope);\n\n  where[association.target.primaryKeyAttribute] = targetInstances.map(function (unassociatedObject) {\n    return unassociatedObject.get(association.target.primaryKeyAttribute);\n  });\n\n  return association.target.unscoped().update(\n    update,\n    _.defaults({\n      where: where\n    }, options)\n  ).return(sourceInstance);\n};\n\nHasMany.prototype.remove = function(sourceInstance, targetInstances, options) {\n  var association = this\n    , update = {}\n    , where = {};\n\n  options = options || {};\n  targetInstances = association.toInstanceArray(targetInstances);\n\n  update[association.foreignKey] = null;\n\n  where[association.foreignKey] = sourceInstance.get(association.sourceKey);\n  where[association.target.primaryKeyAttribute] = targetInstances.map(function (targetInstance) {\n    return targetInstance.get(association.target.primaryKeyAttribute);\n  });\n\n  return association.target.unscoped().update(\n    update,\n    _.defaults({\n      where: where\n    }, options)\n  ).return(this);\n};\n\nHasMany.prototype.create = function(sourceInstance, values, options) {\n  var association = this;\n\n  options = options || {};\n\n  if (Array.isArray(options)) {\n    options = {\n      fields: options\n    };\n  }\n\n  if (values === undefined) {\n    values = {};\n  }\n\n  if (association.scope) {\n    Object.keys(association.scope).forEach(function (attribute) {\n      values[attribute] = association.scope[attribute];\n      if (options.fields) options.fields.push(attribute);\n    });\n  }\n\n  values[association.foreignKey] = sourceInstance.get(association.sourceKey);\n  if (options.fields) options.fields.push(association.foreignKey);\n  return association.target.create(values, options);\n};\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/plugins/counter-cache.js":"'use strict';\n\nvar Utils = require('./../utils')\n  , Helpers = require('../associations/helpers')\n  , DataTypes = require('../data-types')\n  , Promise = require('bluebird');\n\nvar CounterCache = function(association, options) {\n  this.association = association;\n  this.source = association.source;\n  this.target = association.target;\n  this.options = options || {};\n\n  this.sequelize = this.source.modelManager.sequelize;\n  this.as = this.options.as;\n\n  if (association.associationType !== 'HasMany') {\n    throw new Error('Can only have CounterCache on HasMany association');\n  }\n\n  if (this.as) {\n    this.isAliased = true;\n    this.columnName = this.as;\n  } else {\n    this.as = 'count_' + this.target.options.name.plural;\n    this.columnName = Utils.camelizeIf(\n      this.as,\n      !this.source.options.underscored\n    );\n  }\n\n  this.injectAttributes();\n  this.injectHooks();\n};\n\n// Add countAssociation attribute to source model\nCounterCache.prototype.injectAttributes = function() {\n  // Do not try to use a column that's already taken\n  Helpers.checkNamingCollision(this);\n\n  var newAttributes = {};\n\n  newAttributes[this.columnName] = {\n    type: DataTypes.INTEGER,\n    allowNull: false,\n    defaultValue: Utils._.partial(\n      Utils.toDefaultValue,\n      0\n    )\n  };\n\n  Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n\n  // Sync attributes and setters/getters to DAO prototype\n  this.source.refreshAttributes();\n};\n\n// Add setAssociaton method to the prototype of the model instance\nCounterCache.prototype.injectHooks = function() {\n  var association = this.association,\n    counterCacheInstance = this,\n    CounterUtil,\n    fullUpdateHook,\n    atomicHooks,\n    previousTargetId;\n\n  CounterUtil = {\n    update: function (targetId, options) {\n      var query = CounterUtil._targetQuery(targetId);\n\n      return association.target.count({ where: query, logging: options && options.logging }).then(function (count) {\n        var newValues = {};\n\n        query = CounterUtil._sourceQuery(targetId);\n\n        newValues[counterCacheInstance.columnName] = count;\n\n        return association.source.update(newValues, { where: query, logging: options && options.logging });\n      });\n    },\n    increment: function (targetId, options) {\n      var query = CounterUtil._sourceQuery(targetId);\n\n      return association.source.find({ where: query, logging: options && options.logging }).then(function (instance) {\n        return instance.increment(counterCacheInstance.columnName, { by: 1, logging: options && options.logging });\n      });\n    },\n    decrement: function (targetId, options) {\n      var query = CounterUtil._sourceQuery(targetId);\n\n      return association.source.find({ where: query, logging: options && options.logging }).then(function (instance) {\n        return instance.decrement(counterCacheInstance.columnName, { by: 1, logging: options && options.logging });\n      });\n    },\n    // helpers\n    _targetQuery: function (id) {\n      var query = {};\n\n      query[association.foreignKey] = id;\n\n      return query;\n    },\n    _sourceQuery: function (id) {\n      var query = {};\n\n      query[association.source.primaryKeyAttribute] = id;\n\n      return query;\n    }\n  };\n\n  fullUpdateHook = function (target, options) {\n    var targetId = target.get(association.foreignKey)\n      , promises = [];\n\n    if (targetId) {\n      promises.push(CounterUtil.update(targetId, options));\n    }\n\n    if (previousTargetId && previousTargetId !== targetId) {\n      promises.push(CounterUtil.update(previousTargetId, options));\n    }\n\n    return Promise.all(promises).return(undefined);\n  };\n\n  atomicHooks = {\n    create: function (target, options) {\n      var targetId = target.get(association.foreignKey);\n\n      if (targetId) {\n        return CounterUtil.increment(targetId, options);\n      }\n    },\n    update: function (target, options) {\n      var targetId = target.get(association.foreignKey)\n        , promises = [];\n\n      if (targetId && !previousTargetId) {\n        promises.push(CounterUtil.increment(targetId, options));\n      }\n      if (!targetId && previousTargetId) {\n        promises.push(CounterUtil.decrement(targetId, options));\n      }\n      if (previousTargetId && targetId && previousTargetId !== targetId) {\n        promises.push(CounterUtil.increment(targetId, options));\n        promises.push(CounterUtil.decrement(previousTargetId, options));\n      }\n\n      return Promise.all(promises);\n    },\n    destroy: function (target, options) {\n      var targetId = target.get(association.foreignKey);\n\n      if (targetId) {\n        return CounterUtil.decrement(targetId, options);\n      }\n    }\n  };\n\n  // previousDataValues are cleared before afterUpdate, so we need to save this here\n  association.target.addHook('beforeUpdate', function (target) {\n    previousTargetId = target.previous(association.foreignKey);\n  });\n\n  if (this.options.atomic === false) {\n    association.target.addHook('afterCreate', fullUpdateHook);\n    association.target.addHook('afterUpdate', fullUpdateHook);\n    association.target.addHook('afterDestroy', fullUpdateHook);\n  } else {\n    association.target.addHook('afterCreate', atomicHooks.create);\n    association.target.addHook('afterUpdate', atomicHooks.update);\n    association.target.addHook('afterDestroy', atomicHooks.destroy);\n  }\n};\n\nmodule.exports = CounterCache;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/has-one.js":"'use strict';\n\nvar Utils = require('./../utils')\n  , Helpers = require('./helpers')\n  , _ = require('lodash')\n  , Association = require('./base')\n  , util = require('util');\n\n/**\n * One-to-one association\n *\n * In the API reference below, replace `Association` with the actual name of your association, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception. The foreign key will be defined on the target model.\n *\n * @mixin HasOne\n */\nvar HasOne = function(srcModel, targetModel, options) {\n  Association.call(this);\n\n  this.associationType = 'HasOne';\n  this.source = srcModel;\n  this.target = targetModel;\n  this.options = options;\n  this.scope = options.scope;\n  this.isSingleAssociation = true;\n  this.isSelfAssociation = (this.source === this.target);\n  this.as = this.options.as;\n  this.foreignKeyAttribute = {};\n\n  if (this.as) {\n    this.isAliased = true;\n    this.options.name = {\n      singular: this.as\n    };\n  } else {\n    this.as = this.target.options.name.singular;\n    this.options.name = this.target.options.name;\n  }\n\n  if (_.isObject(this.options.foreignKey)) {\n    this.foreignKeyAttribute = this.options.foreignKey;\n    this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n  } else if (this.options.foreignKey) {\n    this.foreignKey = this.options.foreignKey;\n  }\n\n  if (!this.foreignKey) {\n    this.foreignKey = Utils.camelizeIf(\n      [\n        Utils.underscoredIf(Utils.singularize(this.source.name), this.target.options.underscored),\n        this.source.primaryKeyAttribute\n      ].join('_'),\n      !this.source.options.underscored\n    );\n  }\n\n  this.sourceIdentifier = this.source.primaryKeyAttribute;\n  this.sourceKey = this.source.primaryKeyAttribute;\n  this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n\n  this.associationAccessor = this.as;\n  this.options.useHooks = options.useHooks;\n\n  if (this.target.rawAttributes[this.foreignKey]) {\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n  }\n\n  // Get singular name, trying to uppercase the first letter, unless the model forbids it\n  var singular = Utils.uppercaseFirst(this.options.name.singular);\n\n  this.accessors = {\n    /**\n     * Get the associated instance.\n     *\n     * @param {Object} [options]\n     * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @param {String} [options.schema] Apply a schema on the related model\n     * @return {Promise<Instance>}\n     * @method getAssociation\n     */\n    get: 'get' + singular,\n    /**\n     * Set the associated model.\n     *\n     * @param {Instance|String|Number} [newAssociation] An persisted instance or the primary key of a persisted instance to associate with this. Pass `null` or `undefined` to remove the association.\n     * @param {Object} [options] Options passed to getAssociation and `target.save`\n     * @return {Promise}\n     * @method setAssociation\n     */\n    set: 'set' + singular,\n    /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Object} [values]\n     * @param {Object} [options] Options passed to `target.create` and setAssociation.\n     * @return {Promise}\n     * @method createAssociation\n     */\n    create: 'create' + singular\n  };\n};\n\nutil.inherits(HasOne, Association);\n\n// the id is in the target table\nHasOne.prototype.injectAttributes = function() {\n  var newAttributes = {}\n    , keyType = this.source.rawAttributes[this.source.primaryKeyAttribute].type;\n\n  newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n    type: this.options.keyType || keyType,\n    allowNull : true\n  });\n  Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n  this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n  if (this.options.constraints !== false) {\n    var target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n    this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n    this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n  }\n\n  Helpers.addForeignKeyConstraints(this.target.rawAttributes[this.foreignKey], this.source, this.target, this.options);\n\n  // Sync attributes and setters/getters to Model prototype\n  this.target.refreshAttributes();\n\n  Helpers.checkNamingCollision(this);\n\n  return this;\n};\n\nHasOne.prototype.mixin = function(obj) {\n  var association = this;\n\n  obj[this.accessors.get] = function(options) {\n    return association.get(this, options);\n  };\n\n  association.injectSetter(obj);\n  association.injectCreator(obj);\n};\n\nHasOne.prototype.get = function(instances, options) {\n  var association = this\n    , Target = association.target\n    , instance\n    , where = {};\n\n  options = Utils.cloneDeep(options);\n\n  if (options.hasOwnProperty('scope')) {\n    if (!options.scope) {\n      Target = Target.unscoped();\n    } else {\n      Target = Target.scope(options.scope);\n    }\n  }\n\n  if (options.hasOwnProperty('schema')) {\n    Target = Target.schema(options.schema, options.schemaDelimiter);\n  }\n\n  if (!Array.isArray(instances)) {\n    instance = instances;\n    instances = undefined;\n  }\n\n  if (instances) {\n    where[association.foreignKey] = {\n      $in: instances.map(function (instance) {\n        return instance.get(association.sourceKey);\n      })\n    };\n  } else {\n    where[association.foreignKey] = instance.get(association.sourceKey);\n  }\n\n  if (association.scope) {\n    _.assign(where, association.scope);\n  }\n\n  options.where = options.where ?\n                  {$and: [where, options.where]} :\n                  where;\n\n  if (instances) {\n    return Target.findAll(options).then(function (results) {\n      var result = {};\n      instances.forEach(function (instance) {\n        result[instance.get(association.sourceKey, {raw: true})] = null;\n      });\n\n      results.forEach(function (instance) {\n        result[instance.get(association.foreignKey, {raw: true})] = instance;\n      });\n\n      return result;\n    });\n  }\n  return Target.findOne(options);\n};\n\nHasOne.prototype.injectSetter = function(instancePrototype) {\n  var association = this;\n\n  instancePrototype[this.accessors.set] = function(associatedInstance, options) {\n    var instance = this,\n      alreadyAssociated;\n\n    options = _.assign({}, options, {\n      scope: false\n    });\n    return instance[association.accessors.get](options).then(function(oldInstance) {\n      // TODO Use equals method once #5605 is resolved\n      alreadyAssociated = oldInstance && associatedInstance && _.every(association.target.primaryKeyAttributes, function(attribute) {\n        return oldInstance.get(attribute, {raw: true}) === associatedInstance.get(attribute, {raw: true});\n      });\n\n      if (oldInstance && !alreadyAssociated) {\n        oldInstance[association.foreignKey] = null;\n        return oldInstance.save(_.extend({}, options, {\n          fields: [association.foreignKey],\n          allowNull: [association.foreignKey],\n          association: true\n        }));\n      }\n    }).then(function() {\n      if (associatedInstance && !alreadyAssociated) {\n        if (!(associatedInstance instanceof association.target.Instance)) {\n          var tmpInstance = {};\n          tmpInstance[association.target.primaryKeyAttribute] = associatedInstance;\n          associatedInstance = association.target.build(tmpInstance, {\n            isNewRecord: false\n          });\n        }\n\n        _.assign(associatedInstance, association.scope);\n        associatedInstance.set(association.foreignKey, instance.get(association.sourceIdentifier));\n\n        return associatedInstance.save(options);\n      }\n      return null;\n    });\n  };\n\n  return this;\n};\n\nHasOne.prototype.injectCreator = function(instancePrototype) {\n  var association = this;\n\n  instancePrototype[this.accessors.create] = function(values, options) {\n    var instance = this;\n    values = values || {};\n    options = options || {};\n\n    if (association.scope) {\n      Object.keys(association.scope).forEach(function (attribute) {\n        values[attribute] = association.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      });\n    }\n\n    values[association.foreignKey] = instance.get(association.sourceIdentifier);\n    if (options.fields) options.fields.push(association.foreignKey);\n    return association.target.create(values, options);\n  };\n\n  return this;\n};\n\nmodule.exports = HasOne;\nmodule.exports.HasOne = HasOne;\nmodule.exports.default = HasOne;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/instance-validator.js":"'use strict';\n\nvar validator = require('./utils/validator-extras').validator\n  , extendModelValidations = require('./utils/validator-extras').extendModelValidations\n  , Utils = require('./utils')\n  , sequelizeError = require('./errors')\n  , Promise = require('./promise')\n  , DataTypes = require('./data-types')\n  , _ = require('lodash');\n\n/**\n * The Main Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {Object} options A dict with options.\n * @constructor\n */\nfunction InstanceValidator(modelInstance, options) {\n  options = _.clone(options) || {};\n\n  if (options.fields && !options.skip) {\n    options.skip = Utils._.difference(Object.keys(modelInstance.Model.attributes), options.fields);\n  }\n\n  // assign defined and default options\n  this.options = Utils._.defaults(options, {\n    skip: []\n  });\n\n  this.modelInstance = modelInstance;\n\n  /**\n   * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n   * @name validator\n   */\n  this.validator = validator;\n\n  /**\n   *  All errors will be stored here from the validations.\n   *\n   * @type {Array} Will contain keys that correspond to attributes which will\n   *   be Arrays of Errors.\n   */\n  this.errors = [];\n\n  /** @type {boolean} Indicates if validations are in progress */\n  this.inProgress = false;\n\n  extendModelValidations(modelInstance);\n}\n\n/** @define {string} The error key for arguments as passed by custom validators */\nInstanceValidator.RAW_KEY_NAME = '__raw';\n\n/**\n * The main entry point for the Validation module, invoke to start the dance.\n *\n * @return {Promise}\n */\nInstanceValidator.prototype.validate = function() {\n  if (this.inProgress) {\n    throw new Error('Validations already in progress.');\n  }\n  this.inProgress = true;\n\n  var self = this;\n  return Promise.all([\n    self._builtinValidators(),\n    self._customValidators()\n  ].map(function(promise) {\n    return promise.reflect();\n  })).then(function() {\n    if (self.errors.length) {\n      return new sequelizeError.ValidationError(null, self.errors);\n    } else {\n      return null;\n    }\n  });\n};\n\n/**\n * Invoke the Validation sequence:\n *   - Before Validation Model Hooks\n *   - Validation\n *   - On validation success: After Validation Model Hooks\n *   - On validation failure: Validation Failed Model Hooks\n *\n * @return {Promise}\n */\nInstanceValidator.prototype.hookValidate = function() {\n  var self = this;\n  return self.modelInstance.Model.runHooks('beforeValidate', self.modelInstance, self.options).then(function() {\n    return self.validate().then(function(error) {\n      if (error) {\n        return self.modelInstance.Model.runHooks('validationFailed', self.modelInstance, self.options, error).then(function(newError) {\n          throw newError || error;\n        });\n      }\n    });\n  }).then(function() {\n    return self.modelInstance.Model.runHooks('afterValidate', self.modelInstance, self.options);\n  }).return(self.modelInstance);\n};\n\n/**\n * Will run all the built-in validators.\n *\n * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n * @private\n */\nInstanceValidator.prototype._builtinValidators = function() {\n  var self = this;\n\n  // promisify all attribute invocations\n  var validators = [];\n  Utils._.forIn(this.modelInstance.rawAttributes, function(rawAttribute, field) {\n    if (self.options.skip.indexOf(field) >= 0) {\n      return;\n    }\n\n    var value = self.modelInstance.dataValues[field];\n\n    if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n      // perform validations based on schema\n      self._validateSchema(rawAttribute, field, value);\n    }\n\n    if (self.modelInstance.validators.hasOwnProperty(field)) {\n      validators.push(self._builtinAttrValidate.call(self, value, field).reflect());\n    }\n  });\n\n  return Promise.all(validators);\n};\n\n/**\n * Will run all the custom validators.\n *\n * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n * @private\n */\nInstanceValidator.prototype._customValidators = function() {\n  var validators = [];\n  var self = this;\n  Utils._.each(this.modelInstance.$modelOptions.validate, function(validator, validatorType) {\n    if (self.options.skip.indexOf(validatorType) >= 0) {\n      return;\n    }\n\n    var valprom = self._invokeCustomValidator(validator, validatorType)\n      // errors are handled in settling, stub this\n      .catch(function() {})\n      .reflect();\n\n    validators.push(valprom);\n  });\n\n  return Promise.all(validators);\n};\n\n/**\n * Validate a single attribute with all the defined built-in validators.\n *\n * @param {*} value Anything.\n * @param {string} field The field name.\n * @return {Promise} A promise, will always resolve,\n *   auto populates error on this.error local object.\n * @private\n */\nInstanceValidator.prototype._builtinAttrValidate = function(value, field) {\n  var self = this;\n  // check if value is null (if null not allowed the Schema pass will capture it)\n  if (value === null || typeof value === 'undefined') {\n    return Promise.resolve();\n  }\n\n  // Promisify each validator\n  var validators = [];\n  Utils._.forIn(this.modelInstance.validators[field], function(test,\n    validatorType) {\n\n    if (['isUrl', 'isURL', 'isEmail'].indexOf(validatorType) !== -1) {\n      // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n      if (typeof test === 'object' && test !== null && test.msg) {\n        test = {\n          msg: test.msg\n        };\n      } else if (test === true) {\n        test = {};\n      }\n    }\n\n    // Check for custom validator.\n    if (typeof test === 'function') {\n      return validators.push(self._invokeCustomValidator(test, validatorType, true, value, field).reflect());\n    }\n\n    var validatorPromise = self._invokeBuiltinValidator(value, test, validatorType, field);\n    // errors are handled in settling, stub this\n    validatorPromise.catch(function() {});\n    validators.push(validatorPromise.reflect());\n  });\n\n  return Promise.all(validators).then(this._handleReflectedResult.bind(this, field));\n};\n\n/**\n * Prepare and invoke a custom validator.\n *\n * @param {Function} validator The custom validator.\n * @param {string} validatorType the custom validator type (name).\n * @param {boolean=} optAttrDefined Set to true if custom validator was defined\n *   from the Attribute\n * @return {Promise} A promise.\n * @private\n */\nInstanceValidator.prototype._invokeCustomValidator = Promise.method(function(validator, validatorType, optAttrDefined, optValue, optField) {\n  var validatorFunction = null;  // the validation function to call\n  var isAsync = false;\n\n  var validatorArity = validator.length;\n  // check if validator is async and requires a callback\n  var asyncArity = 1;\n  var errorKey = validatorType;\n  var invokeArgs;\n  if (optAttrDefined) {\n    asyncArity = 2;\n    invokeArgs = optValue;\n    errorKey = optField;\n  }\n  if (validatorArity === asyncArity) {\n    isAsync = true;\n  }\n\n  if (isAsync) {\n    if (optAttrDefined) {\n      validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));\n    } else {\n      validatorFunction = Promise.promisify(validator.bind(this.modelInstance));\n    }\n    return validatorFunction().catch(this._pushError.bind(this, false, errorKey));\n  } else {\n    return Promise.try(validator.bind(this.modelInstance, invokeArgs)).catch(this._pushError.bind(this, false, errorKey));\n  }\n});\n\n/**\n * Prepare and invoke a build-in validator.\n *\n * @param {*} value Anything.\n * @param {*} test The test case.\n * @param {string} validatorType One of known to Sequelize validators.\n * @param {string} field The field that is being validated\n * @return {Object} An object with specific keys to invoke the validator.\n * @private\n */\nInstanceValidator.prototype._invokeBuiltinValidator = Promise.method(function(value, test, validatorType, field) {\n  var self = this;\n  // Cast value as string to pass new Validator.js string requirement\n  var valueString = String(value);\n  // check if Validator knows that kind of validation test\n  if (typeof validator[validatorType] !== 'function') {\n    throw new Error('Invalid validator function: ' + validatorType);\n  }\n  var validatorArgs = self._extractValidatorArgs(test, validatorType, field);\n  if (!validator[validatorType].apply(validator, [valueString].concat(validatorArgs))) {\n  // extract the error msg\n    throw new Error(test.msg || 'Validation ' + validatorType + ' failed');\n  }\n});\n\n/**\n * Will extract arguments for the validator.\n *\n * @param {*} test The test case.\n * @param {string} validatorType One of known to Sequelize validators.\n * @param {string} field The field that is being validated.\n * @private\n */\nInstanceValidator.prototype._extractValidatorArgs = function(test, validatorType, field) {\n  var validatorArgs = test.args || test;\n  var isLocalizedValidator = typeof(validatorArgs) !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n  if (!Array.isArray(validatorArgs)) {\n    if (validatorType === 'isImmutable') {\n      validatorArgs = [validatorArgs, field];\n    } else if (isLocalizedValidator || validatorType === 'isIP') {\n      validatorArgs = [];\n    } else {\n      validatorArgs = [validatorArgs];\n    }\n  } else {\n    validatorArgs = validatorArgs.slice(0);\n  }\n  return validatorArgs;\n};\n\n/**\n * Will validate a single field against its schema definition (isnull).\n *\n * @param {Object} rawAttribute As defined in the Schema.\n * @param {string} field The field name.\n * @param {*} value anything.\n * @private\n */\nInstanceValidator.prototype._validateSchema = function(rawAttribute, field, value) {\n  var error;\n\n  if (rawAttribute.allowNull === false && ((value === null) || (value === undefined))) {\n    error = new sequelizeError.ValidationErrorItem(field + ' cannot be null', 'notNull Violation', field, value);\n    this.errors.push(error);\n  }\n\n  if (rawAttribute.type === DataTypes.STRING || rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type === DataTypes.TEXT || rawAttribute.type instanceof DataTypes.TEXT) {\n    if (Array.isArray(value) || (_.isObject(value) && !value._isSequelizeMethod) && !Buffer.isBuffer(value)) {\n      error = new sequelizeError.ValidationErrorItem(field + ' cannot be an array or an object', 'string violation', field, value);\n      this.errors.push(error);\n    }\n  }\n};\n\n\n/**\n * Handles the returned result of a Promise.reflect.\n *\n * If errors are found it populates this.error.\n *\n * @param {string} field The attribute name.\n * @param {Array.<Promise.PromiseInspection>} Promise inspection objects.\n * @private\n */\nInstanceValidator.prototype._handleReflectedResult = function(field, promiseInspections) {\n  var self = this;\n  promiseInspections.forEach(function(promiseInspection) {\n    if (promiseInspection.isRejected()) {\n      var rejection = promiseInspection.error();\n      self._pushError(true, field, rejection);\n    }\n  });\n};\n\n/**\n * Signs all errors retaining the original.\n *\n * @param {boolean} isBuiltin Determines if error is from builtin validator.\n * @param {string} errorKey The error key to assign on this.errors object.\n * @param {Error|string} rawError The original error.\n * @private\n */\nInstanceValidator.prototype._pushError = function(isBuiltin, errorKey, rawError) {\n  var message = rawError.message || rawError || 'Validation error';\n  var error = new sequelizeError.ValidationErrorItem(message, 'Validation error', errorKey, rawError);\n  error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n  this.errors.push(error);\n};\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/utils/validator-extras.js":"'use strict';\n\nvar validator = require('validator')\n  , _ = require('lodash');\n\nvar extensions = {\n  extend: function(name, fn) {\n    this[name] = fn;\n\n    return this;\n  },\n  notEmpty: function(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len: function(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl: function(str) {\n    return this.isURL(str);\n  },\n  isIPv6: function(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4: function(str) {\n    return this.isIP(str, 4);\n  },\n  notIn: function(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex: function(str, pattern, modifiers) {\n    str += '';\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex: function(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal: function(str) {\n    return str !== '' && str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$/);\n  },\n  min: function(str, val) {\n    var number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max: function(str, val) {\n    var number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not: function(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains: function(str, elem) {\n    return str.indexOf(elem) >= 0 && !!elem;\n  },\n  notContains: function(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is: function(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  },\n};\nvar extendModelValidations = function(modelInstance) {\n  var extensions = {\n        isImmutable: function(str, param, field) {\n          return (modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field]);\n        },\n      };\n\n  _.forEach(extensions, function(extend, key) {\n    validator[key] = extend;\n  });\n};\n\n// Deprecate this.\nvalidator.notNull = function() {\n  throw new Error('Warning \"notNull\" validation has been deprecated in favor of Schema based \"allowNull\"');\n};\n\n// https://github.com/chriso/validator.js/blob/1.5.0/lib/validators.js\n_.forEach(extensions, function(extend, key) {\n  validator[key] = extend;\n});\n\nmodule.exports = {\n  extensions: extensions,\n  extendModelValidations: extendModelValidations,\n  validator: validator,\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/query-types.js":"'use strict';\n\nmodule.exports = {\n  SELECT: 'SELECT',\n  INSERT: 'INSERT',\n  UPDATE: 'UPDATE',\n  BULKUPDATE: 'BULKUPDATE',\n  BULKDELETE: 'BULKDELETE',\n  DELETE: 'DELETE',\n  UPSERT: 'UPSERT',\n  VERSION: 'VERSION',\n  SHOWTABLES: 'SHOWTABLES',\n  SHOWINDEXES: 'SHOWINDEXES',\n  DESCRIBE: 'DESCRIBE',\n  RAW: 'RAW',\n  FOREIGNKEYS: 'FOREIGNKEYS',\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/hooks.js":"'use strict';\n\nvar Utils = require('./utils')\n  , Promise = require('./promise');\n\n/**\n * Hooks are function that are called before and after  (bulk-) creation/updating/deletion and validation. Hooks can be added to you models in three ways:\n *\n * 1. By specifying them as options in `sequelize.define`\n * 2. By calling `hook()` with a string and your hook handler function\n * 3. By calling the function with the same name as the hook you want\n\n * ```js\n * // Method 1\n * sequelize.define(name, { attributes }, {\n *   hooks: {\n *     beforeBulkCreate: function () {\n *       // can be a single function\n *     },\n *     beforeValidate: [\n *       function () {},\n *       function() {} // Or an array of several\n *     ]\n *   }\n * })\n *\n * // Method 2\n * Model.hook('afterDestroy', function () {})\n *\n * // Method 3\n * Model.afterBulkUpdate(function () {})\n * ```\n *\n * @see {Sequelize#define}\n * @mixin Hooks\n * @name Hooks\n */\n\nvar hookTypes = {\n  beforeValidate: {params: 2},\n  afterValidate: {params: 2},\n  validationFailed: {params: 3},\n  beforeCreate: {params: 2},\n  afterCreate: {params: 2},\n  beforeDestroy: {params: 2},\n  afterDestroy: {params: 2},\n  beforeRestore: {params: 2},\n  afterRestore: {params: 2},\n  beforeUpdate: {params: 2},\n  afterUpdate: {params: 2},\n  beforeBulkCreate: {params: 2},\n  afterBulkCreate: {params: 2},\n  beforeBulkDestroy: {params: 1},\n  afterBulkDestroy: {params: 1},\n  beforeBulkRestore: {params: 1},\n  afterBulkRestore: {params: 1},\n  beforeBulkUpdate: {params: 1},\n  afterBulkUpdate: {params: 1},\n  beforeFind: {params: 1},\n  beforeFindAfterExpandIncludeAll: {params: 1},\n  beforeFindAfterOptions: {params: 1},\n  afterFind: {params: 2},\n  beforeCount: {params: 1},\n  beforeDefine: {params: 2, sync: true},\n  afterDefine: {params: 1, sync: true},\n  beforeInit: {params: 2, sync: true},\n  afterInit: {params: 1, sync: true},\n  beforeConnect: {params: 1},\n  afterConnect: {params: 2},\n  beforeSync: {params: 1},\n  afterSync: {params: 1},\n  beforeBulkSync: {params: 1},\n  afterBulkSync: {params: 1}\n};\n\nvar hookAliases = {\n  beforeDelete: 'beforeDestroy',\n  afterDelete: 'afterDestroy',\n  beforeBulkDelete: 'beforeBulkDestroy',\n  afterBulkDelete: 'afterBulkDestroy',\n  beforeConnection: 'beforeConnect'\n};\n\nvar Hooks = {\n  replaceHookAliases: function(hooks) {\n    var realHookName;\n\n    Utils._.each(hooks, function(hooksArray, name) {\n      // Does an alias for this hook name exist?\n      if (realHookName = hookAliases[name]) {\n        // Add the hooks to the actual hook\n        hooks[realHookName] = (hooks[realHookName] || []).concat(hooksArray);\n\n        // Delete the alias\n        delete hooks[name];\n      }\n    });\n\n    return hooks;\n  },\n\n  runHooks: function(hooks) {\n    var self = this\n      , fn\n      , fnArgs = Utils.sliceArgs(arguments, 1)\n      , hookType;\n\n    if (typeof fnArgs[fnArgs.length - 1] === 'function') {\n      fn = fnArgs.pop();\n    }\n\n    if (typeof hooks === 'string') {\n      hookType = hooks;\n      hooks = this.options.hooks[hookType] || [];\n      if (!Array.isArray(hooks)) hooks = hooks === undefined ? [] : [hooks];\n      if (this.sequelize) hooks = hooks.concat(this.sequelize.options.hooks[hookType] || []);\n    }\n\n    if (!Array.isArray(hooks)) {\n      hooks = hooks === undefined ? [] : [hooks];\n    }\n\n    // run hooks as sync functions if flagged as sync\n    if (hookTypes[hookType] && hookTypes[hookType].sync) {\n      hooks.forEach(function(hook) {\n        if (typeof hook === 'object') hook = hook.fn;\n        return hook.apply(self, fnArgs);\n      });\n      return;\n    }\n\n    // run hooks async\n    var promise = Promise.each(hooks, function (hook) {\n      if (typeof hook === 'object') {\n        hook = hook.fn;\n      }\n\n      if (hookType && hook.length > hookTypes[hookType].params) {\n        hook = Promise.promisify(hook, self);\n      }\n\n      return hook.apply(self, fnArgs);\n    }).return();\n\n    if (fn) {\n      return promise.nodeify(fn);\n    }\n\n    return promise;\n  },\n\n  hook: function() {\n    return Hooks.addHook.apply(this, arguments);\n  },\n\n  /**\n   * Add a hook to the model\n   *\n   * @param {String}    hooktype\n   * @param {String}    [name]    Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future.\n   * @param {Function}  fn        The hook function\n   *\n   * @alias hook\n   */\n  addHook: function(hookType, name, fn) {\n    if (typeof name === 'function') {\n      fn = name;\n      name = null;\n    }\n\n    hookType = hookAliases[hookType] || hookType;\n\n    this.options.hooks[hookType] = this.options.hooks[hookType] || [];\n    this.options.hooks[hookType].push(!!name ? {name: name, fn: fn} : fn);\n    return this;\n  },\n\n  /**\n   * Remove hook from the model\n   *\n   * @param {String} hookType\n   * @param {String} name\n   */\n  removeHook: function(hookType, name) {\n    hookType = hookAliases[hookType] || hookType;\n\n    if (!this.hasHook(hookType)) {\n      return this;\n    }\n\n    this.options.hooks[hookType] = this.options.hooks[hookType].filter(function (hook) {\n      // don't remove unnamed hooks\n      if (typeof hook === 'function') {\n        return true;\n      }\n\n      return typeof hook === 'object' && hook.name !== name;\n    });\n\n    return this;\n  },\n\n  /*\n   * Check whether the mode has any hooks of this type\n   *\n   * @param {String}  hookType\n   *\n   * @alias hasHooks\n   */\n  hasHook: function(hookType) {\n    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;\n  },\n};\n\nHooks.hasHooks = Hooks.hasHook;\n\n/**\n * A hook that is run before validation\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name beforeValidate\n */\n\n/**\n * A hook that is run after validation\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name afterValidate\n */\n\n/**\n * A hook that is run when validation fails\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options, error. Error is the\n * SequelizeValidationError. If the callback throws an error, it will replace the original validation error.\n * @name validationFailed\n */\n\n/**\n * A hook that is run before creating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeCreate\n */\n\n/**\n * A hook that is run after creating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name afterCreate\n */\n\n/**\n * A hook that is run before destroying a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name beforeDestroy\n * @alias beforeDelete\n */\n\n/**\n * A hook that is run after destroying a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name afterDestroy\n * @alias afterDelete\n */\n\n/**\n * A hook that is run before restoring a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name beforeRestore\n */\n\n/**\n * A hook that is run after restoring a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n *\n * @name afterRestore\n */\n\n/**\n * A hook that is run before updating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name beforeUpdate\n */\n\n/**\n * A hook that is run after updating a single instance\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance, options\n * @name afterUpdate\n */\n\n/**\n * A hook that is run before creating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instances, options\n * @name beforeBulkCreate\n */\n\n/**\n * A hook that is run after creating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instances, options\n * @name afterBulkCreate\n */\n\n/**\n * A hook that is run before destroying instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name beforeBulkDestroy\n * @alias beforeBulkDelete\n */\n\n/**\n * A hook that is run after destroying instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name afterBulkDestroy\n * @alias afterBulkDelete\n */\n\n/**\n * A hook that is run before restoring instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name beforeBulkRestore\n */\n\n/**\n * A hook that is run after restoring instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n *\n * @name afterBulkRestore\n */\n\n/**\n * A hook that is run before updating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeBulkUpdate\n */\n\n/**\n * A hook that is run after updating instances in bulk\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name afterBulkUpdate\n */\n\n/**\n * A hook that is run before a find (select) query\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFind\n */\n\n/**\n * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFindAfterExpandIncludeAll\n */\n\n/**\n * A hook that is run before a find (select) query, after all option parsing is complete\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeFindAfterOptions\n */\n\n/**\n * A hook that is run after a find (select) query\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with instance(s), options\n * @name afterFind\n */\n\n/**\n * A hook that is run before a count query\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options\n * @name beforeCount\n */\n\n/**\n * A hook that is run before a define call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with attributes, options\n * @name beforeDefine\n */\n\n/**\n * A hook that is run after a define call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with factory\n * @name afterDefine\n */\n\n/**\n * A hook that is run before Sequelize() call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with config, options\n * @name beforeInit\n */\n\n/**\n * A hook that is run after Sequelize() call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with sequelize\n * @name afterInit\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run before a connection is created\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with config passed to connection\n * @name beforeConnect\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run after a connection is created\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with the connection object and thye config passed to connection\n * @name afterConnect\n * @memberOf Sequelize\n */\n\n/**\n * A hook that is run before Model.sync call\n * @param {String}   name\n * @param {Function} fn   A callback function that is called with options passed to Model.sync\n * @name beforeSync\n * @memberOf Sequelize\n */\n\n /**\n  * A hook that is run before a connection is created\n  * @param {String}   name\n  * @param {Function} fn   A callback function that is called with config passed to connection\n  * @name beforeConnect\n  */\n\n /**\n  * A hook that is run before Model.sync call\n  * @param {String}   name\n  * @param {Function} fn   A callback function that is called with options passed to Model.sync\n  * @name beforeSync\n  */\n\n /**\n  * A hook that is run after Model.sync call\n  * @param {String}   name\n  * @param {Function} fn   A callback function that is called with options passed to Model.sync\n  * @name afterSync\n  */\n\n  /**\n   * A hook that is run before sequelize.sync call\n   * @param {String}   name\n   * @param {Function} fn   A callback function that is called with options passed to sequelize.sync\n   * @name beforeBulkSync\n   */\n\n  /**\n   * A hook that is run after sequelize.sync call\n   * @param {String}   name\n   * @param {Function} fn   A callback function that is called with options passed to sequelize.sync\n   * @name afterBulkSync\n   */\n\nmodule.exports = {\n  hooks: hookTypes,\n  hookAliases: hookAliases,\n\n  applyTo: function(Model) {\n    Utils._.mixin(Model, Hooks);\n    Utils._.mixin(Model.prototype, Hooks);\n\n    var allHooks = Object.keys(hookTypes).concat(Object.keys(hookAliases));\n    allHooks.forEach(function(hook) {\n      Model.prototype[hook] = function(name, callback) {\n        return this.addHook(hook, name, callback);\n      };\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/mixin.js":"'use strict';\n\nvar Utils = require('./../utils')\n  , _ = require('lodash')\n  , HasOne = require('./has-one')\n  , HasMany = require('./has-many')\n  , BelongsToMany = require('./belongs-to-many')\n  , BelongsTo = require('./belongs-to');\n\n/**\n * Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).\n *\n * * hasOne - adds a foreign key to the target and singular association mixins to the source.\n * * belongsTo - add a foreign key and singular association mixins to the source.\n * * hasMany - adds a foreign key to target and plural association mixins to the source.\n * * belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId.\n *\n * Creating an association will add a foreign key constraint to the attributes. All associations use `CASCADE` on update and `SET NULL` on delete, except for n:m, which also uses `CASCADE` on delete.\n *\n * When creating associations, you can provide an alias, via the `as` option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model.\n *\n * As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a `userId`, but in addition the user model also has a `profilePictureId`, to be able to easily load the user's profile picture.\n *\n * ```js\n * User.hasMany(Picture)\n * User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false })\n *\n * user.getPictures() // gets you all pictures\n * user.getProfilePicture() // gets you only the profile picture\n *\n * User.findAll({\n *   where: ...,\n *   include: [\n *     { model: Picture }, // load all pictures\n *     { model: Picture, as: 'ProfilePicture' }, // load the profile picture. Notice that the spelling must be the exact same as the one in the association\n *   ]\n * })\n * ```\n * To get full control over the foreign key column added by sequelize, you can use the `foreignKey` option. It can either be a string, that specifies the name, or and object type definition,\n * equivalent to those passed to `sequelize.define`.\n *\n * ```js\n * User.hasMany(Picture, { foreignKey: 'uid' })\n * ```\n *\n * The foreign key column in Picture will now be called `uid` instead of the default `userId`.\n *\n * ```js\n * User.hasMany(Picture, {\n *   foreignKey: {\n *     name: 'uid',\n *     allowNull: false\n *   }\n * })\n * ```\n *\n * This specifies that the `uid` column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see `constraints: false` below).\n *\n * When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to `find`/`findAll`. To only get pictures in JPG, you can do:\n *\n * ```js\n * user.getPictures({\n *   where: {\n *     format: 'jpg'\n *   }\n * })\n * ```\n *\n * There are several ways to update and add new associations. Continuing with our example of users and pictures:\n * ```js\n * user.addPicture(p) // Add a single picture\n * user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted\n * user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations\n * ```\n *\n * You don't have to pass in a complete object to the association functions, if your associated model has a single primary key:\n *\n * ```js\n * user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture\n * ```\n *\n * In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.\n *\n * Note how we also specified `constraints: false` for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of `Error: Cyclic dependency found. 'users' is dependent of itself`. If you encounter this, you should either disable some constraints, or rethink your associations completely.\n *\n * @mixin Associations\n * @name Associations\n */\nvar Mixin = module.exports = function() {};\n\n// The logic for hasOne and belongsTo is exactly the same\nvar singleLinked = function (Type) {\n  return function(target, options) { // testhint options:none\n    if (!(target instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.' + Utils.lowercaseFirst(Type.toString()) + ' called with something that\\'s not an instance of Sequelize.Model');\n    }\n\n    var source = this;\n\n    // Since this is a mixin, we'll need a unique variable name for hooks (since Model will override our hooks option)\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    // the id is in the foreign table\n    var association = new Type(source, target, _.extend(options, source.options));\n    source.associations[association.associationAccessor] = association.injectAttributes();\n\n    if (association.mixin) {\n      association.mixin(source.Instance.prototype);\n    } else {\n      association.injectGetter(source.Instance.prototype);\n      association.injectSetter(source.Instance.prototype);\n      association.injectCreator(source.Instance.prototype);\n    }\n\n    return association;\n  };\n};\n/**\n * Creates an association between this (the source) and the provided target. The foreign key is added on the target.\n *\n * Example: `User.hasOne(Profile)`. This will add userId to the profile table.\n *\n * @method hasOne\n * @param {Model}           target\n * @param {object}          [options]\n * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target\n * @param {string|object}   [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n * @param {string}          [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise\n * @param {string}          [options.onUpdate='CASCADE']\n * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n */\nMixin.hasOne = singleLinked(HasOne);\n\n/**\n * Creates an association between this (the source) and the provided target. The foreign key is added on the source.\n *\n * Example: `Profile.belongsTo(User)`. This will add userId to the profile table.\n *\n * @method belongsTo\n * @param {Model}           target\n * @param {object}          [options]\n * @param {boolean}         [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n * @param {string}          [options.as] The alias of this model, in singular form. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target\n * @param {string|object}   [options.foreignKey] The name of the foreign key in the source table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target\n * @param {string}          [options.targetKey] The name of the field to use as the key for the association in the target table. Defaults to the primary key of the target table\n * @param {string}          [options.onDelete='SET&nbsp;NULL|NO&nbsp;ACTION'] SET NULL if foreignKey allows nulls, NO ACTION if otherwise\n * @param {string}          [options.onUpdate='CASCADE']\n * @param {boolean}         [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n */\nMixin.belongsTo = singleLinked(BelongsTo);\n\n/**\n * Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.\n *\n * Example: `User.hasMany(Profile)`. This will add userId to the profile table.\n *\n * @param {Model}               target\n * @param {object}              [options]\n * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n * @param {string|object}       [options.as] The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target\n * @param {string|object}       [options.foreignKey] The name of the foreign key in the target table or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n * @param {string}              [options.sourceKey] The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table\n * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)\n * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] SET NULL if foreignKey allows nulls, CASCADE if otherwise\n * @param {string}              [options.onUpdate='CASCADE']\n * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n */\nMixin.hasMany = function(target, options) { // testhint options:none\n  if (!(target instanceof this.sequelize.Model)) {\n    throw new Error(this.name + '.hasMany called with something that\\'s not an instance of Sequelize.Model');\n  }\n\n  var source = this;\n\n  // Since this is a mixin, we'll need a unique variable name for hooks (since Model will override our hooks option)\n  options = options || {};\n  options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n  options.useHooks = options.hooks;\n\n  options = _.extend(options, _.omit(source.options, ['hooks']));\n\n  // the id is in the foreign table or in a connecting table\n  var association = new HasMany(source, target, options);\n  source.associations[association.associationAccessor] = association;\n\n  association.injectAttributes();\n  association.mixin(source.Instance.prototype);\n\n  return association;\n};\n\n/**\n * Create an N:M association with a join table.\n *\n * ```js\n * User.belongsToMany(Project, { through: 'UserProjects' })\n * Project.belongsToMany(User, { through: 'UserProjects' })\n * ```\n * Defining `through` is required. Sequelize would previously attempt to auto generate names but that would not always lead to the most logical setups.\n *\n * If you define a through model with custom attributes, these attributes can be set when adding / setting new associations in two ways. Consider users and projects from before with a join table that stores whether the project has been started yet:\n * ```js\n * var UserProjects = sequelize.define('UserProjects', {\n *   started: Sequelize.BOOLEAN\n * })\n * User.belongsToMany(Project, { through: UserProjects })\n * Project.belongsToMany(User, { through: UserProjects })\n * ```\n * ```js\n * jan.addProject(homework, { started: false }) // The homework project is not started yet\n * jan.setProjects([makedinner, doshopping], { started: true}) // Both shopping and dinner has been started\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], {started: false}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(function (projects) {\n *   var p1 = projects[0]\n *   p1.UserProjects.started // Is this project started yet?\n * })\n * ```\n *\n * @param {Model}               target\n * @param {object}              [options]\n * @param {boolean}             [options.hooks=false] Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if `User.hasOne(Profile, {onDelete: 'cascade', hooks:true})`, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks\n * @param {Model|string|object} [options.through] The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.\n * @param {Model}               [options.through.model] The model used to join both sides of the N:M association.\n * @param {object}              [options.through.scope] A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model)\n * @param {boolean}             [options.through.unique=true] If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)\n * @param {string|object}       [options.as] The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with `plural` and `singular` keys. See also the `name` option passed to `sequelize.define`. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target\n * @param {string|object}       [options.foreignKey] The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of source + primary key of source\n * @param {string|object}       [options.otherKey] The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see `Sequelize.define` for syntax). When using an object, you can add a `name` property to set the name of the column. Defaults to the name of target + primary key of target\n * @param {object}              [options.scope] A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M)\n * @param {boolean}             [options.timestamps=sequelize.options.timestamps] Should the join model have timestamps\n * @param {string}              [options.onDelete='SET&nbsp;NULL|CASCADE'] Cascade if this is a n:m, and set null if it is a 1:m\n * @param {string}              [options.onUpdate='CASCADE']\n * @param {boolean}             [options.constraints=true] Should on update and on delete constraints be enabled on the foreign key.\n */\nMixin.belongsToMany = function(targetModel, options) { // testhint options:none\n  if (!(targetModel instanceof this.sequelize.Model)) {\n    throw new Error(this.name + '.belongsToMany called with something that\\'s not an instance of Sequelize.Model');\n  }\n\n  var sourceModel = this;\n\n  // Since this is a mixin, we'll need a unique variable name for hooks (since Model will override our hooks option)\n  options = options || {};\n  options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n  options.useHooks = options.hooks;\n  options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n  options = _.extend(options, _.omit(sourceModel.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n  // the id is in the foreign table or in a connecting table\n  var association = new BelongsToMany(sourceModel, targetModel, options);\n  sourceModel.associations[association.associationAccessor] = association.injectAttributes();\n\n  association.injectGetter(sourceModel.Instance.prototype);\n  association.injectSetter(sourceModel.Instance.prototype);\n  association.injectCreator(sourceModel.Instance.prototype);\n\n  return association;\n};\n\nMixin.getAssociation = function(target, alias) {\n  for (var associationName in this.associations) {\n    if (this.associations.hasOwnProperty(associationName)) {\n      var association = this.associations[associationName];\n\n      if (association.target.name === target.name && (alias === undefined ? !association.isAliased : association.as === alias)) {\n        return association;\n      }\n    }\n  }\n\n  return null;\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/deferrable.js":"'use strict';\n\nvar util = require('util');\n\n\n/**\n * A collection of properties related to deferrable constraints. It can be used to\n * make foreign key constraints deferrable and to set the constraints within a\n * transaction. This is only supported in PostgreSQL.\n *\n * The foreign keys can be configured like this. It will create a foreign key\n * that will check the constraints immediately when the data was inserted.\n *\n * ```js\n * sequelize.define('Model', {\n *   foreign_id: {\n *     type: Sequelize.INTEGER,\n *     references: {\n *       model: OtherModel,\n *       key: 'id',\n *       deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE\n *     }\n *   }\n * });\n * ```\n *\n * The constraints can be configured in a transaction like this. It will\n * trigger a query once the transaction has been started and set the constraints\n * to be checked at the very end of the transaction.\n *\n * ```js\n * sequelize.transaction({\n *   deferrable: Sequelize.Deferrable.SET_DEFERRED\n * });\n * ```\n *\n * @return {object}\n */\nvar Deferrable = module.exports = {\n  INITIALLY_DEFERRED: INITIALLY_DEFERRED,\n  INITIALLY_IMMEDIATE: INITIALLY_IMMEDIATE,\n  NOT: NOT,\n  SET_DEFERRED: SET_DEFERRED,\n  SET_IMMEDIATE: SET_IMMEDIATE\n};\n\nfunction ABSTRACT () {}\n\nABSTRACT.prototype.toString = function () {\n  return this.toSql.apply(this, arguments);\n};\n\n\n/**\n * A property that will defer constraints checks to the end of transactions.\n *\n * @property INITIALLY_DEFERRED\n */\nfunction INITIALLY_DEFERRED () {\n  if (!(this instanceof INITIALLY_DEFERRED)) {\n    return new INITIALLY_DEFERRED();\n  }\n}\nutil.inherits(INITIALLY_DEFERRED, ABSTRACT);\n\nINITIALLY_DEFERRED.prototype.toSql = function () {\n  return 'DEFERRABLE INITIALLY DEFERRED';\n};\n\n\n/**\n * A property that will trigger the constraint checks immediately\n *\n * @property INITIALLY_IMMEDIATE\n */\nfunction INITIALLY_IMMEDIATE () {\n  if (!(this instanceof INITIALLY_IMMEDIATE)) {\n    return new INITIALLY_IMMEDIATE();\n  }\n}\nutil.inherits(INITIALLY_IMMEDIATE, ABSTRACT);\n\nINITIALLY_IMMEDIATE.prototype.toSql = function () {\n  return 'DEFERRABLE INITIALLY IMMEDIATE';\n};\n\n\n/**\n * A property that will set the constraints to not deferred. This is\n * the default in PostgreSQL and it make it impossible to dynamically\n * defer the constraints within a transaction.\n *\n * @property NOT\n */\nfunction NOT () {\n  if (!(this instanceof NOT)) {\n    return new NOT();\n  }\n}\nutil.inherits(NOT, ABSTRACT);\n\nNOT.prototype.toSql = function () {\n  return 'NOT DEFERRABLE';\n};\n\n\n/**\n * A property that will trigger an additional query at the beginning of a\n * transaction which sets the constraints to deferred.\n *\n * @param  {Array} constraints An array of constraint names. Will defer all constraints by default.\n * @property SET_DEFERRED\n */\nfunction SET_DEFERRED (constraints) {\n  if (!(this instanceof SET_DEFERRED)) {\n    return new SET_DEFERRED(constraints);\n  }\n\n  this.constraints = constraints;\n}\nutil.inherits(SET_DEFERRED, ABSTRACT);\n\nSET_DEFERRED.prototype.toSql = function (queryGenerator) {\n  return queryGenerator.setDeferredQuery(this.constraints);\n};\n\n\n/**\n * A property that will trigger an additional query at the beginning of a\n * transaction which sets the constraints to immediately.\n *\n * @param  {Array} constraints An array of constraint names. Will defer all constraints by default.\n * @property SET_IMMEDIATE\n */\nfunction SET_IMMEDIATE (constraints) {\n  if (!(this instanceof SET_IMMEDIATE)) {\n    return new SET_IMMEDIATE(constraints);\n  }\n\n  this.constraints = constraints;\n}\nutil.inherits(SET_IMMEDIATE, ABSTRACT);\n\nSET_IMMEDIATE.prototype.toSql = function (queryGenerator) {\n  return queryGenerator.setImmediateQuery(this.constraints);\n};\n\nObject.keys(Deferrable).forEach(function (key) {\n  var DeferrableType = Deferrable[key];\n\n  DeferrableType.toString = function () {\n    var instance = new DeferrableType();\n    return instance.toString.apply(instance, arguments);\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/model-manager.js":"'use strict';\n\nvar Toposort = require('toposort-class')\n  , Utils = require('./utils')\n  , _ = require('lodash');\n\nvar ModelManager = function(sequelize) {\n  this.models = [];\n  this.sequelize = sequelize;\n};\n\nModelManager.prototype.addModel = function(model) {\n  this.models.push(model);\n  this.sequelize.models[model.name] = model;\n\n  return model;\n};\n\nModelManager.prototype.removeModel = function(model) {\n  this.models = this.models.filter(function($model) {\n    return $model.name !== model.name;\n  });\n\n  delete this.sequelize.models[model.name];\n};\n\nModelManager.prototype.getModel = function(against, options) {\n  options = _.defaults(options || {}, {\n    attribute: 'name'\n  });\n\n  var model = this.models.filter(function(model) {\n    return model[options.attribute] === against;\n  });\n\n  return !!model ? model[0] : null;\n};\n\nModelManager.prototype.__defineGetter__('all', function() {\n  return this.models;\n});\n\n/**\n * Iterate over Models in an order suitable for e.g. creating tables. Will\n * take foreign key constraints into account so that dependencies are visited\n * before dependents.\n */\nModelManager.prototype.forEachModel = function(iterator, options) {\n  var models = {}\n    , sorter = new Toposort()\n    , sorted\n    , dep;\n\n  options = _.defaults(options || {}, {\n    reverse: true\n  });\n\n  this.models.forEach(function(model) {\n    var deps = []\n      , tableName = model.getTableName();\n\n    if (_.isObject(tableName)) {\n      tableName = tableName.schema + '.' + tableName.tableName;\n    }\n\n    models[tableName] = model;\n\n    for (var attrName in model.rawAttributes) {\n      if (model.rawAttributes.hasOwnProperty(attrName)) {\n        var attribute = model.rawAttributes[attrName];\n\n        if (attribute.references) {\n          attribute = Utils.formatReferences(attribute);\n          dep       = attribute.references.model;\n\n          if (_.isObject(dep)) {\n            dep = dep.schema + '.' + dep.tableName;\n          }\n\n          deps.push(dep);\n        }\n      }\n    }\n\n    deps = deps.filter(function(dep) {\n      return tableName !== dep;\n    });\n\n    sorter.add(tableName, deps);\n  });\n\n  sorted = sorter.sort();\n  if (options.reverse) {\n    sorted = sorted.reverse();\n  }\n  sorted.forEach(function(name) {\n    iterator(models[name], name);\n  });\n};\n\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports.default = ModelManager;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/query-interface.js":"'use strict';\n\nvar Utils = require('./utils')\n  , _ = require('lodash')\n  , DataTypes = require('./data-types')\n  , SQLiteQueryInterface = require('./dialects/sqlite/query-interface')\n  , MSSSQLQueryInterface = require('./dialects/mssql/query-interface')\n  , MySQLQueryInterface = require('./dialects/mysql/query-interface')\n  , Transaction = require('./transaction')\n  , Promise = require('./promise')\n  , QueryTypes = require('./query-types');\n\n/*\n * The interface that Sequelize uses to talk to all databases\n * @class QueryInterface\n**/\nvar QueryInterface = function(sequelize) {\n  this.sequelize = sequelize;\n  this.QueryGenerator = this.sequelize.dialect.QueryGenerator;\n};\n\nQueryInterface.prototype.createSchema = function(schema, options) {\n  options = options || {};\n  var sql = this.QueryGenerator.createSchema(schema);\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.dropSchema = function(schema, options) {\n  options = options || {};\n  var sql = this.QueryGenerator.dropSchema(schema);\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.dropAllSchemas = function(options) {\n  options = options || {};\n\n  var self = this;\n  if (!this.QueryGenerator._dialect.supports.schemas) {\n    return this.sequelize.drop(options);\n  } else {\n    return this.showAllSchemas(options).map(function(schemaName) {\n      return self.dropSchema(schemaName, options);\n    });\n  }\n};\n\nQueryInterface.prototype.showAllSchemas = function(options) {\n  var self = this;\n\n  options = _.assign({}, options, {\n    raw: true,\n    type: this.sequelize.QueryTypes.SELECT\n  });\n\n  var showSchemasSql = self.QueryGenerator.showSchemasQuery();\n\n  return this.sequelize.query(showSchemasSql, options).then(function(schemaNames) {\n    return Utils._.flatten(\n      Utils._.map(schemaNames, function(value) {\n        return (!!value.schema_name ? value.schema_name : value);\n      })\n    );\n  });\n};\n\nQueryInterface.prototype.databaseVersion = function(options) {\n  return this.sequelize.query(\n    this.QueryGenerator.versionQuery(),\n    _.assign({}, options, { type: QueryTypes.VERSION })\n  );\n};\n\nQueryInterface.prototype.createTable = function(tableName, attributes, options, model) {\n  var keys = Object.keys(attributes)\n    , keyLen = keys.length\n    , self = this\n    , sql = ''\n    , i = 0;\n\n  options = _.clone(options) || {};\n\n  attributes = Utils._.mapValues(attributes, function(attribute) {\n    if (!Utils._.isPlainObject(attribute)) {\n      attribute = { type: attribute, allowNull: true };\n    }\n\n    attribute = self.sequelize.normalizeAttribute(attribute);\n\n    return attribute;\n  });\n\n  // Postgres requires a special SQL command for enums\n  if (self.sequelize.options.dialect === 'postgres') {\n    var promises = [];\n\n    for (i = 0; i < keyLen; i++) {\n      if (attributes[keys[i]].type instanceof DataTypes.ENUM) {\n        sql = self.QueryGenerator.pgListEnums(tableName, attributes[keys[i]].field || keys[i], options);\n        promises.push(self.sequelize.query(\n          sql,\n          _.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })\n        ));\n      }\n    }\n\n    return Promise.all(promises).then(function(results) {\n      var promises = []\n        , enumIdx = 0;\n\n      for (i = 0; i < keyLen; i++) {\n        if (attributes[keys[i]].type instanceof DataTypes.ENUM) {\n          // If the enum type doesn't exist then create it\n          if (!results[enumIdx]) {\n            sql = self.QueryGenerator.pgEnum(tableName, attributes[keys[i]].field || keys[i], attributes[keys[i]], options);\n            promises.push(self.sequelize.query(\n              sql,\n              _.assign({}, options, { raw: true })\n            ));\n          } else if (!!results[enumIdx] && !!model) {\n            var enumVals = self.QueryGenerator.fromArray(results[enumIdx].enum_value)\n              , vals = model.rawAttributes[keys[i]].values;\n\n            vals.forEach(function(value, idx) {\n              // reset out after/before options since it's for every enum value\n              var valueOptions = _.clone(options);\n              valueOptions.before = null;\n              valueOptions.after = null;\n\n              if (enumVals.indexOf(value) === -1) {\n                if (!!vals[idx + 1]) {\n                  valueOptions.before = vals[idx + 1];\n                }\n                else if (!!vals[idx - 1]) {\n                  valueOptions.after = vals[idx - 1];\n                }\n                valueOptions.supportsSearchPath = false;\n                promises.push(self.sequelize.query(self.QueryGenerator.pgEnumAdd(tableName, keys[i], value, valueOptions), valueOptions));\n              }\n            });\n            enumIdx++;\n          }\n        }\n      }\n\n      if (!tableName.schema &&\n        (options.schema || (!!model && model.$schema))) {\n        tableName = self.QueryGenerator.addSchema({\n          tableName: tableName,\n          $schema: (!!model && model.$schema) || options.schema\n        });\n      }\n\n      attributes = self.QueryGenerator.attributesToSQL(attributes, {\n        context: 'createTable'\n      });\n      sql = self.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n      return Promise.all(promises).then(function() {\n        return self.sequelize.query(sql, options);\n      });\n    });\n  } else {\n    if (!tableName.schema &&\n      (options.schema || (!!model && model.$schema))) {\n      tableName = self.QueryGenerator.addSchema({\n        tableName: tableName,\n        $schema: (!!model && model.$schema) || options.schema\n      });\n    }\n\n    attributes = self.QueryGenerator.attributesToSQL(attributes, {\n      context: 'createTable'\n    });\n    sql = self.QueryGenerator.createTableQuery(tableName, attributes, options);\n\n    return self.sequelize.query(sql, options);\n  }\n};\n\nQueryInterface.prototype.dropTable = function(tableName, options) {\n  // if we're forcing we should be cascading unless explicitly stated otherwise\n  options = _.clone(options) || {};\n  options.cascade = options.cascade || options.force || false;\n\n  var sql = this.QueryGenerator.dropTableQuery(tableName, options)\n    , self = this;\n\n  return this.sequelize.query(sql, options).then(function() {\n    var promises = [];\n\n    // Since postgres has a special case for enums, we should drop the related\n    // enum type within the table and attribute\n    if (self.sequelize.options.dialect === 'postgres') {\n      var instanceTable = self.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n      if (!!instanceTable) {\n        var getTableName = (!options || !options.schema || options.schema === 'public' ? '' : options.schema + '_') + tableName;\n\n        var keys = Object.keys(instanceTable.rawAttributes)\n          , keyLen = keys.length\n          , i = 0;\n\n        for (i = 0; i < keyLen; i++) {\n          if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n            sql = self.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n            options.supportsSearchPath = false;\n            promises.push(self.sequelize.query(sql, _.assign({}, options, { raw: true })));\n          }\n        }\n      }\n    }\n\n    return Promise.all(promises).get(0);\n  });\n};\n\nQueryInterface.prototype.dropAllTables = function(options) {\n  var self = this\n    , skip;\n\n  options = options || {};\n  skip = options.skip || [];\n\n  var dropAllTables = function(tableNames) {\n    return Promise.each(tableNames, function(tableName) {\n      // if tableName is not in the Array of tables names then dont drop it\n      if (skip.indexOf(tableName.tableName || tableName) === -1) {\n        return self.dropTable(tableName, _.assign({}, options, { cascade: true }) );\n      }\n    });\n  };\n\n  return self.showAllTables(options).then(function(tableNames) {\n    if (self.sequelize.options.dialect === 'sqlite') {\n      return self.sequelize.query('PRAGMA foreign_keys;', options).then(function(result) {\n        var foreignKeysAreEnabled = result.foreign_keys === 1;\n\n        if (foreignKeysAreEnabled) {\n          return self.sequelize.query('PRAGMA foreign_keys = OFF', options).then(function() {\n            return dropAllTables(tableNames).then(function() {\n              return self.sequelize.query('PRAGMA foreign_keys = ON', options);\n            });\n          });\n        } else {\n          return dropAllTables(tableNames);\n        }\n      });\n    } else {\n      return self.getForeignKeysForTables(tableNames, options).then(function(foreignKeys) {\n        var promises = [];\n\n        tableNames.forEach(function(tableName) {\n          var normalizedTableName = tableName;\n          if (Utils._.isObject(tableName)) {\n             normalizedTableName = tableName.schema + '.' + tableName.tableName;\n          }\n\n          foreignKeys[normalizedTableName].forEach(function(foreignKey) {\n            var sql = self.QueryGenerator.dropForeignKeyQuery(tableName, foreignKey);\n            promises.push(self.sequelize.query(sql, options));\n          });\n        });\n\n        return Promise.all(promises).then(function() {\n          return dropAllTables(tableNames);\n        });\n      });\n    }\n  });\n};\n\nQueryInterface.prototype.dropAllEnums = function(options) {\n  if (this.sequelize.getDialect() !== 'postgres') {\n    return Promise.resolve();\n  }\n\n  options = options || {};\n\n  var self = this;\n\n  return this.pgListEnums(null, options).map(function(result) {\n    return self.sequelize.query(\n      self.QueryGenerator.pgEnumDrop(null, null, self.QueryGenerator.pgEscapeAndQuote(result.enum_name)),\n      _.assign({}, options, { raw: true })\n    );\n  });\n};\n\nQueryInterface.prototype.pgListEnums = function (tableName, options) {\n  options = options || {};\n  var sql = this.QueryGenerator.pgListEnums(tableName);\n  return this.sequelize.query(sql, _.assign({}, options, { plain: false, raw: true, type: QueryTypes.SELECT }));\n};\n\nQueryInterface.prototype.renameTable = function(before, after, options) {\n  options = options || {};\n  var sql = this.QueryGenerator.renameTableQuery(before, after);\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.showAllTables = function(options) {\n  var self = this;\n  options = _.assign({}, options, {\n    raw: true,\n    type: QueryTypes.SHOWTABLES\n  });\n\n  var showTablesSql = self.QueryGenerator.showTablesQuery();\n  return self.sequelize.query(showTablesSql, options).then(function(tableNames) {\n    return Utils._.flatten(tableNames);\n  });\n};\n\nQueryInterface.prototype.describeTable = function(tableName, options) {\n  var schema = null\n    , schemaDelimiter = null;\n\n  if (typeof options === 'string') {\n    schema = options;\n  } else if (typeof options === 'object' && options !== null) {\n    schema = options.schema || null;\n    schemaDelimiter = options.schemaDelimiter || null;\n  }\n\n  if (typeof tableName === 'object' && tableName !== null) {\n    schema = tableName.schema;\n    tableName = tableName.tableName;\n  }\n\n  var sql = this.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n\n  return this.sequelize.query(\n    sql,\n    _.assign({}, options, { type: QueryTypes.DESCRIBE })\n  ).then(function(data) {\n    // If no data is returned from the query, then the table name may be wrong.\n    // Query generators that use information_schema for retrieving table info will just return an empty result set,\n    // it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n    if (Utils._.isEmpty(data)) {\n      return Promise.reject('No description found for \"' + tableName + '\" table. Check the table name and schema; remember, they _are_ case sensitive.');\n    } else {\n      return Promise.resolve(data);\n    }\n  });\n};\n\nQueryInterface.prototype.addColumn = function(table, key, attribute, options) {\n  if (!table || !key || !attribute) {\n    throw new Error('addColumn takes atleast 3 arguments (table, attribute name, attribute definition)');\n  }\n\n  options = options || {};\n  attribute = this.sequelize.normalizeAttribute(attribute);\n  return this.sequelize.query(this.QueryGenerator.addColumnQuery(table, key, attribute), options);\n};\n\nQueryInterface.prototype.removeColumn = function(tableName, attributeName, options) {\n  options = options || {};\n  switch (this.sequelize.options.dialect) {\n    case 'sqlite':\n      // sqlite needs some special treatment as it cannot drop a column\n      return SQLiteQueryInterface.removeColumn.call(this, tableName, attributeName, options);\n    case 'mssql':\n      // mssql needs special treatment as it cannot drop a column with a default or foreign key constraint\n      return MSSSQLQueryInterface.removeColumn.call(this, tableName, attributeName, options);\n    case 'mysql':\n    case 'mariadb':\n      // mysql/maria needs special treatment as it cannot drop a column with a foreign key constraint\n      return MySQLQueryInterface.removeColumn.call(this, tableName, attributeName, options);\n    default:\n        var sql = this.QueryGenerator.removeColumnQuery(tableName, attributeName);\n        return this.sequelize.query(sql, options);\n  }\n};\n\nQueryInterface.prototype.changeColumn = function(tableName, attributeName, dataTypeOrOptions, options) {\n  var attributes = {};\n  options = options || {};\n\n  if (Utils._.values(DataTypes).indexOf(dataTypeOrOptions) > -1) {\n    attributes[attributeName] = { type: dataTypeOrOptions, allowNull: true };\n  } else {\n    attributes[attributeName] = dataTypeOrOptions;\n  }\n\n  attributes[attributeName].type = this.sequelize.normalizeDataType(attributes[attributeName].type);\n\n  if (this.sequelize.options.dialect === 'sqlite') {\n    // sqlite needs some special treatment as it cannot change a column\n    return SQLiteQueryInterface.changeColumn.call(this, tableName, attributes, options);\n  } else {\n    var query = this.QueryGenerator.attributesToSQL(attributes)\n      , sql = this.QueryGenerator.changeColumnQuery(tableName, query);\n\n    return this.sequelize.query(sql, options);\n  }\n};\n\nQueryInterface.prototype.renameColumn = function(tableName, attrNameBefore, attrNameAfter, options) {\n  options = options || {};\n  return this.describeTable(tableName, options).then(function(data) {\n    data = data[attrNameBefore] || {};\n\n    var _options = {};\n\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n\n    // fix: a not-null column cannot have null as default value\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n\n    if (this.sequelize.options.dialect === 'sqlite') {\n      // sqlite needs some special treatment as it cannot rename a column\n      return SQLiteQueryInterface.renameColumn.call(this, tableName, attrNameBefore, attrNameAfter, options);\n    } else {\n      var sql = this.QueryGenerator.renameColumnQuery(\n        tableName,\n        attrNameBefore,\n        this.QueryGenerator.attributesToSQL(_options)\n      );\n      return this.sequelize.query(sql, options);\n    }\n  }.bind(this));\n};\n\nQueryInterface.prototype.addIndex = function(tableName, attributes, options, rawTablename) {\n  // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n  if (!Array.isArray(attributes)) {\n    rawTablename = options;\n    options = attributes;\n    attributes = options.fields;\n  }\n  // testhint argsConform.end\n\n  if (!rawTablename) {\n    // Map for backwards compat\n    rawTablename = tableName;\n  }\n\n  options = Utils.cloneDeep(options);\n  options.fields = attributes;\n  var sql = this.QueryGenerator.addIndexQuery(tableName, options, rawTablename);\n  return this.sequelize.query(sql, _.assign({}, options, { supportsSearchPath: false }));\n};\n\nQueryInterface.prototype.showIndex = function(tableName, options) {\n  var sql = this.QueryGenerator.showIndexesQuery(tableName, options);\n  return this.sequelize.query(sql, _.assign({}, options, { type: QueryTypes.SHOWINDEXES }));\n};\n\nQueryInterface.prototype.nameIndexes = function(indexes, rawTablename) {\n  return this.QueryGenerator.nameIndexes(indexes, rawTablename);\n};\n\nQueryInterface.prototype.getForeignKeysForTables = function(tableNames, options) {\n  var self = this;\n  options = options || {};\n\n  if (tableNames.length === 0) {\n    return Promise.resolve({});\n  }\n\n  return Promise.map(tableNames, function(tableName) {\n    return self.sequelize.query(self.QueryGenerator.getForeignKeysQuery(tableName, self.sequelize.config.database), options).get(0);\n  }).then(function(results) {\n    var result = {};\n\n    tableNames.forEach(function(tableName, i) {\n      if (Utils._.isObject(tableName)) {\n        tableName = tableName.schema + '.' + tableName.tableName;\n      }\n\n      result[tableName] = Utils._.compact(results[i]).map(function(r) {\n        return r.constraint_name;\n      });\n    });\n\n    return result;\n  });\n};\n\nQueryInterface.prototype.removeIndex = function(tableName, indexNameOrAttributes, options) {\n  options = options || {};\n  var sql = this.QueryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.insert = function(instance, tableName, values, options) {\n  options = Utils.cloneDeep(options);\n  options.hasTrigger = instance && instance.Model.options.hasTrigger;\n  var sql = this.QueryGenerator.insertQuery(tableName, values, instance && instance.Model.rawAttributes, options);\n\n  options.type = QueryTypes.INSERT;\n  options.instance = instance;\n\n  return this.sequelize.query(sql, options).then(function(result) {\n    if (instance) result.isNewRecord = false;\n    return result;\n  });\n};\n\nQueryInterface.prototype.upsert = function(tableName, valuesByField, updateValues, where, model, options) {\n  var wheres = []\n    , indexFields\n    , indexes = []\n    , attributes = Object.keys(valuesByField);\n\n  options = _.clone(options);\n\n  if (!Utils._.isEmpty(where)) {\n    wheres.push(where);\n  }\n\n  // Lets combine uniquekeys and indexes into one\n  indexes = Utils._.map(model.options.uniqueKeys, function (value) {\n    return value.fields;\n  });\n\n  Utils._.each(model.options.indexes, function (value) {\n    if (value.unique === true) {\n      // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n      indexFields = Utils._.map(value.fields, function (field) {\n        if (Utils._.isPlainObject(field)) {\n          return field.attribute;\n        }\n        return field;\n      });\n      indexes.push(indexFields);\n    }\n  });\n\n  indexes.forEach(function (index) {\n    if (Utils._.intersection(attributes, index).length === index.length) {\n      where = {};\n      index.forEach(function (field) {\n        where[field] = valuesByField[field];\n      });\n      wheres.push(where);\n    }\n  });\n\n  where = { $or: wheres };\n\n  options.type = QueryTypes.UPSERT;\n  options.raw = true;\n\n  var sql = this.QueryGenerator.upsertQuery(tableName, valuesByField, updateValues, where, model.rawAttributes, options);\n  return this.sequelize.query(sql, options).then(function (rowCount) {\n    if (rowCount === undefined) {\n      return rowCount;\n    }\n\n    // MySQL returns 1 for inserted, 2 for updated http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html. Postgres has been modded to do the same\n\n    return rowCount === 1;\n  });\n};\n\nQueryInterface.prototype.bulkInsert = function(tableName, records, options, attributes) {\n  options = _.clone(options) || {};\n  options.type = QueryTypes.INSERT;\n  var sql = this.QueryGenerator.bulkInsertQuery(tableName, records, options, attributes);\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.update = function(instance, tableName, values, identifier, options) {\n  options = _.clone(options || {});\n  options.hasTrigger = !!(instance && instance.$modelOptions && instance.$modelOptions.hasTrigger);\n\n\n  var self = this\n    , restrict = false\n    , sql = self.QueryGenerator.updateQuery(tableName, values, identifier, options, instance.Model.rawAttributes);\n\n\n  options.type = QueryTypes.UPDATE;\n\n  // Check for a restrict field\n  if (!!instance.Model && !!instance.Model.associations) {\n    var keys = Object.keys(instance.Model.associations)\n      , length = keys.length;\n\n    for (var i = 0; i < length; i++) {\n      if (instance.Model.associations[keys[i]].options && instance.Model.associations[keys[i]].options.onUpdate && instance.Model.associations[keys[i]].options.onUpdate === 'restrict') {\n        restrict = true;\n      }\n    }\n  }\n\n  options.instance = instance;\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.bulkUpdate = function(tableName, values, identifier, options, attributes) {\n  options = Utils.cloneDeep(options);\n  if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n  var sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, attributes)\n    , table = Utils._.isObject(tableName) ? tableName : { tableName: tableName }\n    , model = Utils._.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n  options.model = model;\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.delete = function(instance, tableName, identifier, options) {\n  var self = this\n    , cascades = []\n    , sql = self.QueryGenerator.deleteQuery(tableName, identifier, null, instance.Model);\n\n  options = _.clone(options) || {};\n\n  // Check for a restrict field\n  if (!!instance.Model && !!instance.Model.associations) {\n    var keys = Object.keys(instance.Model.associations)\n      , length = keys.length\n      , association;\n\n    for (var i = 0; i < length; i++) {\n      association = instance.Model.associations[keys[i]];\n      if (association.options && association.options.onDelete &&\n        association.options.onDelete.toLowerCase() === 'cascade' &&\n        association.options.useHooks === true) {\n        cascades.push(association.accessors.get);\n      }\n    }\n  }\n\n  return Promise.each(cascades, function (cascade) {\n    return instance[cascade](options).then(function (instances) {\n      // Check for hasOne relationship with non-existing associate (\"has zero\")\n      if (!instances) {\n        return Promise.resolve();\n      }\n\n      if (!Array.isArray(instances)) instances = [instances];\n\n      return Promise.each(instances, function (instance) {\n        return instance.destroy(options);\n      });\n    });\n  }).then(function () {\n    options.instance = instance;\n    return self.sequelize.query(sql, options);\n  });\n};\n\nQueryInterface.prototype.bulkDelete = function(tableName, identifier, options, model) {\n  options = Utils.cloneDeep(options);\n  options = _.defaults(options, {limit: null});\n  if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n  var sql = this.QueryGenerator.deleteQuery(tableName, identifier, options, model);\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.select = function(model, tableName, options) {\n  options = Utils.cloneDeep(options);\n  options.type = QueryTypes.SELECT;\n  options.model = model;\n\n  return this.sequelize.query(\n    this.QueryGenerator.selectQuery(tableName, options, model),\n    options\n  );\n};\n\nQueryInterface.prototype.increment = function(instance, tableName, values, identifier, options) {\n  var sql = this.QueryGenerator.incrementQuery(tableName, values, identifier, options.attributes);\n\n  options = _.clone(options) || {};\n\n  options.type = QueryTypes.UPDATE;\n  options.instance = instance;\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.rawSelect = function(tableName, options, attributeSelector, Model) {\n  if (options.schema) {\n    tableName = this.QueryGenerator.addSchema({\n      tableName: tableName,\n      $schema: options.schema\n    });\n  }\n\n  options = Utils.cloneDeep(options);\n  options = _.defaults(options, {\n    raw: true,\n    plain: true,\n    type: QueryTypes.SELECT\n  });\n\n  var sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n  if (attributeSelector === undefined) {\n    throw new Error('Please pass an attribute selector!');\n  }\n\n  return this.sequelize.query(sql, options).then(function(data) {\n    if (!options.plain) {\n      return data;\n    }\n\n    var result = data ? data[attributeSelector] : null;\n\n    if (options && options.dataType) {\n      var dataType = options.dataType;\n\n      if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n        result = parseFloat(result);\n      } else if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n        result = parseInt(result, 10);\n      } else if (dataType instanceof DataTypes.DATE) {\n        if (!Utils._.isNull(result) && !Utils._.isDate(result)) {\n          result = new Date(result);\n        }\n      } else if (dataType instanceof DataTypes.STRING) {\n        // Nothing to do, result is already a string.\n      }\n    }\n\n    return result;\n  });\n};\n\nQueryInterface.prototype.createTrigger = function(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n  var sql = this.QueryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n  options = options || {};\n  if (sql) {\n    return this.sequelize.query(sql, options);\n  } else {\n    return Promise.resolve();\n  }\n};\n\nQueryInterface.prototype.dropTrigger = function(tableName, triggerName, options) {\n  var sql = this.QueryGenerator.dropTrigger(tableName, triggerName);\n  options = options || {};\n\n  if (sql) {\n    return this.sequelize.query(sql, options);\n  } else {\n    return Promise.resolve();\n  }\n};\n\nQueryInterface.prototype.renameTrigger = function(tableName, oldTriggerName, newTriggerName, options) {\n  var sql = this.QueryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n  options = options || {};\n\n  if (sql) {\n    return this.sequelize.query(sql, options);\n  } else {\n    return Promise.resolve();\n  }\n};\n\nQueryInterface.prototype.createFunction = function(functionName, params, returnType, language, body, options) {\n  var sql = this.QueryGenerator.createFunction(functionName, params, returnType, language, body, options);\n  options = options || {};\n\n  if (sql) {\n    return this.sequelize.query(sql, options);\n  } else {\n    return Promise.resolve();\n  }\n};\n\nQueryInterface.prototype.dropFunction = function(functionName, params, options) {\n  var sql = this.QueryGenerator.dropFunction(functionName, params);\n  options = options || {};\n\n  if (sql) {\n    return this.sequelize.query(sql, options);\n  } else {\n    return Promise.resolve();\n  }\n};\n\nQueryInterface.prototype.renameFunction = function(oldFunctionName, params, newFunctionName, options) {\n  var sql = this.QueryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n  options = options || {};\n\n  if (sql) {\n    return this.sequelize.query(sql, options);\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Helper methods useful for querying\n\n/**\n * Escape an identifier (e.g. a table or attribute name). If force is true,\n * the identifier will be quoted even if the `quoteIdentifiers` option is\n * false.\n */\nQueryInterface.prototype.quoteIdentifier = function(identifier, force) {\n  return this.QueryGenerator.quoteIdentifier(identifier, force);\n};\n\nQueryInterface.prototype.quoteTable = function(identifier) {\n  return this.QueryGenerator.quoteTable(identifier);\n};\n\n/**\n * Split an identifier into .-separated tokens and quote each part.\n * If force is true, the identifier will be quoted even if the\n * `quoteIdentifiers` option is false.\n */\nQueryInterface.prototype.quoteIdentifiers = function(identifiers, force) {\n  return this.QueryGenerator.quoteIdentifiers(identifiers, force);\n};\n\n/**\n * Escape a value (e.g. a string, number or date)\n */\nQueryInterface.prototype.escape = function(value) {\n  return this.QueryGenerator.escape(value);\n};\n\nQueryInterface.prototype.setAutocommit = function(transaction, value, options) {\n  if (!transaction || !(transaction instanceof Transaction)) {\n    throw new Error('Unable to set autocommit for a transaction without transaction object!');\n  }\n  if (transaction.parent) {\n    // Not possible to set a seperate isolation level for savepoints\n    return Promise.resolve();\n  }\n\n  options = _.assign({}, options, {\n    transaction: transaction.parent || transaction\n  });\n\n  var sql = this.QueryGenerator.setAutocommitQuery(value, {\n    parent: transaction.parent\n  });\n\n  if (!sql) return Promise.resolve();\n\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.setIsolationLevel = function(transaction, value, options) {\n  if (!transaction || !(transaction instanceof Transaction)) {\n    throw new Error('Unable to set isolation level for a transaction without transaction object!');\n  }\n  if (transaction.parent) {\n    // Not possible to set a seperate isolation level for savepoints\n    return Promise.resolve();\n  }\n\n  options = _.assign({}, options, {\n    transaction: transaction.parent || transaction\n  });\n\n  var sql = this.QueryGenerator.setIsolationLevelQuery(value, {\n    parent: transaction.parent\n  });\n\n  if (!sql) return Promise.resolve();\n\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.startTransaction = function(transaction, options) {\n  if (!transaction || !(transaction instanceof Transaction)) {\n    throw new Error('Unable to start a transaction without transaction object!');\n  }\n\n  options = _.assign({}, options, {\n    transaction: transaction.parent || transaction\n  });\n  options.transaction.name = transaction.parent ? transaction.name : undefined;\n  var sql = this.QueryGenerator.startTransactionQuery(transaction);\n\n  return this.sequelize.query(sql, options);\n};\n\nQueryInterface.prototype.deferConstraints = function (transaction, options) {\n  options = _.assign({}, options, {\n    transaction: transaction.parent || transaction\n  });\n\n  var sql = this.QueryGenerator.deferConstraintsQuery(options);\n\n  if (sql) {\n    return this.sequelize.query(sql, options);\n  }\n\n  return Promise.resolve();\n};\n\nQueryInterface.prototype.commitTransaction = function(transaction, options) {\n  if (!transaction || !(transaction instanceof Transaction)) {\n    throw new Error('Unable to commit a transaction without transaction object!');\n  }\n  if (transaction.parent) {\n    // Savepoints cannot be committed\n    return Promise.resolve();\n  }\n\n  options = _.assign({}, options, {\n    transaction: transaction.parent || transaction,\n    supportsSearchPath: false\n  });\n\n  var sql = this.QueryGenerator.commitTransactionQuery(transaction);\n  var promise = this.sequelize.query(sql, options);\n\n  transaction.finished = 'commit';\n\n  return promise;\n};\n\nQueryInterface.prototype.rollbackTransaction = function(transaction, options) {\n  if (!transaction || !(transaction instanceof Transaction)) {\n    throw new Error('Unable to rollback a transaction without transaction object!');\n  }\n\n  options = _.assign({}, options, {\n    transaction: transaction.parent || transaction,\n    supportsSearchPath: false\n  });\n  options.transaction.name = transaction.parent ? transaction.name : undefined;\n  var sql = this.QueryGenerator.rollbackTransactionQuery(transaction);\n  var promise = this.sequelize.query(sql, options);\n\n  transaction.finished = 'rollback';\n\n  return promise;\n};\n\nmodule.exports = QueryInterface;\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/sqlite/query-interface.js":"'use strict';\n\nvar Utils = require('../../utils')\n  , Promise = require('../../promise');\n\n/**\n Returns an object that treats SQLite's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n */\n\n/**\n  A wrapper that fixes SQLite's inability to remove columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but without the obsolete column.\n\n  @method removeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName     The name of the table.\n  @param  {String} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n */\nvar removeColumn = function(tableName, attributeName, options) {\n  var self = this;\n  options = options || {};\n\n  return this.describeTable(tableName, options).then(function(fields) {\n    delete fields[attributeName];\n\n    var sql = self.QueryGenerator.removeColumnQuery(tableName, fields)\n      , subQueries = sql.split(';').filter(function(q) { return q !== ''; });\n\n    return Promise.each(subQueries, function(subQuery) {\n      return self.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options));\n    });\n  });\n};\n\n/**\n  A wrapper that fixes SQLite's inability to change columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a modified version of the respective column.\n\n  @method changeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName The name of the table.\n  @param  {Object} attributes An object with the attribute's name as key and it's options as value object.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n */\nvar changeColumn = function(tableName, attributes, options) {\n  var attributeName = Utils._.keys(attributes)[0]\n    , self = this;\n  options = options || {};\n\n  return this.describeTable(tableName, options).then(function(fields) {\n    fields[attributeName] = attributes[attributeName];\n\n    var sql = self.QueryGenerator.removeColumnQuery(tableName, fields)\n      , subQueries = sql.split(';').filter(function(q) { return q !== ''; });\n\n    return Promise.each(subQueries, function(subQuery) {\n      return self.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options));\n    });\n  });\n};\n\n/**\n  A wrapper that fixes SQLite's inability to rename columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a renamed version of the respective column.\n\n  @method renameColumn\n  @for    QueryInterface\n\n  @param  {String} tableName The name of the table.\n  @param  {String} attrNameBefore The name of the attribute before it was renamed.\n  @param  {String} attrNameAfter The name of the attribute after it was renamed.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n */\nvar renameColumn = function(tableName, attrNameBefore, attrNameAfter, options) {\n  var self = this;\n  options = options || {};\n\n  return this.describeTable(tableName, options).then(function(fields) {\n    fields[attrNameAfter] = Utils._.clone(fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n\n    var sql = self.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields)\n      , subQueries = sql.split(';').filter(function(q) { return q !== ''; });\n\n    return Promise.each(subQueries, function(subQuery) {\n      return self.sequelize.query(subQuery + ';', Utils._.assign({raw: true}, options));\n    });\n  });\n};\n\nmodule.exports = {\n  removeColumn: removeColumn,\n  changeColumn: changeColumn,\n  renameColumn: renameColumn\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/mssql/query-interface.js":"'use strict';\n\n/**\n Returns an object that treats MSSQL's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n */\n\n/**\n  A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.\n\n  @method removeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName     The name of the table.\n  @param  {String} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {Boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n */\nvar removeColumn = function (tableName, attributeName, options) {\n  var self = this;\n  options = options || {};\n\n  var findConstraintSql = self.QueryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n  return self.sequelize.query(findConstraintSql, { raw: true, logging: options.logging})\n    .spread(function (results) {\n      if (!results.length) {\n        // No default constraint found -- we can cleanly remove the column\n        return;\n      }\n      var dropConstraintSql = self.QueryGenerator.dropConstraintQuery(tableName, results[0].name);\n      return self.sequelize.query(dropConstraintSql, { raw: true, logging: options.logging});\n    })\n    .then(function () {\n      var findForeignKeySql = self.QueryGenerator.getForeignKeyQuery(tableName, attributeName);\n      return self.sequelize.query(findForeignKeySql , { raw: true, logging: options.logging});\n    })\n    .spread(function (results) {\n      if (!results.length) {\n        // No foreign key constraints found, so we can remove the column\n        return;\n      }\n      var dropForeignKeySql = self.QueryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      return self.sequelize.query(dropForeignKeySql , { raw: true, logging: options.logging});\n    })\n    .then(function() {\n      //Check if the current column is a primaryKey\n      var primaryKeyConstraintSql = self.QueryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n      return self.sequelize.query(primaryKeyConstraintSql, { raw: true, logging: options.logging });\n    })\n    .spread(function(result) {\n      if (!result.length) {\n        return;\n      }\n      var dropConstraintSql = self.QueryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      return self.sequelize.query(dropConstraintSql, { raw: true, logging: options.logging});\n    })\n    .then(function () {\n      var removeSql = self.QueryGenerator.removeColumnQuery(tableName, attributeName);\n      return self.sequelize.query(removeSql, { raw: true, logging: options.logging});\n    });\n};\n\nmodule.exports = {\n  removeColumn: removeColumn\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/dialects/mysql/query-interface.js":"'use strict';\n\n/**\n Returns an object that treats MySQL's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n */\n\nvar _ = require('lodash');\n\n/**\n  A wrapper that fixes MySQL's inability to cleanly remove columns from existing tables if they have a foreign key constraint.\n\n  @method removeColumn\n  @for    QueryInterface\n\n  @param  {String} tableName     The name of the table.\n  @param  {String} columnName    The name of the attribute that we want to remove.\n  @param  {Object} options\n */\nvar removeColumn = function (tableName, columnName, options) {\n  var self = this;\n  options = options || {};\n\n  return self.sequelize.query(\n      self.QueryGenerator.getForeignKeyQuery(tableName, columnName),\n      _.assign({ raw: true }, options)\n    )\n    .spread(function (results) {\n      //Exclude primary key constraint\n      if (!results.length || results[0].constraint_name === 'PRIMARY') {\n        // No foreign key constraints found, so we can remove the column\n        return;\n      }\n      return self.sequelize.query(\n          self.QueryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name),\n          _.assign({ raw: true }, options)\n        );\n    })\n    .then(function () {\n      return self.sequelize.query(\n          self.QueryGenerator.removeColumnQuery(tableName, columnName),\n          _.assign({ raw: true }, options)\n        );\n    });\n};\n\nmodule.exports = {\n  removeColumn: removeColumn\n};\n","/home/travis/build/npmtest/node-npmtest-sequelize/sequelize/lib/associations/index.js":"'use strict';\n\nvar Association = require('./base');\nAssociation.BelongsTo = require('./belongs-to');\nAssociation.HasOne = require('./has-one');\nAssociation.HasMany = require('./has-many');\nAssociation.BelongsToMany = require('./belongs-to-many');\n\nmodule.exports = Association;\n"}